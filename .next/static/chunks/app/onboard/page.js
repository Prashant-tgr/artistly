/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
(self["webpackChunk_N_E"] = self["webpackChunk_N_E"] || []).push([["app/onboard/page"],{

/***/ "(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Ctiger%5CDownloads%5Cartistly%5Capp%5Conboard%5Cpage.tsx&server=false!":
/*!**************************************************************************************************************************************************************************************!*\
  !*** ./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Ctiger%5CDownloads%5Cartistly%5Capp%5Conboard%5Cpage.tsx&server=false! ***!
  \**************************************************************************************************************************************************************************************/
/***/ (function(__unused_webpack_module, __unused_webpack_exports, __webpack_require__) {

eval(__webpack_require__.ts("Promise.resolve(/*! import() eager */).then(__webpack_require__.bind(__webpack_require__, /*! ./app/onboard/page.tsx */ \"(app-pages-browser)/./app/onboard/page.tsx\"))//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvYnVpbGQvd2VicGFjay9sb2FkZXJzL25leHQtZmxpZ2h0LWNsaWVudC1lbnRyeS1sb2FkZXIuanM/bW9kdWxlcz1DJTNBJTVDVXNlcnMlNUN0aWdlciU1Q0Rvd25sb2FkcyU1Q2FydGlzdGx5JTVDYXBwJTVDb25ib2FyZCU1Q3BhZ2UudHN4JnNlcnZlcj1mYWxzZSEiLCJtYXBwaW5ncyI6IkFBQUEiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLz9hYTMyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCgvKiB3ZWJwYWNrTW9kZTogXCJlYWdlclwiICovIFwiQzpcXFxcVXNlcnNcXFxcdGlnZXJcXFxcRG93bmxvYWRzXFxcXGFydGlzdGx5XFxcXGFwcFxcXFxvbmJvYXJkXFxcXHBhZ2UudHN4XCIpIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Ctiger%5CDownloads%5Cartistly%5Capp%5Conboard%5Cpage.tsx&server=false!\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js ***!
  \****************************************************************************************/
/***/ (function(__unused_webpack_module, exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * @license React\n * react-jsx-dev-runtime.development.js\n *\n * Copyright (c) Meta Platforms, Inc. and affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        var React = __webpack_require__(/*! next/dist/compiled/react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n        // ATTENTION\n        // When adding new symbols to this file,\n        // Please consider also adding to 'react-devtools-shared/src/backend/ReactSymbols'\n        // The Symbol used to tag the ReactElement-like types.\n        var REACT_ELEMENT_TYPE = Symbol.for(\"react.element\");\n        var REACT_PORTAL_TYPE = Symbol.for(\"react.portal\");\n        var REACT_FRAGMENT_TYPE = Symbol.for(\"react.fragment\");\n        var REACT_STRICT_MODE_TYPE = Symbol.for(\"react.strict_mode\");\n        var REACT_PROFILER_TYPE = Symbol.for(\"react.profiler\");\n        var REACT_PROVIDER_TYPE = Symbol.for(\"react.provider\");\n        var REACT_CONTEXT_TYPE = Symbol.for(\"react.context\");\n        var REACT_FORWARD_REF_TYPE = Symbol.for(\"react.forward_ref\");\n        var REACT_SUSPENSE_TYPE = Symbol.for(\"react.suspense\");\n        var REACT_SUSPENSE_LIST_TYPE = Symbol.for(\"react.suspense_list\");\n        var REACT_MEMO_TYPE = Symbol.for(\"react.memo\");\n        var REACT_LAZY_TYPE = Symbol.for(\"react.lazy\");\n        var REACT_OFFSCREEN_TYPE = Symbol.for(\"react.offscreen\");\n        var REACT_CACHE_TYPE = Symbol.for(\"react.cache\");\n        var MAYBE_ITERATOR_SYMBOL = Symbol.iterator;\n        var FAUX_ITERATOR_SYMBOL = \"@@iterator\";\n        function getIteratorFn(maybeIterable) {\n            if (maybeIterable === null || typeof maybeIterable !== \"object\") {\n                return null;\n            }\n            var maybeIterator = MAYBE_ITERATOR_SYMBOL && maybeIterable[MAYBE_ITERATOR_SYMBOL] || maybeIterable[FAUX_ITERATOR_SYMBOL];\n            if (typeof maybeIterator === \"function\") {\n                return maybeIterator;\n            }\n            return null;\n        }\n        var ReactSharedInternals = React.__SECRET_INTERNALS_DO_NOT_USE_OR_YOU_WILL_BE_FIRED;\n        function error(format) {\n            {\n                {\n                    for(var _len2 = arguments.length, args = new Array(_len2 > 1 ? _len2 - 1 : 0), _key2 = 1; _key2 < _len2; _key2++){\n                        args[_key2 - 1] = arguments[_key2];\n                    }\n                    printWarning(\"error\", format, args);\n                }\n            }\n        }\n        function printWarning(level, format, args) {\n            // When changing this logic, you might want to also\n            // update consoleWithStackDev.www.js as well.\n            {\n                var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n                var stack = ReactDebugCurrentFrame.getStackAddendum();\n                if (stack !== \"\") {\n                    format += \"%s\";\n                    args = args.concat([\n                        stack\n                    ]);\n                } // eslint-disable-next-line react-internal/safe-string-coercion\n                var argsWithFormat = args.map(function(item) {\n                    return String(item);\n                }); // Careful: RN currently depends on this prefix\n                argsWithFormat.unshift(\"Warning: \" + format); // We intentionally don't use spread (or .apply) directly because it\n                // breaks IE9: https://github.com/facebook/react/issues/13610\n                // eslint-disable-next-line react-internal/no-production-logging\n                Function.prototype.apply.call(console[level], console, argsWithFormat);\n            }\n        }\n        // -----------------------------------------------------------------------------\n        var enableScopeAPI = false; // Experimental Create Event Handle API.\n        var enableCacheElement = false;\n        var enableTransitionTracing = false; // No known bugs, but needs performance testing\n        var enableLegacyHidden = false; // Enables unstable_avoidThisFallback feature in Fiber\n        // stuff. Intended to enable React core members to more easily debug scheduling\n        // issues in DEV builds.\n        var enableDebugTracing = false;\n        var REACT_CLIENT_REFERENCE$2 = Symbol.for(\"react.client.reference\");\n        function isValidElementType(type) {\n            if (typeof type === \"string\" || typeof type === \"function\") {\n                return true;\n            } // Note: typeof might be other than 'symbol' or 'number' (e.g. if it's a polyfill).\n            if (type === REACT_FRAGMENT_TYPE || type === REACT_PROFILER_TYPE || enableDebugTracing || type === REACT_STRICT_MODE_TYPE || type === REACT_SUSPENSE_TYPE || type === REACT_SUSPENSE_LIST_TYPE || enableLegacyHidden || type === REACT_OFFSCREEN_TYPE || enableScopeAPI || enableCacheElement || enableTransitionTracing) {\n                return true;\n            }\n            if (typeof type === \"object\" && type !== null) {\n                if (type.$$typeof === REACT_LAZY_TYPE || type.$$typeof === REACT_MEMO_TYPE || type.$$typeof === REACT_PROVIDER_TYPE || type.$$typeof === REACT_CONTEXT_TYPE || type.$$typeof === REACT_FORWARD_REF_TYPE || // This needs to include all possible module reference object\n                // types supported by any Flight configuration anywhere since\n                // we don't know which Flight build this will end up being used\n                // with.\n                type.$$typeof === REACT_CLIENT_REFERENCE$2 || type.getModuleId !== undefined) {\n                    return true;\n                }\n            }\n            return false;\n        }\n        function getWrappedName(outerType, innerType, wrapperName) {\n            var displayName = outerType.displayName;\n            if (displayName) {\n                return displayName;\n            }\n            var functionName = innerType.displayName || innerType.name || \"\";\n            return functionName !== \"\" ? wrapperName + \"(\" + functionName + \")\" : wrapperName;\n        } // Keep in sync with react-reconciler/getComponentNameFromFiber\n        function getContextName(type) {\n            return type.displayName || \"Context\";\n        }\n        var REACT_CLIENT_REFERENCE$1 = Symbol.for(\"react.client.reference\"); // Note that the reconciler package should generally prefer to use getComponentNameFromFiber() instead.\n        function getComponentNameFromType(type) {\n            if (type == null) {\n                // Host root, text node or just invalid type.\n                return null;\n            }\n            if (typeof type === \"function\") {\n                if (type.$$typeof === REACT_CLIENT_REFERENCE$1) {\n                    // TODO: Create a convention for naming client references with debug info.\n                    return null;\n                }\n                return type.displayName || type.name || null;\n            }\n            if (typeof type === \"string\") {\n                return type;\n            }\n            switch(type){\n                case REACT_FRAGMENT_TYPE:\n                    return \"Fragment\";\n                case REACT_PORTAL_TYPE:\n                    return \"Portal\";\n                case REACT_PROFILER_TYPE:\n                    return \"Profiler\";\n                case REACT_STRICT_MODE_TYPE:\n                    return \"StrictMode\";\n                case REACT_SUSPENSE_TYPE:\n                    return \"Suspense\";\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return \"SuspenseList\";\n                case REACT_CACHE_TYPE:\n                    {\n                        return \"Cache\";\n                    }\n            }\n            if (typeof type === \"object\") {\n                {\n                    if (typeof type.tag === \"number\") {\n                        error(\"Received an unexpected object in getComponentNameFromType(). \" + \"This is likely a bug in React. Please file an issue.\");\n                    }\n                }\n                switch(type.$$typeof){\n                    case REACT_CONTEXT_TYPE:\n                        var context = type;\n                        return getContextName(context) + \".Consumer\";\n                    case REACT_PROVIDER_TYPE:\n                        var provider = type;\n                        return getContextName(provider._context) + \".Provider\";\n                    case REACT_FORWARD_REF_TYPE:\n                        return getWrappedName(type, type.render, \"ForwardRef\");\n                    case REACT_MEMO_TYPE:\n                        var outerName = type.displayName || null;\n                        if (outerName !== null) {\n                            return outerName;\n                        }\n                        return getComponentNameFromType(type.type) || \"Memo\";\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                return getComponentNameFromType(init(payload));\n                            } catch (x) {\n                                return null;\n                            }\n                        }\n                }\n            }\n            return null;\n        }\n        var assign = Object.assign;\n        // Helpers to patch console.logs to avoid logging during side-effect free\n        // replaying on render function. This currently only patches the object\n        // lazily which won't cover if the log function was extracted eagerly.\n        // We could also eagerly patch the method.\n        var disabledDepth = 0;\n        var prevLog;\n        var prevInfo;\n        var prevWarn;\n        var prevError;\n        var prevGroup;\n        var prevGroupCollapsed;\n        var prevGroupEnd;\n        function disabledLog() {}\n        disabledLog.__reactDisabledLog = true;\n        function disableLogs() {\n            {\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ prevLog = console.log;\n                    prevInfo = console.info;\n                    prevWarn = console.warn;\n                    prevError = console.error;\n                    prevGroup = console.group;\n                    prevGroupCollapsed = console.groupCollapsed;\n                    prevGroupEnd = console.groupEnd; // https://github.com/facebook/react/issues/19099\n                    var props = {\n                        configurable: true,\n                        enumerable: true,\n                        value: disabledLog,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        info: props,\n                        log: props,\n                        warn: props,\n                        error: props,\n                        group: props,\n                        groupCollapsed: props,\n                        groupEnd: props\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                disabledDepth++;\n            }\n        }\n        function reenableLogs() {\n            {\n                disabledDepth--;\n                if (disabledDepth === 0) {\n                    /* eslint-disable react-internal/no-production-logging */ var props = {\n                        configurable: true,\n                        enumerable: true,\n                        writable: true\n                    }; // $FlowFixMe[cannot-write] Flow thinks console is immutable.\n                    Object.defineProperties(console, {\n                        log: assign({}, props, {\n                            value: prevLog\n                        }),\n                        info: assign({}, props, {\n                            value: prevInfo\n                        }),\n                        warn: assign({}, props, {\n                            value: prevWarn\n                        }),\n                        error: assign({}, props, {\n                            value: prevError\n                        }),\n                        group: assign({}, props, {\n                            value: prevGroup\n                        }),\n                        groupCollapsed: assign({}, props, {\n                            value: prevGroupCollapsed\n                        }),\n                        groupEnd: assign({}, props, {\n                            value: prevGroupEnd\n                        })\n                    });\n                /* eslint-enable react-internal/no-production-logging */ }\n                if (disabledDepth < 0) {\n                    error(\"disabledDepth fell below zero. \" + \"This is a bug in React. Please file an issue.\");\n                }\n            }\n        }\n        var ReactCurrentDispatcher = ReactSharedInternals.ReactCurrentDispatcher;\n        var prefix;\n        function describeBuiltInComponentFrame(name, source, ownerFn) {\n            {\n                if (prefix === undefined) {\n                    // Extract the VM specific prefix used by each line.\n                    try {\n                        throw Error();\n                    } catch (x) {\n                        var match = x.stack.trim().match(/\\n( *(at )?)/);\n                        prefix = match && match[1] || \"\";\n                    }\n                } // We use the prefix to ensure our stacks line up with native stack frames.\n                return \"\\n\" + prefix + name;\n            }\n        }\n        var reentry = false;\n        var componentFrameCache;\n        {\n            var PossiblyWeakMap = typeof WeakMap === \"function\" ? WeakMap : Map;\n            componentFrameCache = new PossiblyWeakMap();\n        }\n        /**\n * Leverages native browser/VM stack frames to get proper details (e.g.\n * filename, line + col number) for a single component in a component stack. We\n * do this by:\n *   (1) throwing and catching an error in the function - this will be our\n *       control error.\n *   (2) calling the component which will eventually throw an error that we'll\n *       catch - this will be our sample error.\n *   (3) diffing the control and sample error stacks to find the stack frame\n *       which represents our component.\n */ function describeNativeComponentFrame(fn, construct) {\n            // If something asked for a stack inside a fake render, it should get ignored.\n            if (!fn || reentry) {\n                return \"\";\n            }\n            {\n                var frame = componentFrameCache.get(fn);\n                if (frame !== undefined) {\n                    return frame;\n                }\n            }\n            reentry = true;\n            var previousPrepareStackTrace = Error.prepareStackTrace; // $FlowFixMe[incompatible-type] It does accept undefined.\n            Error.prepareStackTrace = undefined;\n            var previousDispatcher;\n            {\n                previousDispatcher = ReactCurrentDispatcher.current; // Set the dispatcher in DEV because this might be call in the render function\n                // for warnings.\n                ReactCurrentDispatcher.current = null;\n                disableLogs();\n            }\n            /**\n   * Finding a common stack frame between sample and control errors can be\n   * tricky given the different types and levels of stack trace truncation from\n   * different JS VMs. So instead we'll attempt to control what that common\n   * frame should be through this object method:\n   * Having both the sample and control errors be in the function under the\n   * `DescribeNativeComponentFrameRoot` property, + setting the `name` and\n   * `displayName` properties of the function ensures that a stack\n   * frame exists that has the method name `DescribeNativeComponentFrameRoot` in\n   * it for both control and sample stacks.\n   */ var RunInRootFrame = {\n                DetermineComponentFrameRoot: function() {\n                    var control;\n                    try {\n                        // This should throw.\n                        if (construct) {\n                            // Something should be setting the props in the constructor.\n                            var Fake = function() {\n                                throw Error();\n                            }; // $FlowFixMe[prop-missing]\n                            Object.defineProperty(Fake.prototype, \"props\", {\n                                set: function() {\n                                    // We use a throwing setter instead of frozen or non-writable props\n                                    // because that won't throw in a non-strict mode function.\n                                    throw Error();\n                                }\n                            });\n                            if (typeof Reflect === \"object\" && Reflect.construct) {\n                                // We construct a different control for this case to include any extra\n                                // frames added by the construct call.\n                                try {\n                                    Reflect.construct(Fake, []);\n                                } catch (x) {\n                                    control = x;\n                                }\n                                Reflect.construct(fn, [], Fake);\n                            } else {\n                                try {\n                                    Fake.call();\n                                } catch (x) {\n                                    control = x;\n                                } // $FlowFixMe[prop-missing] found when upgrading Flow\n                                fn.call(Fake.prototype);\n                            }\n                        } else {\n                            try {\n                                throw Error();\n                            } catch (x) {\n                                control = x;\n                            } // TODO(luna): This will currently only throw if the function component\n                            // tries to access React/ReactDOM/props. We should probably make this throw\n                            // in simple components too\n                            var maybePromise = fn(); // If the function component returns a promise, it's likely an async\n                            // component, which we don't yet support. Attach a noop catch handler to\n                            // silence the error.\n                            // TODO: Implement component stacks for async client components?\n                            if (maybePromise && typeof maybePromise.catch === \"function\") {\n                                maybePromise.catch(function() {});\n                            }\n                        }\n                    } catch (sample) {\n                        // This is inlined manually because closure doesn't do it for us.\n                        if (sample && control && typeof sample.stack === \"string\") {\n                            return [\n                                sample.stack,\n                                control.stack\n                            ];\n                        }\n                    }\n                    return [\n                        null,\n                        null\n                    ];\n                }\n            }; // $FlowFixMe[prop-missing]\n            RunInRootFrame.DetermineComponentFrameRoot.displayName = \"DetermineComponentFrameRoot\";\n            var namePropDescriptor = Object.getOwnPropertyDescriptor(RunInRootFrame.DetermineComponentFrameRoot, \"name\"); // Before ES6, the `name` property was not configurable.\n            if (namePropDescriptor && namePropDescriptor.configurable) {\n                // V8 utilizes a function's `name` property when generating a stack trace.\n                Object.defineProperty(RunInRootFrame.DetermineComponentFrameRoot, // is set to `false`.\n                // $FlowFixMe[cannot-write]\n                \"name\", {\n                    value: \"DetermineComponentFrameRoot\"\n                });\n            }\n            try {\n                var _RunInRootFrame$Deter = RunInRootFrame.DetermineComponentFrameRoot(), sampleStack = _RunInRootFrame$Deter[0], controlStack = _RunInRootFrame$Deter[1];\n                if (sampleStack && controlStack) {\n                    // This extracts the first frame from the sample that isn't also in the control.\n                    // Skipping one frame that we assume is the frame that calls the two.\n                    var sampleLines = sampleStack.split(\"\\n\");\n                    var controlLines = controlStack.split(\"\\n\");\n                    var s = 0;\n                    var c = 0;\n                    while(s < sampleLines.length && !sampleLines[s].includes(\"DetermineComponentFrameRoot\")){\n                        s++;\n                    }\n                    while(c < controlLines.length && !controlLines[c].includes(\"DetermineComponentFrameRoot\")){\n                        c++;\n                    } // We couldn't find our intentionally injected common root frame, attempt\n                    // to find another common root frame by search from the bottom of the\n                    // control stack...\n                    if (s === sampleLines.length || c === controlLines.length) {\n                        s = sampleLines.length - 1;\n                        c = controlLines.length - 1;\n                        while(s >= 1 && c >= 0 && sampleLines[s] !== controlLines[c]){\n                            // We expect at least one stack frame to be shared.\n                            // Typically this will be the root most one. However, stack frames may be\n                            // cut off due to maximum stack limits. In this case, one maybe cut off\n                            // earlier than the other. We assume that the sample is longer or the same\n                            // and there for cut off earlier. So we should find the root most frame in\n                            // the sample somewhere in the control.\n                            c--;\n                        }\n                    }\n                    for(; s >= 1 && c >= 0; s--, c--){\n                        // Next we find the first one that isn't the same which should be the\n                        // frame that called our sample function and the control.\n                        if (sampleLines[s] !== controlLines[c]) {\n                            // In V8, the first line is describing the message but other VMs don't.\n                            // If we're about to return the first line, and the control is also on the same\n                            // line, that's a pretty good indicator that our sample threw at same line as\n                            // the control. I.e. before we entered the sample frame. So we ignore this result.\n                            // This can happen if you passed a class to function component, or non-function.\n                            if (s !== 1 || c !== 1) {\n                                do {\n                                    s--;\n                                    c--; // We may still have similar intermediate frames from the construct call.\n                                    // The next one that isn't the same should be our match though.\n                                    if (c < 0 || sampleLines[s] !== controlLines[c]) {\n                                        // V8 adds a \"new\" prefix for native classes. Let's remove it to make it prettier.\n                                        var _frame = \"\\n\" + sampleLines[s].replace(\" at new \", \" at \"); // If our component frame is labeled \"<anonymous>\"\n                                        // but we have a user-provided \"displayName\"\n                                        // splice it in to make the stack more readable.\n                                        if (fn.displayName && _frame.includes(\"<anonymous>\")) {\n                                            _frame = _frame.replace(\"<anonymous>\", fn.displayName);\n                                        }\n                                        if (true) {\n                                            if (typeof fn === \"function\") {\n                                                componentFrameCache.set(fn, _frame);\n                                            }\n                                        } // Return the line we found.\n                                        return _frame;\n                                    }\n                                }while (s >= 1 && c >= 0);\n                            }\n                            break;\n                        }\n                    }\n                }\n            } finally{\n                reentry = false;\n                {\n                    ReactCurrentDispatcher.current = previousDispatcher;\n                    reenableLogs();\n                }\n                Error.prepareStackTrace = previousPrepareStackTrace;\n            } // Fallback to just using the name if we couldn't make it throw.\n            var name = fn ? fn.displayName || fn.name : \"\";\n            var syntheticFrame = name ? describeBuiltInComponentFrame(name) : \"\";\n            {\n                if (typeof fn === \"function\") {\n                    componentFrameCache.set(fn, syntheticFrame);\n                }\n            }\n            return syntheticFrame;\n        }\n        function describeFunctionComponentFrame(fn, source, ownerFn) {\n            {\n                return describeNativeComponentFrame(fn, false);\n            }\n        }\n        function shouldConstruct(Component) {\n            var prototype = Component.prototype;\n            return !!(prototype && prototype.isReactComponent);\n        }\n        function describeUnknownElementTypeFrameInDEV(type, source, ownerFn) {\n            if (type == null) {\n                return \"\";\n            }\n            if (typeof type === \"function\") {\n                {\n                    return describeNativeComponentFrame(type, shouldConstruct(type));\n                }\n            }\n            if (typeof type === \"string\") {\n                return describeBuiltInComponentFrame(type);\n            }\n            switch(type){\n                case REACT_SUSPENSE_TYPE:\n                    return describeBuiltInComponentFrame(\"Suspense\");\n                case REACT_SUSPENSE_LIST_TYPE:\n                    return describeBuiltInComponentFrame(\"SuspenseList\");\n            }\n            if (typeof type === \"object\") {\n                switch(type.$$typeof){\n                    case REACT_FORWARD_REF_TYPE:\n                        return describeFunctionComponentFrame(type.render);\n                    case REACT_MEMO_TYPE:\n                        // Memo may contain any component type so we recursively resolve it.\n                        return describeUnknownElementTypeFrameInDEV(type.type, source, ownerFn);\n                    case REACT_LAZY_TYPE:\n                        {\n                            var lazyComponent = type;\n                            var payload = lazyComponent._payload;\n                            var init = lazyComponent._init;\n                            try {\n                                // Lazy may contain any component type so we recursively resolve it.\n                                return describeUnknownElementTypeFrameInDEV(init(payload), source, ownerFn);\n                            } catch (x) {}\n                        }\n                }\n            }\n            return \"\";\n        }\n        // $FlowFixMe[method-unbinding]\n        var hasOwnProperty = Object.prototype.hasOwnProperty;\n        var loggedTypeFailures = {};\n        var ReactDebugCurrentFrame$1 = ReactSharedInternals.ReactDebugCurrentFrame;\n        function setCurrentlyValidatingElement$1(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame$1.setExtraStackFrame(null);\n                }\n            }\n        }\n        function checkPropTypes(typeSpecs, values, location, componentName, element) {\n            {\n                // $FlowFixMe[incompatible-use] This is okay but Flow doesn't know it.\n                var has = Function.call.bind(hasOwnProperty);\n                for(var typeSpecName in typeSpecs){\n                    if (has(typeSpecs, typeSpecName)) {\n                        var error$1 = void 0; // Prop type validation may throw. In case they do, we don't want to\n                        // fail the render phase where it didn't fail before. So we log it.\n                        // After these have been cleaned up, we'll let them throw.\n                        try {\n                            // This is intentionally an invariant that gets caught. It's the same\n                            // behavior as without this statement except with a better message.\n                            if (typeof typeSpecs[typeSpecName] !== \"function\") {\n                                // eslint-disable-next-line react-internal/prod-error-codes\n                                var err = Error((componentName || \"React class\") + \": \" + location + \" type `\" + typeSpecName + \"` is invalid; \" + \"it must be a function, usually from the `prop-types` package, but received `\" + typeof typeSpecs[typeSpecName] + \"`.\" + \"This often happens because of typos such as `PropTypes.function` instead of `PropTypes.func`.\");\n                                err.name = \"Invariant Violation\";\n                                throw err;\n                            }\n                            error$1 = typeSpecs[typeSpecName](values, typeSpecName, componentName, location, null, \"SECRET_DO_NOT_PASS_THIS_OR_YOU_WILL_BE_FIRED\");\n                        } catch (ex) {\n                            error$1 = ex;\n                        }\n                        if (error$1 && !(error$1 instanceof Error)) {\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"%s: type specification of %s\" + \" `%s` is invalid; the type checker \" + \"function must return `null` or an `Error` but returned a %s. \" + \"You may have forgotten to pass an argument to the type checker \" + \"creator (arrayOf, instanceOf, objectOf, oneOf, oneOfType, and \" + \"shape all require an argument).\", componentName || \"React class\", location, typeSpecName, typeof error$1);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                        if (error$1 instanceof Error && !(error$1.message in loggedTypeFailures)) {\n                            // Only monitor this failure once because there tends to be a lot of the\n                            // same error.\n                            loggedTypeFailures[error$1.message] = true;\n                            setCurrentlyValidatingElement$1(element);\n                            error(\"Failed %s type: %s\", location, error$1.message);\n                            setCurrentlyValidatingElement$1(null);\n                        }\n                    }\n                }\n            }\n        }\n        var isArrayImpl = Array.isArray; // eslint-disable-next-line no-redeclare\n        function isArray(a) {\n            return isArrayImpl(a);\n        }\n        /*\n * The `'' + value` pattern (used in perf-sensitive code) throws for Symbol\n * and Temporal.* types. See https://github.com/facebook/react/pull/22064.\n *\n * The functions in this module will throw an easier-to-understand,\n * easier-to-debug exception with a clear errors message message explaining the\n * problem. (Instead of a confusing exception thrown inside the implementation\n * of the `value` object).\n */ // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function typeName(value) {\n            {\n                // toStringTag is needed for namespaced types like Temporal.Instant\n                var hasToStringTag = typeof Symbol === \"function\" && Symbol.toStringTag;\n                var type = hasToStringTag && value[Symbol.toStringTag] || value.constructor.name || \"Object\"; // $FlowFixMe[incompatible-return]\n                return type;\n            }\n        } // $FlowFixMe[incompatible-return] only called in DEV, so void return is not possible.\n        function willCoercionThrow(value) {\n            {\n                try {\n                    testStringCoercion(value);\n                    return false;\n                } catch (e) {\n                    return true;\n                }\n            }\n        }\n        function testStringCoercion(value) {\n            // If you ended up here by following an exception call stack, here's what's\n            // happened: you supplied an object or symbol value to React (as a prop, key,\n            // DOM attribute, CSS property, string ref, etc.) and when React tried to\n            // coerce it to a string using `'' + value`, an exception was thrown.\n            //\n            // The most common types that will cause this exception are `Symbol` instances\n            // and Temporal objects like `Temporal.Instant`. But any object that has a\n            // `valueOf` or `[Symbol.toPrimitive]` method that throws will also cause this\n            // exception. (Library authors do this to prevent users from using built-in\n            // numeric operators like `+` or comparison operators like `>=` because custom\n            // methods are needed to perform accurate arithmetic or comparison.)\n            //\n            // To fix the problem, coerce this object or symbol value to a string before\n            // passing it to React. The most reliable way is usually `String(value)`.\n            //\n            // To find which value is throwing, check the browser or debugger console.\n            // Before this exception was thrown, there should be `console.error` output\n            // that shows the type (Symbol, Temporal.PlainDate, etc.) that caused the\n            // problem and how that type was used: key, atrribute, input value prop, etc.\n            // In most cases, this console output also shows the component and its\n            // ancestor components where the exception happened.\n            //\n            // eslint-disable-next-line react-internal/safe-string-coercion\n            return \"\" + value;\n        }\n        function checkKeyStringCoercion(value) {\n            {\n                if (willCoercionThrow(value)) {\n                    error(\"The provided key is an unsupported type %s.\" + \" This value must be coerced to a string before using it here.\", typeName(value));\n                    return testStringCoercion(value); // throw (to help callers find troubleshooting comments)\n                }\n            }\n        }\n        var ReactCurrentOwner$1 = ReactSharedInternals.ReactCurrentOwner;\n        var RESERVED_PROPS = {\n            key: true,\n            ref: true,\n            __self: true,\n            __source: true\n        };\n        var specialPropKeyWarningShown;\n        var specialPropRefWarningShown;\n        var didWarnAboutStringRefs;\n        {\n            didWarnAboutStringRefs = {};\n        }\n        function hasValidRef(config) {\n            {\n                if (hasOwnProperty.call(config, \"ref\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"ref\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.ref !== undefined;\n        }\n        function hasValidKey(config) {\n            {\n                if (hasOwnProperty.call(config, \"key\")) {\n                    var getter = Object.getOwnPropertyDescriptor(config, \"key\").get;\n                    if (getter && getter.isReactWarning) {\n                        return false;\n                    }\n                }\n            }\n            return config.key !== undefined;\n        }\n        function warnIfStringRefCannotBeAutoConverted(config, self) {\n            {\n                if (typeof config.ref === \"string\" && ReactCurrentOwner$1.current && self && ReactCurrentOwner$1.current.stateNode !== self) {\n                    var componentName = getComponentNameFromType(ReactCurrentOwner$1.current.type);\n                    if (!didWarnAboutStringRefs[componentName]) {\n                        error('Component \"%s\" contains the string ref \"%s\". ' + \"Support for string refs will be removed in a future major release. \" + \"This case cannot be automatically converted to an arrow function. \" + \"We ask you to manually fix this case by using useRef() or createRef() instead. \" + \"Learn more about using refs safely here: \" + \"https://reactjs.org/link/strict-mode-string-ref\", getComponentNameFromType(ReactCurrentOwner$1.current.type), config.ref);\n                        didWarnAboutStringRefs[componentName] = true;\n                    }\n                }\n            }\n        }\n        function defineKeyPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingKey = function() {\n                    if (!specialPropKeyWarningShown) {\n                        specialPropKeyWarningShown = true;\n                        error(\"%s: `key` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingKey.isReactWarning = true;\n                Object.defineProperty(props, \"key\", {\n                    get: warnAboutAccessingKey,\n                    configurable: true\n                });\n            }\n        }\n        function defineRefPropWarningGetter(props, displayName) {\n            {\n                var warnAboutAccessingRef = function() {\n                    if (!specialPropRefWarningShown) {\n                        specialPropRefWarningShown = true;\n                        error(\"%s: `ref` is not a prop. Trying to access it will result \" + \"in `undefined` being returned. If you need to access the same \" + \"value within the child component, you should pass it as a different \" + \"prop. (https://reactjs.org/link/special-props)\", displayName);\n                    }\n                };\n                warnAboutAccessingRef.isReactWarning = true;\n                Object.defineProperty(props, \"ref\", {\n                    get: warnAboutAccessingRef,\n                    configurable: true\n                });\n            }\n        }\n        /**\n * Factory method to create a new React element. This no longer adheres to\n * the class pattern, so do not use new to call it. Also, instanceof check\n * will not work. Instead test $$typeof field against Symbol.for('react.element') to check\n * if something is a React Element.\n *\n * @param {*} type\n * @param {*} props\n * @param {*} key\n * @param {string|object} ref\n * @param {*} owner\n * @param {*} self A *temporary* helper to detect places where `this` is\n * different from the `owner` when React.createElement is called, so that we\n * can warn. We want to get rid of owner and replace string `ref`s with arrow\n * functions, and as long as `this` and owner are the same, there will be no\n * change in behavior.\n * @param {*} source An annotation object (added by a transpiler or otherwise)\n * indicating filename, line number, and/or other information.\n * @internal\n */ function ReactElement(type, key, ref, self, source, owner, props) {\n            var element = {\n                // This tag allows us to uniquely identify this as a React Element\n                $$typeof: REACT_ELEMENT_TYPE,\n                // Built-in properties that belong on the element\n                type: type,\n                key: key,\n                ref: ref,\n                props: props,\n                // Record the component responsible for creating this element.\n                _owner: owner\n            };\n            {\n                // The validation flag is currently mutative. We put it on\n                // an external backing store so that we can freeze the whole object.\n                // This can be replaced with a WeakMap once they are implemented in\n                // commonly used development environments.\n                element._store = {}; // To make comparing ReactElements easier for testing purposes, we make\n                // the validation flag non-enumerable (where possible, which should\n                // include every environment we run tests in), so the test framework\n                // ignores it.\n                Object.defineProperty(element._store, \"validated\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: true,\n                    value: false\n                }); // self and source are DEV only properties.\n                Object.defineProperty(element, \"_self\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: self\n                }); // Two elements created in two different places should be considered\n                // equal for testing purposes and therefore we hide it from enumeration.\n                Object.defineProperty(element, \"_source\", {\n                    configurable: false,\n                    enumerable: false,\n                    writable: false,\n                    value: source\n                });\n                if (Object.freeze) {\n                    Object.freeze(element.props);\n                    Object.freeze(element);\n                }\n            }\n            return element;\n        }\n        /**\n * https://github.com/reactjs/rfcs/pull/107\n * @param {*} type\n * @param {object} props\n * @param {string} key\n */ function jsxDEV$1(type, config, maybeKey, source, self) {\n            {\n                var propName; // Reserved names are extracted\n                var props = {};\n                var key = null;\n                var ref = null; // Currently, key can be spread in as a prop. This causes a potential\n                // issue if key is also explicitly declared (ie. <div {...props} key=\"Hi\" />\n                // or <div key=\"Hi\" {...props} /> ). We want to deprecate key spread,\n                // but as an intermediary step, we will use jsxDEV for everything except\n                // <div {...props} key=\"Hi\" />, because we aren't currently able to tell if\n                // key is explicitly declared to be undefined or not.\n                if (maybeKey !== undefined) {\n                    {\n                        checkKeyStringCoercion(maybeKey);\n                    }\n                    key = \"\" + maybeKey;\n                }\n                if (hasValidKey(config)) {\n                    {\n                        checkKeyStringCoercion(config.key);\n                    }\n                    key = \"\" + config.key;\n                }\n                if (hasValidRef(config)) {\n                    ref = config.ref;\n                    warnIfStringRefCannotBeAutoConverted(config, self);\n                } // Remaining properties are added to a new props object\n                for(propName in config){\n                    if (hasOwnProperty.call(config, propName) && !RESERVED_PROPS.hasOwnProperty(propName)) {\n                        props[propName] = config[propName];\n                    }\n                } // Resolve default props\n                if (type && type.defaultProps) {\n                    var defaultProps = type.defaultProps;\n                    for(propName in defaultProps){\n                        if (props[propName] === undefined) {\n                            props[propName] = defaultProps[propName];\n                        }\n                    }\n                }\n                if (key || ref) {\n                    var displayName = typeof type === \"function\" ? type.displayName || type.name || \"Unknown\" : type;\n                    if (key) {\n                        defineKeyPropWarningGetter(props, displayName);\n                    }\n                    if (ref) {\n                        defineRefPropWarningGetter(props, displayName);\n                    }\n                }\n                return ReactElement(type, key, ref, self, source, ReactCurrentOwner$1.current, props);\n            }\n        }\n        var ReactCurrentOwner = ReactSharedInternals.ReactCurrentOwner;\n        var ReactDebugCurrentFrame = ReactSharedInternals.ReactDebugCurrentFrame;\n        var REACT_CLIENT_REFERENCE = Symbol.for(\"react.client.reference\");\n        function setCurrentlyValidatingElement(element) {\n            {\n                if (element) {\n                    var owner = element._owner;\n                    var stack = describeUnknownElementTypeFrameInDEV(element.type, element._source, owner ? owner.type : null);\n                    ReactDebugCurrentFrame.setExtraStackFrame(stack);\n                } else {\n                    ReactDebugCurrentFrame.setExtraStackFrame(null);\n                }\n            }\n        }\n        var propTypesMisspellWarningShown;\n        {\n            propTypesMisspellWarningShown = false;\n        }\n        /**\n * Verifies the object is a ReactElement.\n * See https://reactjs.org/docs/react-api.html#isvalidelement\n * @param {?object} object\n * @return {boolean} True if `object` is a ReactElement.\n * @final\n */ function isValidElement(object) {\n            {\n                return typeof object === \"object\" && object !== null && object.$$typeof === REACT_ELEMENT_TYPE;\n            }\n        }\n        function getDeclarationErrorAddendum() {\n            {\n                if (ReactCurrentOwner.current) {\n                    var name = getComponentNameFromType(ReactCurrentOwner.current.type);\n                    if (name) {\n                        return \"\\n\\nCheck the render method of `\" + name + \"`.\";\n                    }\n                }\n                return \"\";\n            }\n        }\n        function getSourceInfoErrorAddendum(source) {\n            {\n                if (source !== undefined) {\n                    var fileName = source.fileName.replace(/^.*[\\\\\\/]/, \"\");\n                    var lineNumber = source.lineNumber;\n                    return \"\\n\\nCheck your code at \" + fileName + \":\" + lineNumber + \".\";\n                }\n                return \"\";\n            }\n        }\n        /**\n * Warn if there's no key explicitly set on dynamic arrays of children or\n * object keys are not valid. This allows us to keep track of children between\n * updates.\n */ var ownerHasKeyUseWarning = {};\n        function getCurrentComponentErrorInfo(parentType) {\n            {\n                var info = getDeclarationErrorAddendum();\n                if (!info) {\n                    var parentName = getComponentNameFromType(parentType);\n                    if (parentName) {\n                        info = \"\\n\\nCheck the top-level render call using <\" + parentName + \">.\";\n                    }\n                }\n                return info;\n            }\n        }\n        /**\n * Warn if the element doesn't have an explicit key assigned to it.\n * This element is in an array. The array could grow and shrink or be\n * reordered. All children that haven't already been validated are required to\n * have a \"key\" property assigned to it. Error statuses are cached so a warning\n * will only be shown once.\n *\n * @internal\n * @param {ReactElement} element Element that requires a key.\n * @param {*} parentType element's parent's type.\n */ function validateExplicitKey(element, parentType) {\n            {\n                if (!element._store || element._store.validated || element.key != null) {\n                    return;\n                }\n                element._store.validated = true;\n                var currentComponentErrorInfo = getCurrentComponentErrorInfo(parentType);\n                if (ownerHasKeyUseWarning[currentComponentErrorInfo]) {\n                    return;\n                }\n                ownerHasKeyUseWarning[currentComponentErrorInfo] = true; // Usually the current owner is the offender, but if it accepts children as a\n                // property, it may be the creator of the child that's responsible for\n                // assigning it a key.\n                var childOwner = \"\";\n                if (element && element._owner && element._owner !== ReactCurrentOwner.current) {\n                    // Give the component that originally created this child.\n                    childOwner = \" It was passed a child from \" + getComponentNameFromType(element._owner.type) + \".\";\n                }\n                setCurrentlyValidatingElement(element);\n                error('Each child in a list should have a unique \"key\" prop.' + \"%s%s See https://reactjs.org/link/warning-keys for more information.\", currentComponentErrorInfo, childOwner);\n                setCurrentlyValidatingElement(null);\n            }\n        }\n        /**\n * Ensure that every element either is passed in a static location, in an\n * array with an explicit keys property defined, or in an object literal\n * with valid key property.\n *\n * @internal\n * @param {ReactNode} node Statically passed child of any type.\n * @param {*} parentType node's parent's type.\n */ function validateChildKeys(node, parentType) {\n            {\n                if (typeof node !== \"object\" || !node) {\n                    return;\n                }\n                if (node.$$typeof === REACT_CLIENT_REFERENCE) ;\n                else if (isArray(node)) {\n                    for(var i = 0; i < node.length; i++){\n                        var child = node[i];\n                        if (isValidElement(child)) {\n                            validateExplicitKey(child, parentType);\n                        }\n                    }\n                } else if (isValidElement(node)) {\n                    // This element was passed in a valid location.\n                    if (node._store) {\n                        node._store.validated = true;\n                    }\n                } else {\n                    var iteratorFn = getIteratorFn(node);\n                    if (typeof iteratorFn === \"function\") {\n                        // Entry iterators used to provide implicit keys,\n                        // but now we print a separate warning for them later.\n                        if (iteratorFn !== node.entries) {\n                            var iterator = iteratorFn.call(node);\n                            var step;\n                            while(!(step = iterator.next()).done){\n                                if (isValidElement(step.value)) {\n                                    validateExplicitKey(step.value, parentType);\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n        /**\n * Given an element, validate that its props follow the propTypes definition,\n * provided by the type.\n *\n * @param {ReactElement} element\n */ function validatePropTypes(element) {\n            {\n                var type = element.type;\n                if (type === null || type === undefined || typeof type === \"string\") {\n                    return;\n                }\n                if (type.$$typeof === REACT_CLIENT_REFERENCE) {\n                    return;\n                }\n                var propTypes;\n                if (typeof type === \"function\") {\n                    propTypes = type.propTypes;\n                } else if (typeof type === \"object\" && (type.$$typeof === REACT_FORWARD_REF_TYPE || // Note: Memo only checks outer props here.\n                // Inner props are checked in the reconciler.\n                type.$$typeof === REACT_MEMO_TYPE)) {\n                    propTypes = type.propTypes;\n                } else {\n                    return;\n                }\n                if (propTypes) {\n                    // Intentionally inside to avoid triggering lazy initializers:\n                    var name = getComponentNameFromType(type);\n                    checkPropTypes(propTypes, element.props, \"prop\", name, element);\n                } else if (type.PropTypes !== undefined && !propTypesMisspellWarningShown) {\n                    propTypesMisspellWarningShown = true; // Intentionally inside to avoid triggering lazy initializers:\n                    var _name = getComponentNameFromType(type);\n                    error(\"Component %s declared `PropTypes` instead of `propTypes`. Did you misspell the property assignment?\", _name || \"Unknown\");\n                }\n                if (typeof type.getDefaultProps === \"function\" && !type.getDefaultProps.isReactClassApproved) {\n                    error(\"getDefaultProps is only used on classic React.createClass \" + \"definitions. Use a static property named `defaultProps` instead.\");\n                }\n            }\n        }\n        /**\n * Given a fragment, validate that it can only be provided with fragment props\n * @param {ReactElement} fragment\n */ function validateFragmentProps(fragment) {\n            {\n                var keys = Object.keys(fragment.props);\n                for(var i = 0; i < keys.length; i++){\n                    var key = keys[i];\n                    if (key !== \"children\" && key !== \"key\") {\n                        setCurrentlyValidatingElement(fragment);\n                        error(\"Invalid prop `%s` supplied to `React.Fragment`. \" + \"React.Fragment can only have `key` and `children` props.\", key);\n                        setCurrentlyValidatingElement(null);\n                        break;\n                    }\n                }\n                if (fragment.ref !== null) {\n                    setCurrentlyValidatingElement(fragment);\n                    error(\"Invalid attribute `ref` supplied to `React.Fragment`.\");\n                    setCurrentlyValidatingElement(null);\n                }\n            }\n        }\n        var didWarnAboutKeySpread = {};\n        function jsxWithValidation(type, props, key, isStaticChildren, source, self) {\n            {\n                var validType = isValidElementType(type); // We warn in this case but don't throw. We expect the element creation to\n                // succeed and there will likely be errors in render.\n                if (!validType) {\n                    var info = \"\";\n                    if (type === undefined || typeof type === \"object\" && type !== null && Object.keys(type).length === 0) {\n                        info += \" You likely forgot to export your component from the file \" + \"it's defined in, or you might have mixed up default and named imports.\";\n                    }\n                    var sourceInfo = getSourceInfoErrorAddendum(source);\n                    if (sourceInfo) {\n                        info += sourceInfo;\n                    } else {\n                        info += getDeclarationErrorAddendum();\n                    }\n                    var typeString;\n                    if (type === null) {\n                        typeString = \"null\";\n                    } else if (isArray(type)) {\n                        typeString = \"array\";\n                    } else if (type !== undefined && type.$$typeof === REACT_ELEMENT_TYPE) {\n                        typeString = \"<\" + (getComponentNameFromType(type.type) || \"Unknown\") + \" />\";\n                        info = \" Did you accidentally export a JSX literal instead of a component?\";\n                    } else {\n                        typeString = typeof type;\n                    }\n                    error(\"React.jsx: type is invalid -- expected a string (for \" + \"built-in components) or a class/function (for composite \" + \"components) but got: %s.%s\", typeString, info);\n                }\n                var element = jsxDEV$1(type, props, key, source, self); // The result can be nullish if a mock or a custom function is used.\n                // TODO: Drop this when these are no longer allowed as the type argument.\n                if (element == null) {\n                    return element;\n                } // Skip key warning if the type isn't valid since our key validation logic\n                // doesn't expect a non-string/function type and can throw confusing errors.\n                // We don't want exception behavior to differ between dev and prod.\n                // (Rendering will throw with a helpful message and as soon as the type is\n                // fixed, the key warnings will appear.)\n                if (validType) {\n                    var children = props.children;\n                    if (children !== undefined) {\n                        if (isStaticChildren) {\n                            if (isArray(children)) {\n                                for(var i = 0; i < children.length; i++){\n                                    validateChildKeys(children[i], type);\n                                }\n                                if (Object.freeze) {\n                                    Object.freeze(children);\n                                }\n                            } else {\n                                error(\"React.jsx: Static children should always be an array. \" + \"You are likely explicitly calling React.jsxs or React.jsxDEV. \" + \"Use the Babel transform instead.\");\n                            }\n                        } else {\n                            validateChildKeys(children, type);\n                        }\n                    }\n                }\n                if (hasOwnProperty.call(props, \"key\")) {\n                    var componentName = getComponentNameFromType(type);\n                    var keys = Object.keys(props).filter(function(k) {\n                        return k !== \"key\";\n                    });\n                    var beforeExample = keys.length > 0 ? \"{key: someKey, \" + keys.join(\": ..., \") + \": ...}\" : \"{key: someKey}\";\n                    if (!didWarnAboutKeySpread[componentName + beforeExample]) {\n                        var afterExample = keys.length > 0 ? \"{\" + keys.join(\": ..., \") + \": ...}\" : \"{}\";\n                        error('A props object containing a \"key\" prop is being spread into JSX:\\n' + \"  let props = %s;\\n\" + \"  <%s {...props} />\\n\" + \"React keys must be passed directly to JSX without using spread:\\n\" + \"  let props = %s;\\n\" + \"  <%s key={someKey} {...props} />\", beforeExample, componentName, afterExample, componentName);\n                        didWarnAboutKeySpread[componentName + beforeExample] = true;\n                    }\n                }\n                if (type === REACT_FRAGMENT_TYPE) {\n                    validateFragmentProps(element);\n                } else {\n                    validatePropTypes(element);\n                }\n                return element;\n            }\n        } // These two functions exist to still get child warnings in dev\n        var jsxDEV = jsxWithValidation;\n        exports.Fragment = REACT_FRAGMENT_TYPE;\n        exports.jsxDEV = jsxDEV;\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvY2pzL3JlYWN0LWpzeC1kZXYtcnVudGltZS5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUNIO1FBRUEsSUFBSUMsUUFBUUMsbUJBQU9BLENBQUMsc0dBQTBCO1FBRTlDLFlBQVk7UUFDWix3Q0FBd0M7UUFDeEMsa0ZBQWtGO1FBQ2xGLHNEQUFzRDtRQUN0RCxJQUFJQyxxQkFBcUJDLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJQyxvQkFBb0JGLE9BQU9DLEdBQUcsQ0FBQztRQUNuQyxJQUFJRSxzQkFBc0JILE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJRyx5QkFBeUJKLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJSSxzQkFBc0JMLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJSyxzQkFBc0JOLE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJTSxxQkFBcUJQLE9BQU9DLEdBQUcsQ0FBQztRQUNwQyxJQUFJTyx5QkFBeUJSLE9BQU9DLEdBQUcsQ0FBQztRQUN4QyxJQUFJUSxzQkFBc0JULE9BQU9DLEdBQUcsQ0FBQztRQUNyQyxJQUFJUywyQkFBMkJWLE9BQU9DLEdBQUcsQ0FBQztRQUMxQyxJQUFJVSxrQkFBa0JYLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJVyxrQkFBa0JaLE9BQU9DLEdBQUcsQ0FBQztRQUNqQyxJQUFJWSx1QkFBdUJiLE9BQU9DLEdBQUcsQ0FBQztRQUN0QyxJQUFJYSxtQkFBbUJkLE9BQU9DLEdBQUcsQ0FBQztRQUNsQyxJQUFJYyx3QkFBd0JmLE9BQU9nQixRQUFRO1FBQzNDLElBQUlDLHVCQUF1QjtRQUMzQixTQUFTQyxjQUFjQyxhQUFhO1lBQ2xDLElBQUlBLGtCQUFrQixRQUFRLE9BQU9BLGtCQUFrQixVQUFVO2dCQUMv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LE9BQU8sUUFBUTtvQkFDckMsSUFBSXVFLGdCQUFnQnZHLHlCQUF5QmI7b0JBQzdDLElBQUlzTSxPQUFPM0ssT0FBTzJLLElBQUksQ0FBQ3pKLE9BQU9pSyxNQUFNLENBQUMsU0FBVUMsQ0FBQzt3QkFDOUMsT0FBT0EsTUFBTTtvQkFDZjtvQkFDQSxJQUFJQyxnQkFBZ0JWLEtBQUtqTyxNQUFNLEdBQUcsSUFBSSxvQkFBb0JpTyxLQUFLVyxJQUFJLENBQUMsYUFBYSxXQUFXO29CQUU1RixJQUFJLENBQUNWLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxFQUFFO3dCQUN6RCxJQUFJRSxlQUFlWixLQUFLak8sTUFBTSxHQUFHLElBQUksTUFBTWlPLEtBQUtXLElBQUksQ0FBQyxhQUFhLFdBQVc7d0JBRTdFaFAsTUFBTSx1RUFBdUUsd0JBQXdCLDBCQUEwQixzRUFBc0Usd0JBQXdCLHFDQUFxQytPLGVBQWU1RixlQUFlOEYsY0FBYzlGO3dCQUU5U21GLHFCQUFxQixDQUFDbkYsZ0JBQWdCNEYsY0FBYyxHQUFHO29CQUN6RDtnQkFDRjtnQkFFQSxJQUFJaE4sU0FBU25ELHFCQUFxQjtvQkFDaEN1UCxzQkFBc0J6RjtnQkFDeEIsT0FBTztvQkFDTG1GLGtCQUFrQm5GO2dCQUNwQjtnQkFFQSxPQUFPQTtZQUNUO1FBQ0YsRUFBRSwrREFBK0Q7UUFFakUsSUFBSXdHLFNBQVNYO1FBRWJZLGdCQUFnQixHQUFHdlE7UUFDbkJ1USxjQUFjLEdBQUdEO0lBQ2Y7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanM/ZmU2MiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiByZWFjdC1qc3gtZGV2LXJ1bnRpbWUuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIE1ldGEgUGxhdGZvcm1zLCBJbmMuIGFuZCBhZmZpbGlhdGVzLlxuICpcbiAqIFRoaXMgc291cmNlIGNvZGUgaXMgbGljZW5zZWQgdW5kZXIgdGhlIE1JVCBsaWNlbnNlIGZvdW5kIGluIHRoZVxuICogTElDRU5TRSBmaWxlIGluIHRoZSByb290IGRpcmVjdG9yeSBvZiB0aGlzIHNvdXJjZSB0cmVlLlxuICovXG5cbid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WICE9PSBcInByb2R1Y3Rpb25cIikge1xuICAoZnVuY3Rpb24oKSB7XG4ndXNlIHN0cmljdCc7XG5cbnZhciBSZWFjdCA9IHJlcXVpcmUoXCJuZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3RcIik7XG5cbi8vIEFUVEVOVElPTlxuLy8gV2hlbiBhZGRpbmcgbmV3IHN5bWJvbHMgdG8gdGhpcyBmaWxlLFxuLy8gUGxlYXNlIGNvbnNpZGVyIGFsc28gYWRkaW5nIHRvICdyZWFjdC1kZXZ0b29scy1zaGFyZWQvc3JjL2JhY2tlbmQvUmVhY3RTeW1ib2xzJ1xuLy8gVGhlIFN5bWJvbCB1c2VkIHRvIHRhZyB0aGUgUmVhY3RFbGVtZW50LWxpa2UgdHlwZXMuXG52YXIgUkVBQ1RfRUxFTUVOVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpO1xudmFyIFJFQUNUX1BPUlRBTF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QucG9ydGFsJyk7XG52YXIgUkVBQ1RfRlJBR01FTlRfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmZyYWdtZW50Jyk7XG52YXIgUkVBQ1RfU1RSSUNUX01PREVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN0cmljdF9tb2RlJyk7XG52YXIgUkVBQ1RfUFJPRklMRVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb2ZpbGVyJyk7XG52YXIgUkVBQ1RfUFJPVklERVJfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnByb3ZpZGVyJyk7XG52YXIgUkVBQ1RfQ09OVEVYVF9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QuY29udGV4dCcpO1xudmFyIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5mb3J3YXJkX3JlZicpO1xudmFyIFJFQUNUX1NVU1BFTlNFX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5zdXNwZW5zZScpO1xudmFyIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LnN1c3BlbnNlX2xpc3QnKTtcbnZhciBSRUFDVF9NRU1PX1RZUEUgPSBTeW1ib2wuZm9yKCdyZWFjdC5tZW1vJyk7XG52YXIgUkVBQ1RfTEFaWV9UWVBFID0gU3ltYm9sLmZvcigncmVhY3QubGF6eScpO1xudmFyIFJFQUNUX09GRlNDUkVFTl9UWVBFID0gU3ltYm9sLmZvcigncmVhY3Qub2Zmc2NyZWVuJyk7XG52YXIgUkVBQ1RfQ0FDSEVfVFlQRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNhY2hlJyk7XG52YXIgTUFZQkVfSVRFUkFUT1JfU1lNQk9MID0gU3ltYm9sLml0ZXJhdG9yO1xudmFyIEZBVVhfSVRFUkFUT1JfU1lNQk9MID0gJ0BAaXRlcmF0b3InO1xuZnVuY3Rpb24gZ2V0SXRlcmF0b3JGbihtYXliZUl0ZXJhYmxlKSB7XG4gIGlmIChtYXliZUl0ZXJhYmxlID09PSBudWxsIHx8IHR5cGVvZiBtYXliZUl0ZXJhYmxlICE9PSAnb2JqZWN0Jykge1xuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgdmFyIG1heWJlSXRlcmF0b3IgPSBNQVlCRV9JVEVSQVRPUl9TWU1CT0wgJiYgbWF5YmVJdGVyYWJsZVtNQVlCRV9JVEVSQVRPUl9TWU1CT0xdIHx8IG1heWJlSXRlcmFibGVbRkFVWF9JVEVSQVRPUl9TWU1CT0xdO1xuXG4gIGlmICh0eXBlb2YgbWF5YmVJdGVyYXRvciA9PT0gJ2Z1bmN0aW9uJykge1xuICAgIHJldHVybiBtYXliZUl0ZXJhdG9yO1xuICB9XG5cbiAgcmV0dXJuIG51bGw7XG59XG5cbnZhciBSZWFjdFNoYXJlZEludGVybmFscyA9IFJlYWN0Ll9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEO1xuXG5mdW5jdGlvbiBlcnJvcihmb3JtYXQpIHtcbiAge1xuICAgIHtcbiAgICAgIGZvciAodmFyIF9sZW4yID0gYXJndW1lbnRzLmxlbmd0aCwgYXJncyA9IG5ldyBBcnJheShfbGVuMiA+IDEgPyBfbGVuMiAtIDEgOiAwKSwgX2tleTIgPSAxOyBfa2V5MiA8IF9sZW4yOyBfa2V5MisrKSB7XG4gICAgICAgIGFyZ3NbX2tleTIgLSAxXSA9IGFyZ3VtZW50c1tfa2V5Ml07XG4gICAgICB9XG5cbiAgICAgIHByaW50V2FybmluZygnZXJyb3InLCBmb3JtYXQsIGFyZ3MpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBwcmludFdhcm5pbmcobGV2ZWwsIGZvcm1hdCwgYXJncykge1xuICAvLyBXaGVuIGNoYW5naW5nIHRoaXMgbG9naWMsIHlvdSBtaWdodCB3YW50IHRvIGFsc29cbiAgLy8gdXBkYXRlIGNvbnNvbGVXaXRoU3RhY2tEZXYud3d3LmpzIGFzIHdlbGwuXG4gIHtcbiAgICB2YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG4gICAgdmFyIHN0YWNrID0gUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5nZXRTdGFja0FkZGVuZHVtKCk7XG5cbiAgICBpZiAoc3RhY2sgIT09ICcnKSB7XG4gICAgICBmb3JtYXQgKz0gJyVzJztcbiAgICAgIGFyZ3MgPSBhcmdzLmNvbmNhdChbc3RhY2tdKTtcbiAgICB9IC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9zYWZlLXN0cmluZy1jb2VyY2lvblxuXG5cbiAgICB2YXIgYXJnc1dpdGhGb3JtYXQgPSBhcmdzLm1hcChmdW5jdGlvbiAoaXRlbSkge1xuICAgICAgcmV0dXJuIFN0cmluZyhpdGVtKTtcbiAgICB9KTsgLy8gQ2FyZWZ1bDogUk4gY3VycmVudGx5IGRlcGVuZHMgb24gdGhpcyBwcmVmaXhcblxuICAgIGFyZ3NXaXRoRm9ybWF0LnVuc2hpZnQoJ1dhcm5pbmc6ICcgKyBmb3JtYXQpOyAvLyBXZSBpbnRlbnRpb25hbGx5IGRvbid0IHVzZSBzcHJlYWQgKG9yIC5hcHBseSkgZGlyZWN0bHkgYmVjYXVzZSBpdFxuICAgIC8vIGJyZWFrcyBJRTk6IGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMTM2MTBcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nXG5cbiAgICBGdW5jdGlvbi5wcm90b3R5cGUuYXBwbHkuY2FsbChjb25zb2xlW2xldmVsXSwgY29uc29sZSwgYXJnc1dpdGhGb3JtYXQpO1xuICB9XG59XG5cbi8vIC0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tXG5cbnZhciBlbmFibGVTY29wZUFQSSA9IGZhbHNlOyAvLyBFeHBlcmltZW50YWwgQ3JlYXRlIEV2ZW50IEhhbmRsZSBBUEkuXG52YXIgZW5hYmxlQ2FjaGVFbGVtZW50ID0gZmFsc2U7XG52YXIgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgPSBmYWxzZTsgLy8gTm8ga25vd24gYnVncywgYnV0IG5lZWRzIHBlcmZvcm1hbmNlIHRlc3RpbmdcblxudmFyIGVuYWJsZUxlZ2FjeUhpZGRlbiA9IGZhbHNlOyAvLyBFbmFibGVzIHVuc3RhYmxlX2F2b2lkVGhpc0ZhbGxiYWNrIGZlYXR1cmUgaW4gRmliZXJcbi8vIHN0dWZmLiBJbnRlbmRlZCB0byBlbmFibGUgUmVhY3QgY29yZSBtZW1iZXJzIHRvIG1vcmUgZWFzaWx5IGRlYnVnIHNjaGVkdWxpbmdcbi8vIGlzc3VlcyBpbiBERVYgYnVpbGRzLlxuXG52YXIgZW5hYmxlRGVidWdUcmFjaW5nID0gZmFsc2U7XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7XG5mdW5jdGlvbiBpc1ZhbGlkRWxlbWVudFR5cGUodHlwZSkge1xuICBpZiAodHlwZW9mIHR5cGUgPT09ICdzdHJpbmcnIHx8IHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH0gLy8gTm90ZTogdHlwZW9mIG1pZ2h0IGJlIG90aGVyIHRoYW4gJ3N5bWJvbCcgb3IgJ251bWJlcicgKGUuZy4gaWYgaXQncyBhIHBvbHlmaWxsKS5cblxuXG4gIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1BST0ZJTEVSX1RZUEUgfHwgZW5hYmxlRGVidWdUcmFjaW5nICB8fCB0eXBlID09PSBSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIHx8IHR5cGUgPT09IFJFQUNUX1NVU1BFTlNFX1RZUEUgfHwgdHlwZSA9PT0gUkVBQ1RfU1VTUEVOU0VfTElTVF9UWVBFIHx8IGVuYWJsZUxlZ2FjeUhpZGRlbiAgfHwgdHlwZSA9PT0gUkVBQ1RfT0ZGU0NSRUVOX1RZUEUgfHwgZW5hYmxlU2NvcGVBUEkgIHx8IGVuYWJsZUNhY2hlRWxlbWVudCAgfHwgZW5hYmxlVHJhbnNpdGlvblRyYWNpbmcgKSB7XG4gICAgcmV0dXJuIHRydWU7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwpIHtcbiAgICBpZiAodHlwZS4kJHR5cGVvZiA9PT0gUkVBQ1RfTEFaWV9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9QUk9WSURFUl9UWVBFIHx8IHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NPTlRFWFRfVFlQRSB8fCB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIHx8IC8vIFRoaXMgbmVlZHMgdG8gaW5jbHVkZSBhbGwgcG9zc2libGUgbW9kdWxlIHJlZmVyZW5jZSBvYmplY3RcbiAgICAvLyB0eXBlcyBzdXBwb3J0ZWQgYnkgYW55IEZsaWdodCBjb25maWd1cmF0aW9uIGFueXdoZXJlIHNpbmNlXG4gICAgLy8gd2UgZG9uJ3Qga25vdyB3aGljaCBGbGlnaHQgYnVpbGQgdGhpcyB3aWxsIGVuZCB1cCBiZWluZyB1c2VkXG4gICAgLy8gd2l0aC5cbiAgICB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIgfHwgdHlwZS5nZXRNb2R1bGVJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZmFsc2U7XG59XG5cbmZ1bmN0aW9uIGdldFdyYXBwZWROYW1lKG91dGVyVHlwZSwgaW5uZXJUeXBlLCB3cmFwcGVyTmFtZSkge1xuICB2YXIgZGlzcGxheU5hbWUgPSBvdXRlclR5cGUuZGlzcGxheU5hbWU7XG5cbiAgaWYgKGRpc3BsYXlOYW1lKSB7XG4gICAgcmV0dXJuIGRpc3BsYXlOYW1lO1xuICB9XG5cbiAgdmFyIGZ1bmN0aW9uTmFtZSA9IGlubmVyVHlwZS5kaXNwbGF5TmFtZSB8fCBpbm5lclR5cGUubmFtZSB8fCAnJztcbiAgcmV0dXJuIGZ1bmN0aW9uTmFtZSAhPT0gJycgPyB3cmFwcGVyTmFtZSArIFwiKFwiICsgZnVuY3Rpb25OYW1lICsgXCIpXCIgOiB3cmFwcGVyTmFtZTtcbn0gLy8gS2VlcCBpbiBzeW5jIHdpdGggcmVhY3QtcmVjb25jaWxlci9nZXRDb21wb25lbnROYW1lRnJvbUZpYmVyXG5cblxuZnVuY3Rpb24gZ2V0Q29udGV4dE5hbWUodHlwZSkge1xuICByZXR1cm4gdHlwZS5kaXNwbGF5TmFtZSB8fCAnQ29udGV4dCc7XG59XG5cbnZhciBSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDEgPSBTeW1ib2wuZm9yKCdyZWFjdC5jbGllbnQucmVmZXJlbmNlJyk7IC8vIE5vdGUgdGhhdCB0aGUgcmVjb25jaWxlciBwYWNrYWdlIHNob3VsZCBnZW5lcmFsbHkgcHJlZmVyIHRvIHVzZSBnZXRDb21wb25lbnROYW1lRnJvbUZpYmVyKCkgaW5zdGVhZC5cblxuZnVuY3Rpb24gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpIHtcbiAgaWYgKHR5cGUgPT0gbnVsbCkge1xuICAgIC8vIEhvc3Qgcm9vdCwgdGV4dCBub2RlIG9yIGp1c3QgaW52YWxpZCB0eXBlLlxuICAgIHJldHVybiBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnZnVuY3Rpb24nKSB7XG4gICAgaWYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSkge1xuICAgICAgLy8gVE9ETzogQ3JlYXRlIGEgY29udmVudGlvbiBmb3IgbmFtaW5nIGNsaWVudCByZWZlcmVuY2VzIHdpdGggZGVidWcgaW5mby5cbiAgICAgIHJldHVybiBudWxsO1xuICAgIH1cblxuICAgIHJldHVybiB0eXBlLmRpc3BsYXlOYW1lIHx8IHR5cGUubmFtZSB8fCBudWxsO1xuICB9XG5cbiAgaWYgKHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiB0eXBlO1xuICB9XG5cbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSBSRUFDVF9GUkFHTUVOVF9UWVBFOlxuICAgICAgcmV0dXJuICdGcmFnbWVudCc7XG5cbiAgICBjYXNlIFJFQUNUX1BPUlRBTF9UWVBFOlxuICAgICAgcmV0dXJuICdQb3J0YWwnO1xuXG4gICAgY2FzZSBSRUFDVF9QUk9GSUxFUl9UWVBFOlxuICAgICAgcmV0dXJuICdQcm9maWxlcic7XG5cbiAgICBjYXNlIFJFQUNUX1NUUklDVF9NT0RFX1RZUEU6XG4gICAgICByZXR1cm4gJ1N0cmljdE1vZGUnO1xuXG4gICAgY2FzZSBSRUFDVF9TVVNQRU5TRV9UWVBFOlxuICAgICAgcmV0dXJuICdTdXNwZW5zZSc7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiAnU3VzcGVuc2VMaXN0JztcblxuICAgIGNhc2UgUkVBQ1RfQ0FDSEVfVFlQRTpcbiAgICAgIHtcbiAgICAgICAgcmV0dXJuICdDYWNoZSc7XG4gICAgICB9XG5cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcpIHtcbiAgICB7XG4gICAgICBpZiAodHlwZW9mIHR5cGUudGFnID09PSAnbnVtYmVyJykge1xuICAgICAgICBlcnJvcignUmVjZWl2ZWQgYW4gdW5leHBlY3RlZCBvYmplY3QgaW4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKCkuICcgKyAnVGhpcyBpcyBsaWtlbHkgYSBidWcgaW4gUmVhY3QuIFBsZWFzZSBmaWxlIGFuIGlzc3VlLicpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHN3aXRjaCAodHlwZS4kJHR5cGVvZikge1xuICAgICAgY2FzZSBSRUFDVF9DT05URVhUX1RZUEU6XG4gICAgICAgIHZhciBjb250ZXh0ID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKGNvbnRleHQpICsgJy5Db25zdW1lcic7XG5cbiAgICAgIGNhc2UgUkVBQ1RfUFJPVklERVJfVFlQRTpcbiAgICAgICAgdmFyIHByb3ZpZGVyID0gdHlwZTtcbiAgICAgICAgcmV0dXJuIGdldENvbnRleHROYW1lKHByb3ZpZGVyLl9jb250ZXh0KSArICcuUHJvdmlkZXInO1xuXG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBnZXRXcmFwcGVkTmFtZSh0eXBlLCB0eXBlLnJlbmRlciwgJ0ZvcndhcmRSZWYnKTtcblxuICAgICAgY2FzZSBSRUFDVF9NRU1PX1RZUEU6XG4gICAgICAgIHZhciBvdXRlck5hbWUgPSB0eXBlLmRpc3BsYXlOYW1lIHx8IG51bGw7XG5cbiAgICAgICAgaWYgKG91dGVyTmFtZSAhPT0gbnVsbCkge1xuICAgICAgICAgIHJldHVybiBvdXRlck5hbWU7XG4gICAgICAgIH1cblxuICAgICAgICByZXR1cm4gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUudHlwZSkgfHwgJ01lbW8nO1xuXG4gICAgICBjYXNlIFJFQUNUX0xBWllfVFlQRTpcbiAgICAgICAge1xuICAgICAgICAgIHZhciBsYXp5Q29tcG9uZW50ID0gdHlwZTtcbiAgICAgICAgICB2YXIgcGF5bG9hZCA9IGxhenlDb21wb25lbnQuX3BheWxvYWQ7XG4gICAgICAgICAgdmFyIGluaXQgPSBsYXp5Q29tcG9uZW50Ll9pbml0O1xuXG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHJldHVybiBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoaW5pdChwYXlsb2FkKSk7XG4gICAgICAgICAgfSBjYXRjaCAoeCkge1xuICAgICAgICAgICAgcmV0dXJuIG51bGw7XG4gICAgICAgICAgfVxuICAgICAgICB9XG5cbiAgICB9XG4gIH1cblxuICByZXR1cm4gbnVsbDtcbn1cblxudmFyIGFzc2lnbiA9IE9iamVjdC5hc3NpZ247XG5cbi8vIEhlbHBlcnMgdG8gcGF0Y2ggY29uc29sZS5sb2dzIHRvIGF2b2lkIGxvZ2dpbmcgZHVyaW5nIHNpZGUtZWZmZWN0IGZyZWVcbi8vIHJlcGxheWluZyBvbiByZW5kZXIgZnVuY3Rpb24uIFRoaXMgY3VycmVudGx5IG9ubHkgcGF0Y2hlcyB0aGUgb2JqZWN0XG4vLyBsYXppbHkgd2hpY2ggd29uJ3QgY292ZXIgaWYgdGhlIGxvZyBmdW5jdGlvbiB3YXMgZXh0cmFjdGVkIGVhZ2VybHkuXG4vLyBXZSBjb3VsZCBhbHNvIGVhZ2VybHkgcGF0Y2ggdGhlIG1ldGhvZC5cbnZhciBkaXNhYmxlZERlcHRoID0gMDtcbnZhciBwcmV2TG9nO1xudmFyIHByZXZJbmZvO1xudmFyIHByZXZXYXJuO1xudmFyIHByZXZFcnJvcjtcbnZhciBwcmV2R3JvdXA7XG52YXIgcHJldkdyb3VwQ29sbGFwc2VkO1xudmFyIHByZXZHcm91cEVuZDtcblxuZnVuY3Rpb24gZGlzYWJsZWRMb2coKSB7fVxuXG5kaXNhYmxlZExvZy5fX3JlYWN0RGlzYWJsZWRMb2cgPSB0cnVlO1xuZnVuY3Rpb24gZGlzYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICBwcmV2TG9nID0gY29uc29sZS5sb2c7XG4gICAgICBwcmV2SW5mbyA9IGNvbnNvbGUuaW5mbztcbiAgICAgIHByZXZXYXJuID0gY29uc29sZS53YXJuO1xuICAgICAgcHJldkVycm9yID0gY29uc29sZS5lcnJvcjtcbiAgICAgIHByZXZHcm91cCA9IGNvbnNvbGUuZ3JvdXA7XG4gICAgICBwcmV2R3JvdXBDb2xsYXBzZWQgPSBjb25zb2xlLmdyb3VwQ29sbGFwc2VkO1xuICAgICAgcHJldkdyb3VwRW5kID0gY29uc29sZS5ncm91cEVuZDsgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xOTA5OVxuXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgdmFsdWU6IGRpc2FibGVkTG9nLFxuICAgICAgICB3cml0YWJsZTogdHJ1ZVxuICAgICAgfTsgLy8gJEZsb3dGaXhNZVtjYW5ub3Qtd3JpdGVdIEZsb3cgdGhpbmtzIGNvbnNvbGUgaXMgaW1tdXRhYmxlLlxuXG4gICAgICBPYmplY3QuZGVmaW5lUHJvcGVydGllcyhjb25zb2xlLCB7XG4gICAgICAgIGluZm86IHByb3BzLFxuICAgICAgICBsb2c6IHByb3BzLFxuICAgICAgICB3YXJuOiBwcm9wcyxcbiAgICAgICAgZXJyb3I6IHByb3BzLFxuICAgICAgICBncm91cDogcHJvcHMsXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBwcm9wcyxcbiAgICAgICAgZ3JvdXBFbmQ6IHByb3BzXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgZGlzYWJsZWREZXB0aCsrO1xuICB9XG59XG5mdW5jdGlvbiByZWVuYWJsZUxvZ3MoKSB7XG4gIHtcbiAgICBkaXNhYmxlZERlcHRoLS07XG5cbiAgICBpZiAoZGlzYWJsZWREZXB0aCA9PT0gMCkge1xuICAgICAgLyogZXNsaW50LWRpc2FibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgICB2YXIgcHJvcHMgPSB7XG4gICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgd3JpdGFibGU6IHRydWVcbiAgICAgIH07IC8vICRGbG93Rml4TWVbY2Fubm90LXdyaXRlXSBGbG93IHRoaW5rcyBjb25zb2xlIGlzIGltbXV0YWJsZS5cblxuICAgICAgT2JqZWN0LmRlZmluZVByb3BlcnRpZXMoY29uc29sZSwge1xuICAgICAgICBsb2c6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkxvZ1xuICAgICAgICB9KSxcbiAgICAgICAgaW5mbzogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2SW5mb1xuICAgICAgICB9KSxcbiAgICAgICAgd2FybjogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2V2FyblxuICAgICAgICB9KSxcbiAgICAgICAgZXJyb3I6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkVycm9yXG4gICAgICAgIH0pLFxuICAgICAgICBncm91cDogYXNzaWduKHt9LCBwcm9wcywge1xuICAgICAgICAgIHZhbHVlOiBwcmV2R3JvdXBcbiAgICAgICAgfSksXG4gICAgICAgIGdyb3VwQ29sbGFwc2VkOiBhc3NpZ24oe30sIHByb3BzLCB7XG4gICAgICAgICAgdmFsdWU6IHByZXZHcm91cENvbGxhcHNlZFxuICAgICAgICB9KSxcbiAgICAgICAgZ3JvdXBFbmQ6IGFzc2lnbih7fSwgcHJvcHMsIHtcbiAgICAgICAgICB2YWx1ZTogcHJldkdyb3VwRW5kXG4gICAgICAgIH0pXG4gICAgICB9KTtcbiAgICAgIC8qIGVzbGludC1lbmFibGUgcmVhY3QtaW50ZXJuYWwvbm8tcHJvZHVjdGlvbi1sb2dnaW5nICovXG4gICAgfVxuXG4gICAgaWYgKGRpc2FibGVkRGVwdGggPCAwKSB7XG4gICAgICBlcnJvcignZGlzYWJsZWREZXB0aCBmZWxsIGJlbG93IHplcm8uICcgKyAnVGhpcyBpcyBhIGJ1ZyBpbiBSZWFjdC4gUGxlYXNlIGZpbGUgYW4gaXNzdWUuJyk7XG4gICAgfVxuICB9XG59XG5cbnZhciBSZWFjdEN1cnJlbnREaXNwYXRjaGVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50RGlzcGF0Y2hlcjtcbnZhciBwcmVmaXg7XG5mdW5jdGlvbiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZShuYW1lLCBzb3VyY2UsIG93bmVyRm4pIHtcbiAge1xuICAgIGlmIChwcmVmaXggPT09IHVuZGVmaW5lZCkge1xuICAgICAgLy8gRXh0cmFjdCB0aGUgVk0gc3BlY2lmaWMgcHJlZml4IHVzZWQgYnkgZWFjaCBsaW5lLlxuICAgICAgdHJ5IHtcbiAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgdmFyIG1hdGNoID0geC5zdGFjay50cmltKCkubWF0Y2goL1xcbiggKihhdCApPykvKTtcbiAgICAgICAgcHJlZml4ID0gbWF0Y2ggJiYgbWF0Y2hbMV0gfHwgJyc7XG4gICAgICB9XG4gICAgfSAvLyBXZSB1c2UgdGhlIHByZWZpeCB0byBlbnN1cmUgb3VyIHN0YWNrcyBsaW5lIHVwIHdpdGggbmF0aXZlIHN0YWNrIGZyYW1lcy5cblxuXG4gICAgcmV0dXJuICdcXG4nICsgcHJlZml4ICsgbmFtZTtcbiAgfVxufVxudmFyIHJlZW50cnkgPSBmYWxzZTtcbnZhciBjb21wb25lbnRGcmFtZUNhY2hlO1xuXG57XG4gIHZhciBQb3NzaWJseVdlYWtNYXAgPSB0eXBlb2YgV2Vha01hcCA9PT0gJ2Z1bmN0aW9uJyA/IFdlYWtNYXAgOiBNYXA7XG4gIGNvbXBvbmVudEZyYW1lQ2FjaGUgPSBuZXcgUG9zc2libHlXZWFrTWFwKCk7XG59XG4vKipcbiAqIExldmVyYWdlcyBuYXRpdmUgYnJvd3Nlci9WTSBzdGFjayBmcmFtZXMgdG8gZ2V0IHByb3BlciBkZXRhaWxzIChlLmcuXG4gKiBmaWxlbmFtZSwgbGluZSArIGNvbCBudW1iZXIpIGZvciBhIHNpbmdsZSBjb21wb25lbnQgaW4gYSBjb21wb25lbnQgc3RhY2suIFdlXG4gKiBkbyB0aGlzIGJ5OlxuICogICAoMSkgdGhyb3dpbmcgYW5kIGNhdGNoaW5nIGFuIGVycm9yIGluIHRoZSBmdW5jdGlvbiAtIHRoaXMgd2lsbCBiZSBvdXJcbiAqICAgICAgIGNvbnRyb2wgZXJyb3IuXG4gKiAgICgyKSBjYWxsaW5nIHRoZSBjb21wb25lbnQgd2hpY2ggd2lsbCBldmVudHVhbGx5IHRocm93IGFuIGVycm9yIHRoYXQgd2UnbGxcbiAqICAgICAgIGNhdGNoIC0gdGhpcyB3aWxsIGJlIG91ciBzYW1wbGUgZXJyb3IuXG4gKiAgICgzKSBkaWZmaW5nIHRoZSBjb250cm9sIGFuZCBzYW1wbGUgZXJyb3Igc3RhY2tzIHRvIGZpbmQgdGhlIHN0YWNrIGZyYW1lXG4gKiAgICAgICB3aGljaCByZXByZXNlbnRzIG91ciBjb21wb25lbnQuXG4gKi9cblxuXG5mdW5jdGlvbiBkZXNjcmliZU5hdGl2ZUNvbXBvbmVudEZyYW1lKGZuLCBjb25zdHJ1Y3QpIHtcbiAgLy8gSWYgc29tZXRoaW5nIGFza2VkIGZvciBhIHN0YWNrIGluc2lkZSBhIGZha2UgcmVuZGVyLCBpdCBzaG91bGQgZ2V0IGlnbm9yZWQuXG4gIGlmICghZm4gfHwgcmVlbnRyeSkge1xuICAgIHJldHVybiAnJztcbiAgfVxuXG4gIHtcbiAgICB2YXIgZnJhbWUgPSBjb21wb25lbnRGcmFtZUNhY2hlLmdldChmbik7XG5cbiAgICBpZiAoZnJhbWUgIT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIGZyYW1lO1xuICAgIH1cbiAgfVxuXG4gIHJlZW50cnkgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSA9IEVycm9yLnByZXBhcmVTdGFja1RyYWNlOyAvLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS10eXBlXSBJdCBkb2VzIGFjY2VwdCB1bmRlZmluZWQuXG5cbiAgRXJyb3IucHJlcGFyZVN0YWNrVHJhY2UgPSB1bmRlZmluZWQ7XG4gIHZhciBwcmV2aW91c0Rpc3BhdGNoZXI7XG5cbiAge1xuICAgIHByZXZpb3VzRGlzcGF0Y2hlciA9IFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudDsgLy8gU2V0IHRoZSBkaXNwYXRjaGVyIGluIERFViBiZWNhdXNlIHRoaXMgbWlnaHQgYmUgY2FsbCBpbiB0aGUgcmVuZGVyIGZ1bmN0aW9uXG4gICAgLy8gZm9yIHdhcm5pbmdzLlxuXG4gICAgUmVhY3RDdXJyZW50RGlzcGF0Y2hlci5jdXJyZW50ID0gbnVsbDtcbiAgICBkaXNhYmxlTG9ncygpO1xuICB9XG4gIC8qKlxuICAgKiBGaW5kaW5nIGEgY29tbW9uIHN0YWNrIGZyYW1lIGJldHdlZW4gc2FtcGxlIGFuZCBjb250cm9sIGVycm9ycyBjYW4gYmVcbiAgICogdHJpY2t5IGdpdmVuIHRoZSBkaWZmZXJlbnQgdHlwZXMgYW5kIGxldmVscyBvZiBzdGFjayB0cmFjZSB0cnVuY2F0aW9uIGZyb21cbiAgICogZGlmZmVyZW50IEpTIFZNcy4gU28gaW5zdGVhZCB3ZSdsbCBhdHRlbXB0IHRvIGNvbnRyb2wgd2hhdCB0aGF0IGNvbW1vblxuICAgKiBmcmFtZSBzaG91bGQgYmUgdGhyb3VnaCB0aGlzIG9iamVjdCBtZXRob2Q6XG4gICAqIEhhdmluZyBib3RoIHRoZSBzYW1wbGUgYW5kIGNvbnRyb2wgZXJyb3JzIGJlIGluIHRoZSBmdW5jdGlvbiB1bmRlciB0aGVcbiAgICogYERlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWVSb290YCBwcm9wZXJ0eSwgKyBzZXR0aW5nIHRoZSBgbmFtZWAgYW5kXG4gICAqIGBkaXNwbGF5TmFtZWAgcHJvcGVydGllcyBvZiB0aGUgZnVuY3Rpb24gZW5zdXJlcyB0aGF0IGEgc3RhY2tcbiAgICogZnJhbWUgZXhpc3RzIHRoYXQgaGFzIHRoZSBtZXRob2QgbmFtZSBgRGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZVJvb3RgIGluXG4gICAqIGl0IGZvciBib3RoIGNvbnRyb2wgYW5kIHNhbXBsZSBzdGFja3MuXG4gICAqL1xuXG5cbiAgdmFyIFJ1bkluUm9vdEZyYW1lID0ge1xuICAgIERldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdDogZnVuY3Rpb24gKCkge1xuICAgICAgdmFyIGNvbnRyb2w7XG5cbiAgICAgIHRyeSB7XG4gICAgICAgIC8vIFRoaXMgc2hvdWxkIHRocm93LlxuICAgICAgICBpZiAoY29uc3RydWN0KSB7XG4gICAgICAgICAgLy8gU29tZXRoaW5nIHNob3VsZCBiZSBzZXR0aW5nIHRoZSBwcm9wcyBpbiB0aGUgY29uc3RydWN0b3IuXG4gICAgICAgICAgdmFyIEZha2UgPSBmdW5jdGlvbiAoKSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH07IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXVxuXG5cbiAgICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoRmFrZS5wcm90b3R5cGUsICdwcm9wcycsIHtcbiAgICAgICAgICAgIHNldDogZnVuY3Rpb24gKCkge1xuICAgICAgICAgICAgICAvLyBXZSB1c2UgYSB0aHJvd2luZyBzZXR0ZXIgaW5zdGVhZCBvZiBmcm96ZW4gb3Igbm9uLXdyaXRhYmxlIHByb3BzXG4gICAgICAgICAgICAgIC8vIGJlY2F1c2UgdGhhdCB3b24ndCB0aHJvdyBpbiBhIG5vbi1zdHJpY3QgbW9kZSBmdW5jdGlvbi5cbiAgICAgICAgICAgICAgdGhyb3cgRXJyb3IoKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcblxuICAgICAgICAgIGlmICh0eXBlb2YgUmVmbGVjdCA9PT0gJ29iamVjdCcgJiYgUmVmbGVjdC5jb25zdHJ1Y3QpIHtcbiAgICAgICAgICAgIC8vIFdlIGNvbnN0cnVjdCBhIGRpZmZlcmVudCBjb250cm9sIGZvciB0aGlzIGNhc2UgdG8gaW5jbHVkZSBhbnkgZXh0cmFcbiAgICAgICAgICAgIC8vIGZyYW1lcyBhZGRlZCBieSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChGYWtlLCBbXSk7XG4gICAgICAgICAgICB9IGNhdGNoICh4KSB7XG4gICAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBSZWZsZWN0LmNvbnN0cnVjdChmbiwgW10sIEZha2UpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICBGYWtlLmNhbGwoKTtcbiAgICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgICAgY29udHJvbCA9IHg7XG4gICAgICAgICAgICB9IC8vICRGbG93Rml4TWVbcHJvcC1taXNzaW5nXSBmb3VuZCB3aGVuIHVwZ3JhZGluZyBGbG93XG5cblxuICAgICAgICAgICAgZm4uY2FsbChGYWtlLnByb3RvdHlwZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICB0aHJvdyBFcnJvcigpO1xuICAgICAgICAgIH0gY2F0Y2ggKHgpIHtcbiAgICAgICAgICAgIGNvbnRyb2wgPSB4O1xuICAgICAgICAgIH0gLy8gVE9ETyhsdW5hKTogVGhpcyB3aWxsIGN1cnJlbnRseSBvbmx5IHRocm93IGlmIHRoZSBmdW5jdGlvbiBjb21wb25lbnRcbiAgICAgICAgICAvLyB0cmllcyB0byBhY2Nlc3MgUmVhY3QvUmVhY3RET00vcHJvcHMuIFdlIHNob3VsZCBwcm9iYWJseSBtYWtlIHRoaXMgdGhyb3dcbiAgICAgICAgICAvLyBpbiBzaW1wbGUgY29tcG9uZW50cyB0b29cblxuXG4gICAgICAgICAgdmFyIG1heWJlUHJvbWlzZSA9IGZuKCk7IC8vIElmIHRoZSBmdW5jdGlvbiBjb21wb25lbnQgcmV0dXJucyBhIHByb21pc2UsIGl0J3MgbGlrZWx5IGFuIGFzeW5jXG4gICAgICAgICAgLy8gY29tcG9uZW50LCB3aGljaCB3ZSBkb24ndCB5ZXQgc3VwcG9ydC4gQXR0YWNoIGEgbm9vcCBjYXRjaCBoYW5kbGVyIHRvXG4gICAgICAgICAgLy8gc2lsZW5jZSB0aGUgZXJyb3IuXG4gICAgICAgICAgLy8gVE9ETzogSW1wbGVtZW50IGNvbXBvbmVudCBzdGFja3MgZm9yIGFzeW5jIGNsaWVudCBjb21wb25lbnRzP1xuXG4gICAgICAgICAgaWYgKG1heWJlUHJvbWlzZSAmJiB0eXBlb2YgbWF5YmVQcm9taXNlLmNhdGNoID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgICAgICBtYXliZVByb21pc2UuY2F0Y2goZnVuY3Rpb24gKCkge30pO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfSBjYXRjaCAoc2FtcGxlKSB7XG4gICAgICAgIC8vIFRoaXMgaXMgaW5saW5lZCBtYW51YWxseSBiZWNhdXNlIGNsb3N1cmUgZG9lc24ndCBkbyBpdCBmb3IgdXMuXG4gICAgICAgIGlmIChzYW1wbGUgJiYgY29udHJvbCAmJiB0eXBlb2Ygc2FtcGxlLnN0YWNrID09PSAnc3RyaW5nJykge1xuICAgICAgICAgIHJldHVybiBbc2FtcGxlLnN0YWNrLCBjb250cm9sLnN0YWNrXTtcbiAgICAgICAgfVxuICAgICAgfVxuXG4gICAgICByZXR1cm4gW251bGwsIG51bGxdO1xuICAgIH1cbiAgfTsgLy8gJEZsb3dGaXhNZVtwcm9wLW1pc3NpbmddXG5cbiAgUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290LmRpc3BsYXlOYW1lID0gJ0RldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCc7XG4gIHZhciBuYW1lUHJvcERlc2NyaXB0b3IgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKFJ1bkluUm9vdEZyYW1lLkRldGVybWluZUNvbXBvbmVudEZyYW1lUm9vdCwgJ25hbWUnKTsgLy8gQmVmb3JlIEVTNiwgdGhlIGBuYW1lYCBwcm9wZXJ0eSB3YXMgbm90IGNvbmZpZ3VyYWJsZS5cblxuICBpZiAobmFtZVByb3BEZXNjcmlwdG9yICYmIG5hbWVQcm9wRGVzY3JpcHRvci5jb25maWd1cmFibGUpIHtcbiAgICAvLyBWOCB1dGlsaXplcyBhIGZ1bmN0aW9uJ3MgYG5hbWVgIHByb3BlcnR5IHdoZW4gZ2VuZXJhdGluZyBhIHN0YWNrIHRyYWNlLlxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShSdW5JblJvb3RGcmFtZS5EZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QsIC8vIENvbmZpZ3VyYWJsZSBwcm9wZXJ0aWVzIGNhbiBiZSB1cGRhdGVkIGV2ZW4gaWYgaXRzIHdyaXRhYmxlIGRlc2NyaXB0b3JcbiAgICAvLyBpcyBzZXQgdG8gYGZhbHNlYC5cbiAgICAvLyAkRmxvd0ZpeE1lW2Nhbm5vdC13cml0ZV1cbiAgICAnbmFtZScsIHtcbiAgICAgIHZhbHVlOiAnRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290J1xuICAgIH0pO1xuICB9XG5cbiAgdHJ5IHtcbiAgICB2YXIgX1J1bkluUm9vdEZyYW1lJERldGVyID0gUnVuSW5Sb290RnJhbWUuRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290KCksXG4gICAgICAgIHNhbXBsZVN0YWNrID0gX1J1bkluUm9vdEZyYW1lJERldGVyWzBdLFxuICAgICAgICBjb250cm9sU3RhY2sgPSBfUnVuSW5Sb290RnJhbWUkRGV0ZXJbMV07XG5cbiAgICBpZiAoc2FtcGxlU3RhY2sgJiYgY29udHJvbFN0YWNrKSB7XG4gICAgICAvLyBUaGlzIGV4dHJhY3RzIHRoZSBmaXJzdCBmcmFtZSBmcm9tIHRoZSBzYW1wbGUgdGhhdCBpc24ndCBhbHNvIGluIHRoZSBjb250cm9sLlxuICAgICAgLy8gU2tpcHBpbmcgb25lIGZyYW1lIHRoYXQgd2UgYXNzdW1lIGlzIHRoZSBmcmFtZSB0aGF0IGNhbGxzIHRoZSB0d28uXG4gICAgICB2YXIgc2FtcGxlTGluZXMgPSBzYW1wbGVTdGFjay5zcGxpdCgnXFxuJyk7XG4gICAgICB2YXIgY29udHJvbExpbmVzID0gY29udHJvbFN0YWNrLnNwbGl0KCdcXG4nKTtcbiAgICAgIHZhciBzID0gMDtcbiAgICAgIHZhciBjID0gMDtcblxuICAgICAgd2hpbGUgKHMgPCBzYW1wbGVMaW5lcy5sZW5ndGggJiYgIXNhbXBsZUxpbmVzW3NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBzKys7XG4gICAgICB9XG5cbiAgICAgIHdoaWxlIChjIDwgY29udHJvbExpbmVzLmxlbmd0aCAmJiAhY29udHJvbExpbmVzW2NdLmluY2x1ZGVzKCdEZXRlcm1pbmVDb21wb25lbnRGcmFtZVJvb3QnKSkge1xuICAgICAgICBjKys7XG4gICAgICB9IC8vIFdlIGNvdWxkbid0IGZpbmQgb3VyIGludGVudGlvbmFsbHkgaW5qZWN0ZWQgY29tbW9uIHJvb3QgZnJhbWUsIGF0dGVtcHRcbiAgICAgIC8vIHRvIGZpbmQgYW5vdGhlciBjb21tb24gcm9vdCBmcmFtZSBieSBzZWFyY2ggZnJvbSB0aGUgYm90dG9tIG9mIHRoZVxuICAgICAgLy8gY29udHJvbCBzdGFjay4uLlxuXG5cbiAgICAgIGlmIChzID09PSBzYW1wbGVMaW5lcy5sZW5ndGggfHwgYyA9PT0gY29udHJvbExpbmVzLmxlbmd0aCkge1xuICAgICAgICBzID0gc2FtcGxlTGluZXMubGVuZ3RoIC0gMTtcbiAgICAgICAgYyA9IGNvbnRyb2xMaW5lcy5sZW5ndGggLSAxO1xuXG4gICAgICAgIHdoaWxlIChzID49IDEgJiYgYyA+PSAwICYmIHNhbXBsZUxpbmVzW3NdICE9PSBjb250cm9sTGluZXNbY10pIHtcbiAgICAgICAgICAvLyBXZSBleHBlY3QgYXQgbGVhc3Qgb25lIHN0YWNrIGZyYW1lIHRvIGJlIHNoYXJlZC5cbiAgICAgICAgICAvLyBUeXBpY2FsbHkgdGhpcyB3aWxsIGJlIHRoZSByb290IG1vc3Qgb25lLiBIb3dldmVyLCBzdGFjayBmcmFtZXMgbWF5IGJlXG4gICAgICAgICAgLy8gY3V0IG9mZiBkdWUgdG8gbWF4aW11bSBzdGFjayBsaW1pdHMuIEluIHRoaXMgY2FzZSwgb25lIG1heWJlIGN1dCBvZmZcbiAgICAgICAgICAvLyBlYXJsaWVyIHRoYW4gdGhlIG90aGVyLiBXZSBhc3N1bWUgdGhhdCB0aGUgc2FtcGxlIGlzIGxvbmdlciBvciB0aGUgc2FtZVxuICAgICAgICAgIC8vIGFuZCB0aGVyZSBmb3IgY3V0IG9mZiBlYXJsaWVyLiBTbyB3ZSBzaG91bGQgZmluZCB0aGUgcm9vdCBtb3N0IGZyYW1lIGluXG4gICAgICAgICAgLy8gdGhlIHNhbXBsZSBzb21ld2hlcmUgaW4gdGhlIGNvbnRyb2wuXG4gICAgICAgICAgYy0tO1xuICAgICAgICB9XG4gICAgICB9XG5cbiAgICAgIGZvciAoOyBzID49IDEgJiYgYyA+PSAwOyBzLS0sIGMtLSkge1xuICAgICAgICAvLyBOZXh0IHdlIGZpbmQgdGhlIGZpcnN0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHdoaWNoIHNob3VsZCBiZSB0aGVcbiAgICAgICAgLy8gZnJhbWUgdGhhdCBjYWxsZWQgb3VyIHNhbXBsZSBmdW5jdGlvbiBhbmQgdGhlIGNvbnRyb2wuXG4gICAgICAgIGlmIChzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgLy8gSW4gVjgsIHRoZSBmaXJzdCBsaW5lIGlzIGRlc2NyaWJpbmcgdGhlIG1lc3NhZ2UgYnV0IG90aGVyIFZNcyBkb24ndC5cbiAgICAgICAgICAvLyBJZiB3ZSdyZSBhYm91dCB0byByZXR1cm4gdGhlIGZpcnN0IGxpbmUsIGFuZCB0aGUgY29udHJvbCBpcyBhbHNvIG9uIHRoZSBzYW1lXG4gICAgICAgICAgLy8gbGluZSwgdGhhdCdzIGEgcHJldHR5IGdvb2QgaW5kaWNhdG9yIHRoYXQgb3VyIHNhbXBsZSB0aHJldyBhdCBzYW1lIGxpbmUgYXNcbiAgICAgICAgICAvLyB0aGUgY29udHJvbC4gSS5lLiBiZWZvcmUgd2UgZW50ZXJlZCB0aGUgc2FtcGxlIGZyYW1lLiBTbyB3ZSBpZ25vcmUgdGhpcyByZXN1bHQuXG4gICAgICAgICAgLy8gVGhpcyBjYW4gaGFwcGVuIGlmIHlvdSBwYXNzZWQgYSBjbGFzcyB0byBmdW5jdGlvbiBjb21wb25lbnQsIG9yIG5vbi1mdW5jdGlvbi5cbiAgICAgICAgICBpZiAocyAhPT0gMSB8fCBjICE9PSAxKSB7XG4gICAgICAgICAgICBkbyB7XG4gICAgICAgICAgICAgIHMtLTtcbiAgICAgICAgICAgICAgYy0tOyAvLyBXZSBtYXkgc3RpbGwgaGF2ZSBzaW1pbGFyIGludGVybWVkaWF0ZSBmcmFtZXMgZnJvbSB0aGUgY29uc3RydWN0IGNhbGwuXG4gICAgICAgICAgICAgIC8vIFRoZSBuZXh0IG9uZSB0aGF0IGlzbid0IHRoZSBzYW1lIHNob3VsZCBiZSBvdXIgbWF0Y2ggdGhvdWdoLlxuXG4gICAgICAgICAgICAgIGlmIChjIDwgMCB8fCBzYW1wbGVMaW5lc1tzXSAhPT0gY29udHJvbExpbmVzW2NdKSB7XG4gICAgICAgICAgICAgICAgLy8gVjggYWRkcyBhIFwibmV3XCIgcHJlZml4IGZvciBuYXRpdmUgY2xhc3Nlcy4gTGV0J3MgcmVtb3ZlIGl0IHRvIG1ha2UgaXQgcHJldHRpZXIuXG4gICAgICAgICAgICAgICAgdmFyIF9mcmFtZSA9ICdcXG4nICsgc2FtcGxlTGluZXNbc10ucmVwbGFjZSgnIGF0IG5ldyAnLCAnIGF0ICcpOyAvLyBJZiBvdXIgY29tcG9uZW50IGZyYW1lIGlzIGxhYmVsZWQgXCI8YW5vbnltb3VzPlwiXG4gICAgICAgICAgICAgICAgLy8gYnV0IHdlIGhhdmUgYSB1c2VyLXByb3ZpZGVkIFwiZGlzcGxheU5hbWVcIlxuICAgICAgICAgICAgICAgIC8vIHNwbGljZSBpdCBpbiB0byBtYWtlIHRoZSBzdGFjayBtb3JlIHJlYWRhYmxlLlxuXG5cbiAgICAgICAgICAgICAgICBpZiAoZm4uZGlzcGxheU5hbWUgJiYgX2ZyYW1lLmluY2x1ZGVzKCc8YW5vbnltb3VzPicpKSB7XG4gICAgICAgICAgICAgICAgICBfZnJhbWUgPSBfZnJhbWUucmVwbGFjZSgnPGFub255bW91cz4nLCBmbi5kaXNwbGF5TmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICAgICAgaWYgKHRydWUpIHtcbiAgICAgICAgICAgICAgICAgIGlmICh0eXBlb2YgZm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgICAgICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIF9mcmFtZSk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfSAvLyBSZXR1cm4gdGhlIGxpbmUgd2UgZm91bmQuXG5cblxuICAgICAgICAgICAgICAgIHJldHVybiBfZnJhbWU7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gd2hpbGUgKHMgPj0gMSAmJiBjID49IDApO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGJyZWFrO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9IGZpbmFsbHkge1xuICAgIHJlZW50cnkgPSBmYWxzZTtcblxuICAgIHtcbiAgICAgIFJlYWN0Q3VycmVudERpc3BhdGNoZXIuY3VycmVudCA9IHByZXZpb3VzRGlzcGF0Y2hlcjtcbiAgICAgIHJlZW5hYmxlTG9ncygpO1xuICAgIH1cblxuICAgIEVycm9yLnByZXBhcmVTdGFja1RyYWNlID0gcHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZTtcbiAgfSAvLyBGYWxsYmFjayB0byBqdXN0IHVzaW5nIHRoZSBuYW1lIGlmIHdlIGNvdWxkbid0IG1ha2UgaXQgdGhyb3cuXG5cblxuICB2YXIgbmFtZSA9IGZuID8gZm4uZGlzcGxheU5hbWUgfHwgZm4ubmFtZSA6ICcnO1xuICB2YXIgc3ludGhldGljRnJhbWUgPSBuYW1lID8gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUobmFtZSkgOiAnJztcblxuICB7XG4gICAgaWYgKHR5cGVvZiBmbiA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgY29tcG9uZW50RnJhbWVDYWNoZS5zZXQoZm4sIHN5bnRoZXRpY0ZyYW1lKTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gc3ludGhldGljRnJhbWU7XG59XG5mdW5jdGlvbiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUoZm4sIHNvdXJjZSwgb3duZXJGbikge1xuICB7XG4gICAgcmV0dXJuIGRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUoZm4sIGZhbHNlKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaG91bGRDb25zdHJ1Y3QoQ29tcG9uZW50KSB7XG4gIHZhciBwcm90b3R5cGUgPSBDb21wb25lbnQucHJvdG90eXBlO1xuICByZXR1cm4gISEocHJvdG90eXBlICYmIHByb3RvdHlwZS5pc1JlYWN0Q29tcG9uZW50KTtcbn1cblxuZnVuY3Rpb24gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKHR5cGUsIHNvdXJjZSwgb3duZXJGbikge1xuXG4gIGlmICh0eXBlID09IG51bGwpIHtcbiAgICByZXR1cm4gJyc7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdmdW5jdGlvbicpIHtcbiAgICB7XG4gICAgICByZXR1cm4gZGVzY3JpYmVOYXRpdmVDb21wb25lbnRGcmFtZSh0eXBlLCBzaG91bGRDb25zdHJ1Y3QodHlwZSkpO1xuICAgIH1cbiAgfVxuXG4gIGlmICh0eXBlb2YgdHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUodHlwZSk7XG4gIH1cblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX1RZUEU6XG4gICAgICByZXR1cm4gZGVzY3JpYmVCdWlsdEluQ29tcG9uZW50RnJhbWUoJ1N1c3BlbnNlJyk7XG5cbiAgICBjYXNlIFJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRTpcbiAgICAgIHJldHVybiBkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSgnU3VzcGVuc2VMaXN0Jyk7XG4gIH1cblxuICBpZiAodHlwZW9mIHR5cGUgPT09ICdvYmplY3QnKSB7XG4gICAgc3dpdGNoICh0eXBlLiQkdHlwZW9mKSB7XG4gICAgICBjYXNlIFJFQUNUX0ZPUldBUkRfUkVGX1RZUEU6XG4gICAgICAgIHJldHVybiBkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUodHlwZS5yZW5kZXIpO1xuXG4gICAgICBjYXNlIFJFQUNUX01FTU9fVFlQRTpcbiAgICAgICAgLy8gTWVtbyBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgcmV0dXJuIGRlc2NyaWJlVW5rbm93bkVsZW1lbnRUeXBlRnJhbWVJbkRFVih0eXBlLnR5cGUsIHNvdXJjZSwgb3duZXJGbik7XG5cbiAgICAgIGNhc2UgUkVBQ1RfTEFaWV9UWVBFOlxuICAgICAgICB7XG4gICAgICAgICAgdmFyIGxhenlDb21wb25lbnQgPSB0eXBlO1xuICAgICAgICAgIHZhciBwYXlsb2FkID0gbGF6eUNvbXBvbmVudC5fcGF5bG9hZDtcbiAgICAgICAgICB2YXIgaW5pdCA9IGxhenlDb21wb25lbnQuX2luaXQ7XG5cbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgLy8gTGF6eSBtYXkgY29udGFpbiBhbnkgY29tcG9uZW50IHR5cGUgc28gd2UgcmVjdXJzaXZlbHkgcmVzb2x2ZSBpdC5cbiAgICAgICAgICAgIHJldHVybiBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoaW5pdChwYXlsb2FkKSwgc291cmNlLCBvd25lckZuKTtcbiAgICAgICAgICB9IGNhdGNoICh4KSB7fVxuICAgICAgICB9XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuICcnO1xufVxuXG4vLyAkRmxvd0ZpeE1lW21ldGhvZC11bmJpbmRpbmddXG52YXIgaGFzT3duUHJvcGVydHkgPSBPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5O1xuXG52YXIgbG9nZ2VkVHlwZUZhaWx1cmVzID0ge307XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShlbGVtZW50KSB7XG4gIHtcbiAgICBpZiAoZWxlbWVudCkge1xuICAgICAgdmFyIG93bmVyID0gZWxlbWVudC5fb3duZXI7XG4gICAgICB2YXIgc3RhY2sgPSBkZXNjcmliZVVua25vd25FbGVtZW50VHlwZUZyYW1lSW5ERVYoZWxlbWVudC50eXBlLCBlbGVtZW50Ll9zb3VyY2UsIG93bmVyID8gb3duZXIudHlwZSA6IG51bGwpO1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSQxLnNldEV4dHJhU3RhY2tGcmFtZShzdGFjayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUkMS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGNoZWNrUHJvcFR5cGVzKHR5cGVTcGVjcywgdmFsdWVzLCBsb2NhdGlvbiwgY29tcG9uZW50TmFtZSwgZWxlbWVudCkge1xuICB7XG4gICAgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtdXNlXSBUaGlzIGlzIG9rYXkgYnV0IEZsb3cgZG9lc24ndCBrbm93IGl0LlxuICAgIHZhciBoYXMgPSBGdW5jdGlvbi5jYWxsLmJpbmQoaGFzT3duUHJvcGVydHkpO1xuXG4gICAgZm9yICh2YXIgdHlwZVNwZWNOYW1lIGluIHR5cGVTcGVjcykge1xuICAgICAgaWYgKGhhcyh0eXBlU3BlY3MsIHR5cGVTcGVjTmFtZSkpIHtcbiAgICAgICAgdmFyIGVycm9yJDEgPSB2b2lkIDA7IC8vIFByb3AgdHlwZSB2YWxpZGF0aW9uIG1heSB0aHJvdy4gSW4gY2FzZSB0aGV5IGRvLCB3ZSBkb24ndCB3YW50IHRvXG4gICAgICAgIC8vIGZhaWwgdGhlIHJlbmRlciBwaGFzZSB3aGVyZSBpdCBkaWRuJ3QgZmFpbCBiZWZvcmUuIFNvIHdlIGxvZyBpdC5cbiAgICAgICAgLy8gQWZ0ZXIgdGhlc2UgaGF2ZSBiZWVuIGNsZWFuZWQgdXAsIHdlJ2xsIGxldCB0aGVtIHRocm93LlxuXG4gICAgICAgIHRyeSB7XG4gICAgICAgICAgLy8gVGhpcyBpcyBpbnRlbnRpb25hbGx5IGFuIGludmFyaWFudCB0aGF0IGdldHMgY2F1Z2h0LiBJdCdzIHRoZSBzYW1lXG4gICAgICAgICAgLy8gYmVoYXZpb3IgYXMgd2l0aG91dCB0aGlzIHN0YXRlbWVudCBleGNlcHQgd2l0aCBhIGJldHRlciBtZXNzYWdlLlxuICAgICAgICAgIGlmICh0eXBlb2YgdHlwZVNwZWNzW3R5cGVTcGVjTmFtZV0gIT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgICAgIC8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZSByZWFjdC1pbnRlcm5hbC9wcm9kLWVycm9yLWNvZGVzXG4gICAgICAgICAgICB2YXIgZXJyID0gRXJyb3IoKGNvbXBvbmVudE5hbWUgfHwgJ1JlYWN0IGNsYXNzJykgKyAnOiAnICsgbG9jYXRpb24gKyAnIHR5cGUgYCcgKyB0eXBlU3BlY05hbWUgKyAnYCBpcyBpbnZhbGlkOyAnICsgJ2l0IG11c3QgYmUgYSBmdW5jdGlvbiwgdXN1YWxseSBmcm9tIHRoZSBgcHJvcC10eXBlc2AgcGFja2FnZSwgYnV0IHJlY2VpdmVkIGAnICsgdHlwZW9mIHR5cGVTcGVjc1t0eXBlU3BlY05hbWVdICsgJ2AuJyArICdUaGlzIG9mdGVuIGhhcHBlbnMgYmVjYXVzZSBvZiB0eXBvcyBzdWNoIGFzIGBQcm9wVHlwZXMuZnVuY3Rpb25gIGluc3RlYWQgb2YgYFByb3BUeXBlcy5mdW5jYC4nKTtcbiAgICAgICAgICAgIGVyci5uYW1lID0gJ0ludmFyaWFudCBWaW9sYXRpb24nO1xuICAgICAgICAgICAgdGhyb3cgZXJyO1xuICAgICAgICAgIH1cblxuICAgICAgICAgIGVycm9yJDEgPSB0eXBlU3BlY3NbdHlwZVNwZWNOYW1lXSh2YWx1ZXMsIHR5cGVTcGVjTmFtZSwgY29tcG9uZW50TmFtZSwgbG9jYXRpb24sIG51bGwsICdTRUNSRVRfRE9fTk9UX1BBU1NfVEhJU19PUl9ZT1VfV0lMTF9CRV9GSVJFRCcpO1xuICAgICAgICB9IGNhdGNoIChleCkge1xuICAgICAgICAgIGVycm9yJDEgPSBleDtcbiAgICAgICAgfVxuXG4gICAgICAgIGlmIChlcnJvciQxICYmICEoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yKSkge1xuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEoZWxlbWVudCk7XG5cbiAgICAgICAgICBlcnJvcignJXM6IHR5cGUgc3BlY2lmaWNhdGlvbiBvZiAlcycgKyAnIGAlc2AgaXMgaW52YWxpZDsgdGhlIHR5cGUgY2hlY2tlciAnICsgJ2Z1bmN0aW9uIG11c3QgcmV0dXJuIGBudWxsYCBvciBhbiBgRXJyb3JgIGJ1dCByZXR1cm5lZCBhICVzLiAnICsgJ1lvdSBtYXkgaGF2ZSBmb3Jnb3R0ZW4gdG8gcGFzcyBhbiBhcmd1bWVudCB0byB0aGUgdHlwZSBjaGVja2VyICcgKyAnY3JlYXRvciAoYXJyYXlPZiwgaW5zdGFuY2VPZiwgb2JqZWN0T2YsIG9uZU9mLCBvbmVPZlR5cGUsIGFuZCAnICsgJ3NoYXBlIGFsbCByZXF1aXJlIGFuIGFyZ3VtZW50KS4nLCBjb21wb25lbnROYW1lIHx8ICdSZWFjdCBjbGFzcycsIGxvY2F0aW9uLCB0eXBlU3BlY05hbWUsIHR5cGVvZiBlcnJvciQxKTtcblxuICAgICAgICAgIHNldEN1cnJlbnRseVZhbGlkYXRpbmdFbGVtZW50JDEobnVsbCk7XG4gICAgICAgIH1cblxuICAgICAgICBpZiAoZXJyb3IkMSBpbnN0YW5jZW9mIEVycm9yICYmICEoZXJyb3IkMS5tZXNzYWdlIGluIGxvZ2dlZFR5cGVGYWlsdXJlcykpIHtcbiAgICAgICAgICAvLyBPbmx5IG1vbml0b3IgdGhpcyBmYWlsdXJlIG9uY2UgYmVjYXVzZSB0aGVyZSB0ZW5kcyB0byBiZSBhIGxvdCBvZiB0aGVcbiAgICAgICAgICAvLyBzYW1lIGVycm9yLlxuICAgICAgICAgIGxvZ2dlZFR5cGVGYWlsdXJlc1tlcnJvciQxLm1lc3NhZ2VdID0gdHJ1ZTtcbiAgICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxKGVsZW1lbnQpO1xuXG4gICAgICAgICAgZXJyb3IoJ0ZhaWxlZCAlcyB0eXBlOiAlcycsIGxvY2F0aW9uLCBlcnJvciQxLm1lc3NhZ2UpO1xuXG4gICAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQkMShudWxsKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG52YXIgaXNBcnJheUltcGwgPSBBcnJheS5pc0FycmF5OyAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgbm8tcmVkZWNsYXJlXG5cbmZ1bmN0aW9uIGlzQXJyYXkoYSkge1xuICByZXR1cm4gaXNBcnJheUltcGwoYSk7XG59XG5cbi8qXG4gKiBUaGUgYCcnICsgdmFsdWVgIHBhdHRlcm4gKHVzZWQgaW4gcGVyZi1zZW5zaXRpdmUgY29kZSkgdGhyb3dzIGZvciBTeW1ib2xcbiAqIGFuZCBUZW1wb3JhbC4qIHR5cGVzLiBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L3B1bGwvMjIwNjQuXG4gKlxuICogVGhlIGZ1bmN0aW9ucyBpbiB0aGlzIG1vZHVsZSB3aWxsIHRocm93IGFuIGVhc2llci10by11bmRlcnN0YW5kLFxuICogZWFzaWVyLXRvLWRlYnVnIGV4Y2VwdGlvbiB3aXRoIGEgY2xlYXIgZXJyb3JzIG1lc3NhZ2UgbWVzc2FnZSBleHBsYWluaW5nIHRoZVxuICogcHJvYmxlbS4gKEluc3RlYWQgb2YgYSBjb25mdXNpbmcgZXhjZXB0aW9uIHRocm93biBpbnNpZGUgdGhlIGltcGxlbWVudGF0aW9uXG4gKiBvZiB0aGUgYHZhbHVlYCBvYmplY3QpLlxuICovXG4vLyAkRmxvd0ZpeE1lW2luY29tcGF0aWJsZS1yZXR1cm5dIG9ubHkgY2FsbGVkIGluIERFViwgc28gdm9pZCByZXR1cm4gaXMgbm90IHBvc3NpYmxlLlxuZnVuY3Rpb24gdHlwZU5hbWUodmFsdWUpIHtcbiAge1xuICAgIC8vIHRvU3RyaW5nVGFnIGlzIG5lZWRlZCBmb3IgbmFtZXNwYWNlZCB0eXBlcyBsaWtlIFRlbXBvcmFsLkluc3RhbnRcbiAgICB2YXIgaGFzVG9TdHJpbmdUYWcgPSB0eXBlb2YgU3ltYm9sID09PSAnZnVuY3Rpb24nICYmIFN5bWJvbC50b1N0cmluZ1RhZztcbiAgICB2YXIgdHlwZSA9IGhhc1RvU3RyaW5nVGFnICYmIHZhbHVlW1N5bWJvbC50b1N0cmluZ1RhZ10gfHwgdmFsdWUuY29uc3RydWN0b3IubmFtZSB8fCAnT2JqZWN0JzsgLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXVxuXG4gICAgcmV0dXJuIHR5cGU7XG4gIH1cbn0gLy8gJEZsb3dGaXhNZVtpbmNvbXBhdGlibGUtcmV0dXJuXSBvbmx5IGNhbGxlZCBpbiBERVYsIHNvIHZvaWQgcmV0dXJuIGlzIG5vdCBwb3NzaWJsZS5cblxuXG5mdW5jdGlvbiB3aWxsQ29lcmNpb25UaHJvdyh2YWx1ZSkge1xuICB7XG4gICAgdHJ5IHtcbiAgICAgIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSk7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfSBjYXRjaCAoZSkge1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIHRlc3RTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICAvLyBJZiB5b3UgZW5kZWQgdXAgaGVyZSBieSBmb2xsb3dpbmcgYW4gZXhjZXB0aW9uIGNhbGwgc3RhY2ssIGhlcmUncyB3aGF0J3NcbiAgLy8gaGFwcGVuZWQ6IHlvdSBzdXBwbGllZCBhbiBvYmplY3Qgb3Igc3ltYm9sIHZhbHVlIHRvIFJlYWN0IChhcyBhIHByb3AsIGtleSxcbiAgLy8gRE9NIGF0dHJpYnV0ZSwgQ1NTIHByb3BlcnR5LCBzdHJpbmcgcmVmLCBldGMuKSBhbmQgd2hlbiBSZWFjdCB0cmllZCB0b1xuICAvLyBjb2VyY2UgaXQgdG8gYSBzdHJpbmcgdXNpbmcgYCcnICsgdmFsdWVgLCBhbiBleGNlcHRpb24gd2FzIHRocm93bi5cbiAgLy9cbiAgLy8gVGhlIG1vc3QgY29tbW9uIHR5cGVzIHRoYXQgd2lsbCBjYXVzZSB0aGlzIGV4Y2VwdGlvbiBhcmUgYFN5bWJvbGAgaW5zdGFuY2VzXG4gIC8vIGFuZCBUZW1wb3JhbCBvYmplY3RzIGxpa2UgYFRlbXBvcmFsLkluc3RhbnRgLiBCdXQgYW55IG9iamVjdCB0aGF0IGhhcyBhXG4gIC8vIGB2YWx1ZU9mYCBvciBgW1N5bWJvbC50b1ByaW1pdGl2ZV1gIG1ldGhvZCB0aGF0IHRocm93cyB3aWxsIGFsc28gY2F1c2UgdGhpc1xuICAvLyBleGNlcHRpb24uIChMaWJyYXJ5IGF1dGhvcnMgZG8gdGhpcyB0byBwcmV2ZW50IHVzZXJzIGZyb20gdXNpbmcgYnVpbHQtaW5cbiAgLy8gbnVtZXJpYyBvcGVyYXRvcnMgbGlrZSBgK2Agb3IgY29tcGFyaXNvbiBvcGVyYXRvcnMgbGlrZSBgPj1gIGJlY2F1c2UgY3VzdG9tXG4gIC8vIG1ldGhvZHMgYXJlIG5lZWRlZCB0byBwZXJmb3JtIGFjY3VyYXRlIGFyaXRobWV0aWMgb3IgY29tcGFyaXNvbi4pXG4gIC8vXG4gIC8vIFRvIGZpeCB0aGUgcHJvYmxlbSwgY29lcmNlIHRoaXMgb2JqZWN0IG9yIHN5bWJvbCB2YWx1ZSB0byBhIHN0cmluZyBiZWZvcmVcbiAgLy8gcGFzc2luZyBpdCB0byBSZWFjdC4gVGhlIG1vc3QgcmVsaWFibGUgd2F5IGlzIHVzdWFsbHkgYFN0cmluZyh2YWx1ZSlgLlxuICAvL1xuICAvLyBUbyBmaW5kIHdoaWNoIHZhbHVlIGlzIHRocm93aW5nLCBjaGVjayB0aGUgYnJvd3NlciBvciBkZWJ1Z2dlciBjb25zb2xlLlxuICAvLyBCZWZvcmUgdGhpcyBleGNlcHRpb24gd2FzIHRocm93biwgdGhlcmUgc2hvdWxkIGJlIGBjb25zb2xlLmVycm9yYCBvdXRwdXRcbiAgLy8gdGhhdCBzaG93cyB0aGUgdHlwZSAoU3ltYm9sLCBUZW1wb3JhbC5QbGFpbkRhdGUsIGV0Yy4pIHRoYXQgY2F1c2VkIHRoZVxuICAvLyBwcm9ibGVtIGFuZCBob3cgdGhhdCB0eXBlIHdhcyB1c2VkOiBrZXksIGF0cnJpYnV0ZSwgaW5wdXQgdmFsdWUgcHJvcCwgZXRjLlxuICAvLyBJbiBtb3N0IGNhc2VzLCB0aGlzIGNvbnNvbGUgb3V0cHV0IGFsc28gc2hvd3MgdGhlIGNvbXBvbmVudCBhbmQgaXRzXG4gIC8vIGFuY2VzdG9yIGNvbXBvbmVudHMgd2hlcmUgdGhlIGV4Y2VwdGlvbiBoYXBwZW5lZC5cbiAgLy9cbiAgLy8gZXNsaW50LWRpc2FibGUtbmV4dC1saW5lIHJlYWN0LWludGVybmFsL3NhZmUtc3RyaW5nLWNvZXJjaW9uXG4gIHJldHVybiAnJyArIHZhbHVlO1xufVxuZnVuY3Rpb24gY2hlY2tLZXlTdHJpbmdDb2VyY2lvbih2YWx1ZSkge1xuICB7XG4gICAgaWYgKHdpbGxDb2VyY2lvblRocm93KHZhbHVlKSkge1xuICAgICAgZXJyb3IoJ1RoZSBwcm92aWRlZCBrZXkgaXMgYW4gdW5zdXBwb3J0ZWQgdHlwZSAlcy4nICsgJyBUaGlzIHZhbHVlIG11c3QgYmUgY29lcmNlZCB0byBhIHN0cmluZyBiZWZvcmUgdXNpbmcgaXQgaGVyZS4nLCB0eXBlTmFtZSh2YWx1ZSkpO1xuXG4gICAgICByZXR1cm4gdGVzdFN0cmluZ0NvZXJjaW9uKHZhbHVlKTsgLy8gdGhyb3cgKHRvIGhlbHAgY2FsbGVycyBmaW5kIHRyb3VibGVzaG9vdGluZyBjb21tZW50cylcbiAgICB9XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyJDEgPSBSZWFjdFNoYXJlZEludGVybmFscy5SZWFjdEN1cnJlbnRPd25lcjtcbnZhciBSRVNFUlZFRF9QUk9QUyA9IHtcbiAga2V5OiB0cnVlLFxuICByZWY6IHRydWUsXG4gIF9fc2VsZjogdHJ1ZSxcbiAgX19zb3VyY2U6IHRydWVcbn07XG52YXIgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd247XG52YXIgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd247XG52YXIgZGlkV2FybkFib3V0U3RyaW5nUmVmcztcblxue1xuICBkaWRXYXJuQWJvdXRTdHJpbmdSZWZzID0ge307XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkUmVmKGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAncmVmJykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ3JlZicpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcucmVmICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIGhhc1ZhbGlkS2V5KGNvbmZpZykge1xuICB7XG4gICAgaWYgKGhhc093blByb3BlcnR5LmNhbGwoY29uZmlnLCAna2V5JykpIHtcbiAgICAgIHZhciBnZXR0ZXIgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yKGNvbmZpZywgJ2tleScpLmdldDtcblxuICAgICAgaWYgKGdldHRlciAmJiBnZXR0ZXIuaXNSZWFjdFdhcm5pbmcpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIHJldHVybiBjb25maWcua2V5ICE9PSB1bmRlZmluZWQ7XG59XG5cbmZ1bmN0aW9uIHdhcm5JZlN0cmluZ1JlZkNhbm5vdEJlQXV0b0NvbnZlcnRlZChjb25maWcsIHNlbGYpIHtcbiAge1xuICAgIGlmICh0eXBlb2YgY29uZmlnLnJlZiA9PT0gJ3N0cmluZycgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50ICYmIHNlbGYgJiYgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnN0YXRlTm9kZSAhPT0gc2VsZikge1xuICAgICAgdmFyIGNvbXBvbmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LnR5cGUpO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dFN0cmluZ1JlZnNbY29tcG9uZW50TmFtZV0pIHtcbiAgICAgICAgZXJyb3IoJ0NvbXBvbmVudCBcIiVzXCIgY29udGFpbnMgdGhlIHN0cmluZyByZWYgXCIlc1wiLiAnICsgJ1N1cHBvcnQgZm9yIHN0cmluZyByZWZzIHdpbGwgYmUgcmVtb3ZlZCBpbiBhIGZ1dHVyZSBtYWpvciByZWxlYXNlLiAnICsgJ1RoaXMgY2FzZSBjYW5ub3QgYmUgYXV0b21hdGljYWxseSBjb252ZXJ0ZWQgdG8gYW4gYXJyb3cgZnVuY3Rpb24uICcgKyAnV2UgYXNrIHlvdSB0byBtYW51YWxseSBmaXggdGhpcyBjYXNlIGJ5IHVzaW5nIHVzZVJlZigpIG9yIGNyZWF0ZVJlZigpIGluc3RlYWQuICcgKyAnTGVhcm4gbW9yZSBhYm91dCB1c2luZyByZWZzIHNhZmVseSBoZXJlOiAnICsgJ2h0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zdHJpY3QtbW9kZS1zdHJpbmctcmVmJywgZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKFJlYWN0Q3VycmVudE93bmVyJDEuY3VycmVudC50eXBlKSwgY29uZmlnLnJlZik7XG5cbiAgICAgICAgZGlkV2FybkFib3V0U3RyaW5nUmVmc1tjb21wb25lbnROYW1lXSA9IHRydWU7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ0tleSA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BLZXlXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYGtleWAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nS2V5LmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdrZXknLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ0tleSxcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG5cbmZ1bmN0aW9uIGRlZmluZVJlZlByb3BXYXJuaW5nR2V0dGVyKHByb3BzLCBkaXNwbGF5TmFtZSkge1xuICB7XG4gICAgdmFyIHdhcm5BYm91dEFjY2Vzc2luZ1JlZiA9IGZ1bmN0aW9uICgpIHtcbiAgICAgIGlmICghc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24pIHtcbiAgICAgICAgc3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24gPSB0cnVlO1xuXG4gICAgICAgIGVycm9yKCclczogYHJlZmAgaXMgbm90IGEgcHJvcC4gVHJ5aW5nIHRvIGFjY2VzcyBpdCB3aWxsIHJlc3VsdCAnICsgJ2luIGB1bmRlZmluZWRgIGJlaW5nIHJldHVybmVkLiBJZiB5b3UgbmVlZCB0byBhY2Nlc3MgdGhlIHNhbWUgJyArICd2YWx1ZSB3aXRoaW4gdGhlIGNoaWxkIGNvbXBvbmVudCwgeW91IHNob3VsZCBwYXNzIGl0IGFzIGEgZGlmZmVyZW50ICcgKyAncHJvcC4gKGh0dHBzOi8vcmVhY3Rqcy5vcmcvbGluay9zcGVjaWFsLXByb3BzKScsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cbiAgICB9O1xuXG4gICAgd2FybkFib3V0QWNjZXNzaW5nUmVmLmlzUmVhY3RXYXJuaW5nID0gdHJ1ZTtcbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocHJvcHMsICdyZWYnLCB7XG4gICAgICBnZXQ6IHdhcm5BYm91dEFjY2Vzc2luZ1JlZixcbiAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZVxuICAgIH0pO1xuICB9XG59XG4vKipcbiAqIEZhY3RvcnkgbWV0aG9kIHRvIGNyZWF0ZSBhIG5ldyBSZWFjdCBlbGVtZW50LiBUaGlzIG5vIGxvbmdlciBhZGhlcmVzIHRvXG4gKiB0aGUgY2xhc3MgcGF0dGVybiwgc28gZG8gbm90IHVzZSBuZXcgdG8gY2FsbCBpdC4gQWxzbywgaW5zdGFuY2VvZiBjaGVja1xuICogd2lsbCBub3Qgd29yay4gSW5zdGVhZCB0ZXN0ICQkdHlwZW9mIGZpZWxkIGFnYWluc3QgU3ltYm9sLmZvcigncmVhY3QuZWxlbWVudCcpIHRvIGNoZWNrXG4gKiBpZiBzb21ldGhpbmcgaXMgYSBSZWFjdCBFbGVtZW50LlxuICpcbiAqIEBwYXJhbSB7Kn0gdHlwZVxuICogQHBhcmFtIHsqfSBwcm9wc1xuICogQHBhcmFtIHsqfSBrZXlcbiAqIEBwYXJhbSB7c3RyaW5nfG9iamVjdH0gcmVmXG4gKiBAcGFyYW0geyp9IG93bmVyXG4gKiBAcGFyYW0geyp9IHNlbGYgQSAqdGVtcG9yYXJ5KiBoZWxwZXIgdG8gZGV0ZWN0IHBsYWNlcyB3aGVyZSBgdGhpc2AgaXNcbiAqIGRpZmZlcmVudCBmcm9tIHRoZSBgb3duZXJgIHdoZW4gUmVhY3QuY3JlYXRlRWxlbWVudCBpcyBjYWxsZWQsIHNvIHRoYXQgd2VcbiAqIGNhbiB3YXJuLiBXZSB3YW50IHRvIGdldCByaWQgb2Ygb3duZXIgYW5kIHJlcGxhY2Ugc3RyaW5nIGByZWZgcyB3aXRoIGFycm93XG4gKiBmdW5jdGlvbnMsIGFuZCBhcyBsb25nIGFzIGB0aGlzYCBhbmQgb3duZXIgYXJlIHRoZSBzYW1lLCB0aGVyZSB3aWxsIGJlIG5vXG4gKiBjaGFuZ2UgaW4gYmVoYXZpb3IuXG4gKiBAcGFyYW0geyp9IHNvdXJjZSBBbiBhbm5vdGF0aW9uIG9iamVjdCAoYWRkZWQgYnkgYSB0cmFuc3BpbGVyIG9yIG90aGVyd2lzZSlcbiAqIGluZGljYXRpbmcgZmlsZW5hbWUsIGxpbmUgbnVtYmVyLCBhbmQvb3Igb3RoZXIgaW5mb3JtYXRpb24uXG4gKiBAaW50ZXJuYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIFJlYWN0RWxlbWVudCh0eXBlLCBrZXksIHJlZiwgc2VsZiwgc291cmNlLCBvd25lciwgcHJvcHMpIHtcbiAgdmFyIGVsZW1lbnQgPSB7XG4gICAgLy8gVGhpcyB0YWcgYWxsb3dzIHVzIHRvIHVuaXF1ZWx5IGlkZW50aWZ5IHRoaXMgYXMgYSBSZWFjdCBFbGVtZW50XG4gICAgJCR0eXBlb2Y6IFJFQUNUX0VMRU1FTlRfVFlQRSxcbiAgICAvLyBCdWlsdC1pbiBwcm9wZXJ0aWVzIHRoYXQgYmVsb25nIG9uIHRoZSBlbGVtZW50XG4gICAgdHlwZTogdHlwZSxcbiAgICBrZXk6IGtleSxcbiAgICByZWY6IHJlZixcbiAgICBwcm9wczogcHJvcHMsXG4gICAgLy8gUmVjb3JkIHRoZSBjb21wb25lbnQgcmVzcG9uc2libGUgZm9yIGNyZWF0aW5nIHRoaXMgZWxlbWVudC5cbiAgICBfb3duZXI6IG93bmVyXG4gIH07XG5cbiAge1xuICAgIC8vIFRoZSB2YWxpZGF0aW9uIGZsYWcgaXMgY3VycmVudGx5IG11dGF0aXZlLiBXZSBwdXQgaXQgb25cbiAgICAvLyBhbiBleHRlcm5hbCBiYWNraW5nIHN0b3JlIHNvIHRoYXQgd2UgY2FuIGZyZWV6ZSB0aGUgd2hvbGUgb2JqZWN0LlxuICAgIC8vIFRoaXMgY2FuIGJlIHJlcGxhY2VkIHdpdGggYSBXZWFrTWFwIG9uY2UgdGhleSBhcmUgaW1wbGVtZW50ZWQgaW5cbiAgICAvLyBjb21tb25seSB1c2VkIGRldmVsb3BtZW50IGVudmlyb25tZW50cy5cbiAgICBlbGVtZW50Ll9zdG9yZSA9IHt9OyAvLyBUbyBtYWtlIGNvbXBhcmluZyBSZWFjdEVsZW1lbnRzIGVhc2llciBmb3IgdGVzdGluZyBwdXJwb3Nlcywgd2UgbWFrZVxuICAgIC8vIHRoZSB2YWxpZGF0aW9uIGZsYWcgbm9uLWVudW1lcmFibGUgKHdoZXJlIHBvc3NpYmxlLCB3aGljaCBzaG91bGRcbiAgICAvLyBpbmNsdWRlIGV2ZXJ5IGVudmlyb25tZW50IHdlIHJ1biB0ZXN0cyBpbiksIHNvIHRoZSB0ZXN0IGZyYW1ld29ya1xuICAgIC8vIGlnbm9yZXMgaXQuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudC5fc3RvcmUsICd2YWxpZGF0ZWQnLCB7XG4gICAgICBjb25maWd1cmFibGU6IGZhbHNlLFxuICAgICAgZW51bWVyYWJsZTogZmFsc2UsXG4gICAgICB3cml0YWJsZTogdHJ1ZSxcbiAgICAgIHZhbHVlOiBmYWxzZVxuICAgIH0pOyAvLyBzZWxmIGFuZCBzb3VyY2UgYXJlIERFViBvbmx5IHByb3BlcnRpZXMuXG5cbiAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkoZWxlbWVudCwgJ19zZWxmJywge1xuICAgICAgY29uZmlndXJhYmxlOiBmYWxzZSxcbiAgICAgIGVudW1lcmFibGU6IGZhbHNlLFxuICAgICAgd3JpdGFibGU6IGZhbHNlLFxuICAgICAgdmFsdWU6IHNlbGZcbiAgICB9KTsgLy8gVHdvIGVsZW1lbnRzIGNyZWF0ZWQgaW4gdHdvIGRpZmZlcmVudCBwbGFjZXMgc2hvdWxkIGJlIGNvbnNpZGVyZWRcbiAgICAvLyBlcXVhbCBmb3IgdGVzdGluZyBwdXJwb3NlcyBhbmQgdGhlcmVmb3JlIHdlIGhpZGUgaXQgZnJvbSBlbnVtZXJhdGlvbi5cblxuICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShlbGVtZW50LCAnX3NvdXJjZScsIHtcbiAgICAgIGNvbmZpZ3VyYWJsZTogZmFsc2UsXG4gICAgICBlbnVtZXJhYmxlOiBmYWxzZSxcbiAgICAgIHdyaXRhYmxlOiBmYWxzZSxcbiAgICAgIHZhbHVlOiBzb3VyY2VcbiAgICB9KTtcblxuICAgIGlmIChPYmplY3QuZnJlZXplKSB7XG4gICAgICBPYmplY3QuZnJlZXplKGVsZW1lbnQucHJvcHMpO1xuICAgICAgT2JqZWN0LmZyZWV6ZShlbGVtZW50KTtcbiAgICB9XG4gIH1cblxuICByZXR1cm4gZWxlbWVudDtcbn1cbi8qKlxuICogaHR0cHM6Ly9naXRodWIuY29tL3JlYWN0anMvcmZjcy9wdWxsLzEwN1xuICogQHBhcmFtIHsqfSB0eXBlXG4gKiBAcGFyYW0ge29iamVjdH0gcHJvcHNcbiAqIEBwYXJhbSB7c3RyaW5nfSBrZXlcbiAqL1xuXG5mdW5jdGlvbiBqc3hERVYkMSh0eXBlLCBjb25maWcsIG1heWJlS2V5LCBzb3VyY2UsIHNlbGYpIHtcbiAge1xuICAgIHZhciBwcm9wTmFtZTsgLy8gUmVzZXJ2ZWQgbmFtZXMgYXJlIGV4dHJhY3RlZFxuXG4gICAgdmFyIHByb3BzID0ge307XG4gICAgdmFyIGtleSA9IG51bGw7XG4gICAgdmFyIHJlZiA9IG51bGw7IC8vIEN1cnJlbnRseSwga2V5IGNhbiBiZSBzcHJlYWQgaW4gYXMgYSBwcm9wLiBUaGlzIGNhdXNlcyBhIHBvdGVudGlhbFxuICAgIC8vIGlzc3VlIGlmIGtleSBpcyBhbHNvIGV4cGxpY2l0bHkgZGVjbGFyZWQgKGllLiA8ZGl2IHsuLi5wcm9wc30ga2V5PVwiSGlcIiAvPlxuICAgIC8vIG9yIDxkaXYga2V5PVwiSGlcIiB7Li4ucHJvcHN9IC8+ICkuIFdlIHdhbnQgdG8gZGVwcmVjYXRlIGtleSBzcHJlYWQsXG4gICAgLy8gYnV0IGFzIGFuIGludGVybWVkaWFyeSBzdGVwLCB3ZSB3aWxsIHVzZSBqc3hERVYgZm9yIGV2ZXJ5dGhpbmcgZXhjZXB0XG4gICAgLy8gPGRpdiB7Li4ucHJvcHN9IGtleT1cIkhpXCIgLz4sIGJlY2F1c2Ugd2UgYXJlbid0IGN1cnJlbnRseSBhYmxlIHRvIHRlbGwgaWZcbiAgICAvLyBrZXkgaXMgZXhwbGljaXRseSBkZWNsYXJlZCB0byBiZSB1bmRlZmluZWQgb3Igbm90LlxuXG4gICAgaWYgKG1heWJlS2V5ICE9PSB1bmRlZmluZWQpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihtYXliZUtleSk7XG4gICAgICB9XG5cbiAgICAgIGtleSA9ICcnICsgbWF5YmVLZXk7XG4gICAgfVxuXG4gICAgaWYgKGhhc1ZhbGlkS2V5KGNvbmZpZykpIHtcbiAgICAgIHtcbiAgICAgICAgY2hlY2tLZXlTdHJpbmdDb2VyY2lvbihjb25maWcua2V5KTtcbiAgICAgIH1cblxuICAgICAga2V5ID0gJycgKyBjb25maWcua2V5O1xuICAgIH1cblxuICAgIGlmIChoYXNWYWxpZFJlZihjb25maWcpKSB7XG4gICAgICByZWYgPSBjb25maWcucmVmO1xuICAgICAgd2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkKGNvbmZpZywgc2VsZik7XG4gICAgfSAvLyBSZW1haW5pbmcgcHJvcGVydGllcyBhcmUgYWRkZWQgdG8gYSBuZXcgcHJvcHMgb2JqZWN0XG5cblxuICAgIGZvciAocHJvcE5hbWUgaW4gY29uZmlnKSB7XG4gICAgICBpZiAoaGFzT3duUHJvcGVydHkuY2FsbChjb25maWcsIHByb3BOYW1lKSAmJiAhUkVTRVJWRURfUFJPUFMuaGFzT3duUHJvcGVydHkocHJvcE5hbWUpKSB7XG4gICAgICAgIHByb3BzW3Byb3BOYW1lXSA9IGNvbmZpZ1twcm9wTmFtZV07XG4gICAgICB9XG4gICAgfSAvLyBSZXNvbHZlIGRlZmF1bHQgcHJvcHNcblxuXG4gICAgaWYgKHR5cGUgJiYgdHlwZS5kZWZhdWx0UHJvcHMpIHtcbiAgICAgIHZhciBkZWZhdWx0UHJvcHMgPSB0eXBlLmRlZmF1bHRQcm9wcztcblxuICAgICAgZm9yIChwcm9wTmFtZSBpbiBkZWZhdWx0UHJvcHMpIHtcbiAgICAgICAgaWYgKHByb3BzW3Byb3BOYW1lXSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgcHJvcHNbcHJvcE5hbWVdID0gZGVmYXVsdFByb3BzW3Byb3BOYW1lXTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChrZXkgfHwgcmVmKSB7XG4gICAgICB2YXIgZGlzcGxheU5hbWUgPSB0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJyA/IHR5cGUuZGlzcGxheU5hbWUgfHwgdHlwZS5uYW1lIHx8ICdVbmtub3duJyA6IHR5cGU7XG5cbiAgICAgIGlmIChrZXkpIHtcbiAgICAgICAgZGVmaW5lS2V5UHJvcFdhcm5pbmdHZXR0ZXIocHJvcHMsIGRpc3BsYXlOYW1lKTtcbiAgICAgIH1cblxuICAgICAgaWYgKHJlZikge1xuICAgICAgICBkZWZpbmVSZWZQcm9wV2FybmluZ0dldHRlcihwcm9wcywgZGlzcGxheU5hbWUpO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiBSZWFjdEVsZW1lbnQodHlwZSwga2V5LCByZWYsIHNlbGYsIHNvdXJjZSwgUmVhY3RDdXJyZW50T3duZXIkMS5jdXJyZW50LCBwcm9wcyk7XG4gIH1cbn1cblxudmFyIFJlYWN0Q3VycmVudE93bmVyID0gUmVhY3RTaGFyZWRJbnRlcm5hbHMuUmVhY3RDdXJyZW50T3duZXI7XG52YXIgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZSA9IFJlYWN0U2hhcmVkSW50ZXJuYWxzLlJlYWN0RGVidWdDdXJyZW50RnJhbWU7XG52YXIgUkVBQ1RfQ0xJRU5UX1JFRkVSRU5DRSA9IFN5bWJvbC5mb3IoJ3JlYWN0LmNsaWVudC5yZWZlcmVuY2UnKTtcblxuZnVuY3Rpb24gc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZWxlbWVudCkge1xuICB7XG4gICAgaWYgKGVsZW1lbnQpIHtcbiAgICAgIHZhciBvd25lciA9IGVsZW1lbnQuX293bmVyO1xuICAgICAgdmFyIHN0YWNrID0gZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWKGVsZW1lbnQudHlwZSwgZWxlbWVudC5fc291cmNlLCBvd25lciA/IG93bmVyLnR5cGUgOiBudWxsKTtcbiAgICAgIFJlYWN0RGVidWdDdXJyZW50RnJhbWUuc2V0RXh0cmFTdGFja0ZyYW1lKHN0YWNrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgUmVhY3REZWJ1Z0N1cnJlbnRGcmFtZS5zZXRFeHRyYVN0YWNrRnJhbWUobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93bjtcblxue1xuICBwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biA9IGZhbHNlO1xufVxuLyoqXG4gKiBWZXJpZmllcyB0aGUgb2JqZWN0IGlzIGEgUmVhY3RFbGVtZW50LlxuICogU2VlIGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9yZWFjdC1hcGkuaHRtbCNpc3ZhbGlkZWxlbWVudFxuICogQHBhcmFtIHs/b2JqZWN0fSBvYmplY3RcbiAqIEByZXR1cm4ge2Jvb2xlYW59IFRydWUgaWYgYG9iamVjdGAgaXMgYSBSZWFjdEVsZW1lbnQuXG4gKiBAZmluYWxcbiAqL1xuXG5cbmZ1bmN0aW9uIGlzVmFsaWRFbGVtZW50KG9iamVjdCkge1xuICB7XG4gICAgcmV0dXJuIHR5cGVvZiBvYmplY3QgPT09ICdvYmplY3QnICYmIG9iamVjdCAhPT0gbnVsbCAmJiBvYmplY3QuJCR0eXBlb2YgPT09IFJFQUNUX0VMRU1FTlRfVFlQRTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKSB7XG4gIHtcbiAgICBpZiAoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgdmFyIG5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoUmVhY3RDdXJyZW50T3duZXIuY3VycmVudC50eXBlKTtcblxuICAgICAgaWYgKG5hbWUpIHtcbiAgICAgICAgcmV0dXJuICdcXG5cXG5DaGVjayB0aGUgcmVuZGVyIG1ldGhvZCBvZiBgJyArIG5hbWUgKyAnYC4nO1xuICAgICAgfVxuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRTb3VyY2VJbmZvRXJyb3JBZGRlbmR1bShzb3VyY2UpIHtcbiAge1xuICAgIGlmIChzb3VyY2UgIT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFyIGZpbGVOYW1lID0gc291cmNlLmZpbGVOYW1lLnJlcGxhY2UoL14uKltcXFxcXFwvXS8sICcnKTtcbiAgICAgIHZhciBsaW5lTnVtYmVyID0gc291cmNlLmxpbmVOdW1iZXI7XG4gICAgICByZXR1cm4gJ1xcblxcbkNoZWNrIHlvdXIgY29kZSBhdCAnICsgZmlsZU5hbWUgKyAnOicgKyBsaW5lTnVtYmVyICsgJy4nO1xuICAgIH1cblxuICAgIHJldHVybiAnJztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZXJlJ3Mgbm8ga2V5IGV4cGxpY2l0bHkgc2V0IG9uIGR5bmFtaWMgYXJyYXlzIG9mIGNoaWxkcmVuIG9yXG4gKiBvYmplY3Qga2V5cyBhcmUgbm90IHZhbGlkLiBUaGlzIGFsbG93cyB1cyB0byBrZWVwIHRyYWNrIG9mIGNoaWxkcmVuIGJldHdlZW5cbiAqIHVwZGF0ZXMuXG4gKi9cblxuXG52YXIgb3duZXJIYXNLZXlVc2VXYXJuaW5nID0ge307XG5cbmZ1bmN0aW9uIGdldEN1cnJlbnRDb21wb25lbnRFcnJvckluZm8ocGFyZW50VHlwZSkge1xuICB7XG4gICAgdmFyIGluZm8gPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcblxuICAgIGlmICghaW5mbykge1xuICAgICAgdmFyIHBhcmVudE5hbWUgPSBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUocGFyZW50VHlwZSk7XG5cbiAgICAgIGlmIChwYXJlbnROYW1lKSB7XG4gICAgICAgIGluZm8gPSBcIlxcblxcbkNoZWNrIHRoZSB0b3AtbGV2ZWwgcmVuZGVyIGNhbGwgdXNpbmcgPFwiICsgcGFyZW50TmFtZSArIFwiPi5cIjtcbiAgICAgIH1cbiAgICB9XG5cbiAgICByZXR1cm4gaW5mbztcbiAgfVxufVxuLyoqXG4gKiBXYXJuIGlmIHRoZSBlbGVtZW50IGRvZXNuJ3QgaGF2ZSBhbiBleHBsaWNpdCBrZXkgYXNzaWduZWQgdG8gaXQuXG4gKiBUaGlzIGVsZW1lbnQgaXMgaW4gYW4gYXJyYXkuIFRoZSBhcnJheSBjb3VsZCBncm93IGFuZCBzaHJpbmsgb3IgYmVcbiAqIHJlb3JkZXJlZC4gQWxsIGNoaWxkcmVuIHRoYXQgaGF2ZW4ndCBhbHJlYWR5IGJlZW4gdmFsaWRhdGVkIGFyZSByZXF1aXJlZCB0b1xuICogaGF2ZSBhIFwia2V5XCIgcHJvcGVydHkgYXNzaWduZWQgdG8gaXQuIEVycm9yIHN0YXR1c2VzIGFyZSBjYWNoZWQgc28gYSB3YXJuaW5nXG4gKiB3aWxsIG9ubHkgYmUgc2hvd24gb25jZS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3RFbGVtZW50fSBlbGVtZW50IEVsZW1lbnQgdGhhdCByZXF1aXJlcyBhIGtleS5cbiAqIEBwYXJhbSB7Kn0gcGFyZW50VHlwZSBlbGVtZW50J3MgcGFyZW50J3MgdHlwZS5cbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRXhwbGljaXRLZXkoZWxlbWVudCwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKCFlbGVtZW50Ll9zdG9yZSB8fCBlbGVtZW50Ll9zdG9yZS52YWxpZGF0ZWQgfHwgZWxlbWVudC5rZXkgIT0gbnVsbCkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGVsZW1lbnQuX3N0b3JlLnZhbGlkYXRlZCA9IHRydWU7XG4gICAgdmFyIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8gPSBnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvKHBhcmVudFR5cGUpO1xuXG4gICAgaWYgKG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIG93bmVySGFzS2V5VXNlV2FybmluZ1tjdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvXSA9IHRydWU7IC8vIFVzdWFsbHkgdGhlIGN1cnJlbnQgb3duZXIgaXMgdGhlIG9mZmVuZGVyLCBidXQgaWYgaXQgYWNjZXB0cyBjaGlsZHJlbiBhcyBhXG4gICAgLy8gcHJvcGVydHksIGl0IG1heSBiZSB0aGUgY3JlYXRvciBvZiB0aGUgY2hpbGQgdGhhdCdzIHJlc3BvbnNpYmxlIGZvclxuICAgIC8vIGFzc2lnbmluZyBpdCBhIGtleS5cblxuICAgIHZhciBjaGlsZE93bmVyID0gJyc7XG5cbiAgICBpZiAoZWxlbWVudCAmJiBlbGVtZW50Ll9vd25lciAmJiBlbGVtZW50Ll9vd25lciAhPT0gUmVhY3RDdXJyZW50T3duZXIuY3VycmVudCkge1xuICAgICAgLy8gR2l2ZSB0aGUgY29tcG9uZW50IHRoYXQgb3JpZ2luYWxseSBjcmVhdGVkIHRoaXMgY2hpbGQuXG4gICAgICBjaGlsZE93bmVyID0gXCIgSXQgd2FzIHBhc3NlZCBhIGNoaWxkIGZyb20gXCIgKyBnZXRDb21wb25lbnROYW1lRnJvbVR5cGUoZWxlbWVudC5fb3duZXIudHlwZSkgKyBcIi5cIjtcbiAgICB9XG5cbiAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChlbGVtZW50KTtcblxuICAgIGVycm9yKCdFYWNoIGNoaWxkIGluIGEgbGlzdCBzaG91bGQgaGF2ZSBhIHVuaXF1ZSBcImtleVwiIHByb3AuJyArICclcyVzIFNlZSBodHRwczovL3JlYWN0anMub3JnL2xpbmsvd2FybmluZy1rZXlzIGZvciBtb3JlIGluZm9ybWF0aW9uLicsIGN1cnJlbnRDb21wb25lbnRFcnJvckluZm8sIGNoaWxkT3duZXIpO1xuXG4gICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gIH1cbn1cbi8qKlxuICogRW5zdXJlIHRoYXQgZXZlcnkgZWxlbWVudCBlaXRoZXIgaXMgcGFzc2VkIGluIGEgc3RhdGljIGxvY2F0aW9uLCBpbiBhblxuICogYXJyYXkgd2l0aCBhbiBleHBsaWNpdCBrZXlzIHByb3BlcnR5IGRlZmluZWQsIG9yIGluIGFuIG9iamVjdCBsaXRlcmFsXG4gKiB3aXRoIHZhbGlkIGtleSBwcm9wZXJ0eS5cbiAqXG4gKiBAaW50ZXJuYWxcbiAqIEBwYXJhbSB7UmVhY3ROb2RlfSBub2RlIFN0YXRpY2FsbHkgcGFzc2VkIGNoaWxkIG9mIGFueSB0eXBlLlxuICogQHBhcmFtIHsqfSBwYXJlbnRUeXBlIG5vZGUncyBwYXJlbnQncyB0eXBlLlxuICovXG5cblxuZnVuY3Rpb24gdmFsaWRhdGVDaGlsZEtleXMobm9kZSwgcGFyZW50VHlwZSkge1xuICB7XG4gICAgaWYgKHR5cGVvZiBub2RlICE9PSAnb2JqZWN0JyB8fCAhbm9kZSkge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmIChub2RlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSA7IGVsc2UgaWYgKGlzQXJyYXkobm9kZSkpIHtcbiAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgbm9kZS5sZW5ndGg7IGkrKykge1xuICAgICAgICB2YXIgY2hpbGQgPSBub2RlW2ldO1xuXG4gICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChjaGlsZCkpIHtcbiAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KGNoaWxkLCBwYXJlbnRUeXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNWYWxpZEVsZW1lbnQobm9kZSkpIHtcbiAgICAgIC8vIFRoaXMgZWxlbWVudCB3YXMgcGFzc2VkIGluIGEgdmFsaWQgbG9jYXRpb24uXG4gICAgICBpZiAobm9kZS5fc3RvcmUpIHtcbiAgICAgICAgbm9kZS5fc3RvcmUudmFsaWRhdGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9IGVsc2Uge1xuICAgICAgdmFyIGl0ZXJhdG9yRm4gPSBnZXRJdGVyYXRvckZuKG5vZGUpO1xuXG4gICAgICBpZiAodHlwZW9mIGl0ZXJhdG9yRm4gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgLy8gRW50cnkgaXRlcmF0b3JzIHVzZWQgdG8gcHJvdmlkZSBpbXBsaWNpdCBrZXlzLFxuICAgICAgICAvLyBidXQgbm93IHdlIHByaW50IGEgc2VwYXJhdGUgd2FybmluZyBmb3IgdGhlbSBsYXRlci5cbiAgICAgICAgaWYgKGl0ZXJhdG9yRm4gIT09IG5vZGUuZW50cmllcykge1xuICAgICAgICAgIHZhciBpdGVyYXRvciA9IGl0ZXJhdG9yRm4uY2FsbChub2RlKTtcbiAgICAgICAgICB2YXIgc3RlcDtcblxuICAgICAgICAgIHdoaWxlICghKHN0ZXAgPSBpdGVyYXRvci5uZXh0KCkpLmRvbmUpIHtcbiAgICAgICAgICAgIGlmIChpc1ZhbGlkRWxlbWVudChzdGVwLnZhbHVlKSkge1xuICAgICAgICAgICAgICB2YWxpZGF0ZUV4cGxpY2l0S2V5KHN0ZXAudmFsdWUsIHBhcmVudFR5cGUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cbiAgfVxufVxuLyoqXG4gKiBHaXZlbiBhbiBlbGVtZW50LCB2YWxpZGF0ZSB0aGF0IGl0cyBwcm9wcyBmb2xsb3cgdGhlIHByb3BUeXBlcyBkZWZpbml0aW9uLFxuICogcHJvdmlkZWQgYnkgdGhlIHR5cGUuXG4gKlxuICogQHBhcmFtIHtSZWFjdEVsZW1lbnR9IGVsZW1lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpIHtcbiAge1xuICAgIHZhciB0eXBlID0gZWxlbWVudC50eXBlO1xuXG4gICAgaWYgKHR5cGUgPT09IG51bGwgfHwgdHlwZSA9PT0gdW5kZWZpbmVkIHx8IHR5cGVvZiB0eXBlID09PSAnc3RyaW5nJykge1xuICAgICAgcmV0dXJuO1xuICAgIH1cblxuICAgIGlmICh0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9DTElFTlRfUkVGRVJFTkNFKSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgdmFyIHByb3BUeXBlcztcblxuICAgIGlmICh0eXBlb2YgdHlwZSA9PT0gJ2Z1bmN0aW9uJykge1xuICAgICAgcHJvcFR5cGVzID0gdHlwZS5wcm9wVHlwZXM7XG4gICAgfSBlbHNlIGlmICh0eXBlb2YgdHlwZSA9PT0gJ29iamVjdCcgJiYgKHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX0ZPUldBUkRfUkVGX1RZUEUgfHwgLy8gTm90ZTogTWVtbyBvbmx5IGNoZWNrcyBvdXRlciBwcm9wcyBoZXJlLlxuICAgIC8vIElubmVyIHByb3BzIGFyZSBjaGVja2VkIGluIHRoZSByZWNvbmNpbGVyLlxuICAgIHR5cGUuJCR0eXBlb2YgPT09IFJFQUNUX01FTU9fVFlQRSkpIHtcbiAgICAgIHByb3BUeXBlcyA9IHR5cGUucHJvcFR5cGVzO1xuICAgIH0gZWxzZSB7XG4gICAgICByZXR1cm47XG4gICAgfVxuXG4gICAgaWYgKHByb3BUeXBlcykge1xuICAgICAgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcbiAgICAgIHZhciBuYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgY2hlY2tQcm9wVHlwZXMocHJvcFR5cGVzLCBlbGVtZW50LnByb3BzLCAncHJvcCcsIG5hbWUsIGVsZW1lbnQpO1xuICAgIH0gZWxzZSBpZiAodHlwZS5Qcm9wVHlwZXMgIT09IHVuZGVmaW5lZCAmJiAhcHJvcFR5cGVzTWlzc3BlbGxXYXJuaW5nU2hvd24pIHtcbiAgICAgIHByb3BUeXBlc01pc3NwZWxsV2FybmluZ1Nob3duID0gdHJ1ZTsgLy8gSW50ZW50aW9uYWxseSBpbnNpZGUgdG8gYXZvaWQgdHJpZ2dlcmluZyBsYXp5IGluaXRpYWxpemVyczpcblxuICAgICAgdmFyIF9uYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuXG4gICAgICBlcnJvcignQ29tcG9uZW50ICVzIGRlY2xhcmVkIGBQcm9wVHlwZXNgIGluc3RlYWQgb2YgYHByb3BUeXBlc2AuIERpZCB5b3UgbWlzc3BlbGwgdGhlIHByb3BlcnR5IGFzc2lnbm1lbnQ/JywgX25hbWUgfHwgJ1Vua25vd24nKTtcbiAgICB9XG5cbiAgICBpZiAodHlwZW9mIHR5cGUuZ2V0RGVmYXVsdFByb3BzID09PSAnZnVuY3Rpb24nICYmICF0eXBlLmdldERlZmF1bHRQcm9wcy5pc1JlYWN0Q2xhc3NBcHByb3ZlZCkge1xuICAgICAgZXJyb3IoJ2dldERlZmF1bHRQcm9wcyBpcyBvbmx5IHVzZWQgb24gY2xhc3NpYyBSZWFjdC5jcmVhdGVDbGFzcyAnICsgJ2RlZmluaXRpb25zLiBVc2UgYSBzdGF0aWMgcHJvcGVydHkgbmFtZWQgYGRlZmF1bHRQcm9wc2AgaW5zdGVhZC4nKTtcbiAgICB9XG4gIH1cbn1cbi8qKlxuICogR2l2ZW4gYSBmcmFnbWVudCwgdmFsaWRhdGUgdGhhdCBpdCBjYW4gb25seSBiZSBwcm92aWRlZCB3aXRoIGZyYWdtZW50IHByb3BzXG4gKiBAcGFyYW0ge1JlYWN0RWxlbWVudH0gZnJhZ21lbnRcbiAqL1xuXG5cbmZ1bmN0aW9uIHZhbGlkYXRlRnJhZ21lbnRQcm9wcyhmcmFnbWVudCkge1xuICB7XG4gICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhmcmFnbWVudC5wcm9wcyk7XG5cbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIHZhciBrZXkgPSBrZXlzW2ldO1xuXG4gICAgICBpZiAoa2V5ICE9PSAnY2hpbGRyZW4nICYmIGtleSAhPT0gJ2tleScpIHtcbiAgICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICAgIGVycm9yKCdJbnZhbGlkIHByb3AgYCVzYCBzdXBwbGllZCB0byBgUmVhY3QuRnJhZ21lbnRgLiAnICsgJ1JlYWN0LkZyYWdtZW50IGNhbiBvbmx5IGhhdmUgYGtleWAgYW5kIGBjaGlsZHJlbmAgcHJvcHMuJywga2V5KTtcblxuICAgICAgICBzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudChudWxsKTtcbiAgICAgICAgYnJlYWs7XG4gICAgICB9XG4gICAgfVxuXG4gICAgaWYgKGZyYWdtZW50LnJlZiAhPT0gbnVsbCkge1xuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQoZnJhZ21lbnQpO1xuXG4gICAgICBlcnJvcignSW52YWxpZCBhdHRyaWJ1dGUgYHJlZmAgc3VwcGxpZWQgdG8gYFJlYWN0LkZyYWdtZW50YC4nKTtcblxuICAgICAgc2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQobnVsbCk7XG4gICAgfVxuICB9XG59XG5cbnZhciBkaWRXYXJuQWJvdXRLZXlTcHJlYWQgPSB7fTtcbmZ1bmN0aW9uIGpzeFdpdGhWYWxpZGF0aW9uKHR5cGUsIHByb3BzLCBrZXksIGlzU3RhdGljQ2hpbGRyZW4sIHNvdXJjZSwgc2VsZikge1xuICB7XG4gICAgdmFyIHZhbGlkVHlwZSA9IGlzVmFsaWRFbGVtZW50VHlwZSh0eXBlKTsgLy8gV2Ugd2FybiBpbiB0aGlzIGNhc2UgYnV0IGRvbid0IHRocm93LiBXZSBleHBlY3QgdGhlIGVsZW1lbnQgY3JlYXRpb24gdG9cbiAgICAvLyBzdWNjZWVkIGFuZCB0aGVyZSB3aWxsIGxpa2VseSBiZSBlcnJvcnMgaW4gcmVuZGVyLlxuXG4gICAgaWYgKCF2YWxpZFR5cGUpIHtcbiAgICAgIHZhciBpbmZvID0gJyc7XG5cbiAgICAgIGlmICh0eXBlID09PSB1bmRlZmluZWQgfHwgdHlwZW9mIHR5cGUgPT09ICdvYmplY3QnICYmIHR5cGUgIT09IG51bGwgJiYgT2JqZWN0LmtleXModHlwZSkubGVuZ3RoID09PSAwKSB7XG4gICAgICAgIGluZm8gKz0gJyBZb3UgbGlrZWx5IGZvcmdvdCB0byBleHBvcnQgeW91ciBjb21wb25lbnQgZnJvbSB0aGUgZmlsZSAnICsgXCJpdCdzIGRlZmluZWQgaW4sIG9yIHlvdSBtaWdodCBoYXZlIG1peGVkIHVwIGRlZmF1bHQgYW5kIG5hbWVkIGltcG9ydHMuXCI7XG4gICAgICB9XG5cbiAgICAgIHZhciBzb3VyY2VJbmZvID0gZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0oc291cmNlKTtcblxuICAgICAgaWYgKHNvdXJjZUluZm8pIHtcbiAgICAgICAgaW5mbyArPSBzb3VyY2VJbmZvO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaW5mbyArPSBnZXREZWNsYXJhdGlvbkVycm9yQWRkZW5kdW0oKTtcbiAgICAgIH1cblxuICAgICAgdmFyIHR5cGVTdHJpbmc7XG5cbiAgICAgIGlmICh0eXBlID09PSBudWxsKSB7XG4gICAgICAgIHR5cGVTdHJpbmcgPSAnbnVsbCc7XG4gICAgICB9IGVsc2UgaWYgKGlzQXJyYXkodHlwZSkpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9ICdhcnJheSc7XG4gICAgICB9IGVsc2UgaWYgKHR5cGUgIT09IHVuZGVmaW5lZCAmJiB0eXBlLiQkdHlwZW9mID09PSBSRUFDVF9FTEVNRU5UX1RZUEUpIHtcbiAgICAgICAgdHlwZVN0cmluZyA9IFwiPFwiICsgKGdldENvbXBvbmVudE5hbWVGcm9tVHlwZSh0eXBlLnR5cGUpIHx8ICdVbmtub3duJykgKyBcIiAvPlwiO1xuICAgICAgICBpbmZvID0gJyBEaWQgeW91IGFjY2lkZW50YWxseSBleHBvcnQgYSBKU1ggbGl0ZXJhbCBpbnN0ZWFkIG9mIGEgY29tcG9uZW50Pyc7XG4gICAgICB9IGVsc2Uge1xuICAgICAgICB0eXBlU3RyaW5nID0gdHlwZW9mIHR5cGU7XG4gICAgICB9XG5cbiAgICAgIGVycm9yKCdSZWFjdC5qc3g6IHR5cGUgaXMgaW52YWxpZCAtLSBleHBlY3RlZCBhIHN0cmluZyAoZm9yICcgKyAnYnVpbHQtaW4gY29tcG9uZW50cykgb3IgYSBjbGFzcy9mdW5jdGlvbiAoZm9yIGNvbXBvc2l0ZSAnICsgJ2NvbXBvbmVudHMpIGJ1dCBnb3Q6ICVzLiVzJywgdHlwZVN0cmluZywgaW5mbyk7XG4gICAgfVxuXG4gICAgdmFyIGVsZW1lbnQgPSBqc3hERVYkMSh0eXBlLCBwcm9wcywga2V5LCBzb3VyY2UsIHNlbGYpOyAvLyBUaGUgcmVzdWx0IGNhbiBiZSBudWxsaXNoIGlmIGEgbW9jayBvciBhIGN1c3RvbSBmdW5jdGlvbiBpcyB1c2VkLlxuICAgIC8vIFRPRE86IERyb3AgdGhpcyB3aGVuIHRoZXNlIGFyZSBubyBsb25nZXIgYWxsb3dlZCBhcyB0aGUgdHlwZSBhcmd1bWVudC5cblxuICAgIGlmIChlbGVtZW50ID09IG51bGwpIHtcbiAgICAgIHJldHVybiBlbGVtZW50O1xuICAgIH0gLy8gU2tpcCBrZXkgd2FybmluZyBpZiB0aGUgdHlwZSBpc24ndCB2YWxpZCBzaW5jZSBvdXIga2V5IHZhbGlkYXRpb24gbG9naWNcbiAgICAvLyBkb2Vzbid0IGV4cGVjdCBhIG5vbi1zdHJpbmcvZnVuY3Rpb24gdHlwZSBhbmQgY2FuIHRocm93IGNvbmZ1c2luZyBlcnJvcnMuXG4gICAgLy8gV2UgZG9uJ3Qgd2FudCBleGNlcHRpb24gYmVoYXZpb3IgdG8gZGlmZmVyIGJldHdlZW4gZGV2IGFuZCBwcm9kLlxuICAgIC8vIChSZW5kZXJpbmcgd2lsbCB0aHJvdyB3aXRoIGEgaGVscGZ1bCBtZXNzYWdlIGFuZCBhcyBzb29uIGFzIHRoZSB0eXBlIGlzXG4gICAgLy8gZml4ZWQsIHRoZSBrZXkgd2FybmluZ3Mgd2lsbCBhcHBlYXIuKVxuXG5cbiAgICBpZiAodmFsaWRUeXBlKSB7XG4gICAgICB2YXIgY2hpbGRyZW4gPSBwcm9wcy5jaGlsZHJlbjtcblxuICAgICAgaWYgKGNoaWxkcmVuICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKGlzU3RhdGljQ2hpbGRyZW4pIHtcbiAgICAgICAgICBpZiAoaXNBcnJheShjaGlsZHJlbikpIHtcbiAgICAgICAgICAgIGZvciAodmFyIGkgPSAwOyBpIDwgY2hpbGRyZW4ubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgICAgdmFsaWRhdGVDaGlsZEtleXMoY2hpbGRyZW5baV0sIHR5cGUpO1xuICAgICAgICAgICAgfVxuXG4gICAgICAgICAgICBpZiAoT2JqZWN0LmZyZWV6ZSkge1xuICAgICAgICAgICAgICBPYmplY3QuZnJlZXplKGNoaWxkcmVuKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgZXJyb3IoJ1JlYWN0LmpzeDogU3RhdGljIGNoaWxkcmVuIHNob3VsZCBhbHdheXMgYmUgYW4gYXJyYXkuICcgKyAnWW91IGFyZSBsaWtlbHkgZXhwbGljaXRseSBjYWxsaW5nIFJlYWN0LmpzeHMgb3IgUmVhY3QuanN4REVWLiAnICsgJ1VzZSB0aGUgQmFiZWwgdHJhbnNmb3JtIGluc3RlYWQuJyk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHZhbGlkYXRlQ2hpbGRLZXlzKGNoaWxkcmVuLCB0eXBlKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIGlmIChoYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3BzLCAna2V5JykpIHtcbiAgICAgIHZhciBjb21wb25lbnROYW1lID0gZ2V0Q29tcG9uZW50TmFtZUZyb21UeXBlKHR5cGUpO1xuICAgICAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhwcm9wcykuZmlsdGVyKGZ1bmN0aW9uIChrKSB7XG4gICAgICAgIHJldHVybiBrICE9PSAna2V5JztcbiAgICAgIH0pO1xuICAgICAgdmFyIGJlZm9yZUV4YW1wbGUgPSBrZXlzLmxlbmd0aCA+IDAgPyAne2tleTogc29tZUtleSwgJyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne2tleTogc29tZUtleX0nO1xuXG4gICAgICBpZiAoIWRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0pIHtcbiAgICAgICAgdmFyIGFmdGVyRXhhbXBsZSA9IGtleXMubGVuZ3RoID4gMCA/ICd7JyArIGtleXMuam9pbignOiAuLi4sICcpICsgJzogLi4ufScgOiAne30nO1xuXG4gICAgICAgIGVycm9yKCdBIHByb3BzIG9iamVjdCBjb250YWluaW5nIGEgXCJrZXlcIiBwcm9wIGlzIGJlaW5nIHNwcmVhZCBpbnRvIEpTWDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyB7Li4ucHJvcHN9IC8+XFxuJyArICdSZWFjdCBrZXlzIG11c3QgYmUgcGFzc2VkIGRpcmVjdGx5IHRvIEpTWCB3aXRob3V0IHVzaW5nIHNwcmVhZDpcXG4nICsgJyAgbGV0IHByb3BzID0gJXM7XFxuJyArICcgIDwlcyBrZXk9e3NvbWVLZXl9IHsuLi5wcm9wc30gLz4nLCBiZWZvcmVFeGFtcGxlLCBjb21wb25lbnROYW1lLCBhZnRlckV4YW1wbGUsIGNvbXBvbmVudE5hbWUpO1xuXG4gICAgICAgIGRpZFdhcm5BYm91dEtleVNwcmVhZFtjb21wb25lbnROYW1lICsgYmVmb3JlRXhhbXBsZV0gPSB0cnVlO1xuICAgICAgfVxuICAgIH1cblxuICAgIGlmICh0eXBlID09PSBSRUFDVF9GUkFHTUVOVF9UWVBFKSB7XG4gICAgICB2YWxpZGF0ZUZyYWdtZW50UHJvcHMoZWxlbWVudCk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhbGlkYXRlUHJvcFR5cGVzKGVsZW1lbnQpO1xuICAgIH1cblxuICAgIHJldHVybiBlbGVtZW50O1xuICB9XG59IC8vIFRoZXNlIHR3byBmdW5jdGlvbnMgZXhpc3QgdG8gc3RpbGwgZ2V0IGNoaWxkIHdhcm5pbmdzIGluIGRldlxuXG52YXIganN4REVWID0ganN4V2l0aFZhbGlkYXRpb24gO1xuXG5leHBvcnRzLkZyYWdtZW50ID0gUkVBQ1RfRlJBR01FTlRfVFlQRTtcbmV4cG9ydHMuanN4REVWID0ganN4REVWO1xuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJSZWFjdCIsInJlcXVpcmUiLCJSRUFDVF9FTEVNRU5UX1RZUEUiLCJTeW1ib2wiLCJmb3IiLCJSRUFDVF9QT1JUQUxfVFlQRSIsIlJFQUNUX0ZSQUdNRU5UX1RZUEUiLCJSRUFDVF9TVFJJQ1RfTU9ERV9UWVBFIiwiUkVBQ1RfUFJPRklMRVJfVFlQRSIsIlJFQUNUX1BST1ZJREVSX1RZUEUiLCJSRUFDVF9DT05URVhUX1RZUEUiLCJSRUFDVF9GT1JXQVJEX1JFRl9UWVBFIiwiUkVBQ1RfU1VTUEVOU0VfVFlQRSIsIlJFQUNUX1NVU1BFTlNFX0xJU1RfVFlQRSIsIlJFQUNUX01FTU9fVFlQRSIsIlJFQUNUX0xBWllfVFlQRSIsIlJFQUNUX09GRlNDUkVFTl9UWVBFIiwiUkVBQ1RfQ0FDSEVfVFlQRSIsIk1BWUJFX0lURVJBVE9SX1NZTUJPTCIsIml0ZXJhdG9yIiwiRkFVWF9JVEVSQVRPUl9TWU1CT0wiLCJnZXRJdGVyYXRvckZuIiwibWF5YmVJdGVyYWJsZSIsIm1heWJlSXRlcmF0b3IiLCJSZWFjdFNoYXJlZEludGVybmFscyIsIl9fU0VDUkVUX0lOVEVSTkFMU19ET19OT1RfVVNFX09SX1lPVV9XSUxMX0JFX0ZJUkVEIiwiZXJyb3IiLCJmb3JtYXQiLCJfbGVuMiIsImFyZ3VtZW50cyIsImxlbmd0aCIsImFyZ3MiLCJBcnJheSIsIl9rZXkyIiwicHJpbnRXYXJuaW5nIiwibGV2ZWwiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lIiwic3RhY2siLCJnZXRTdGFja0FkZGVuZHVtIiwiY29uY2F0IiwiYXJnc1dpdGhGb3JtYXQiLCJtYXAiLCJpdGVtIiwiU3RyaW5nIiwidW5zaGlmdCIsIkZ1bmN0aW9uIiwicHJvdG90eXBlIiwiYXBwbHkiLCJjYWxsIiwiY29uc29sZSIsImVuYWJsZVNjb3BlQVBJIiwiZW5hYmxlQ2FjaGVFbGVtZW50IiwiZW5hYmxlVHJhbnNpdGlvblRyYWNpbmciLCJlbmFibGVMZWdhY3lIaWRkZW4iLCJlbmFibGVEZWJ1Z1RyYWNpbmciLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFJDIiLCJpc1ZhbGlkRWxlbWVudFR5cGUiLCJ0eXBlIiwiJCR0eXBlb2YiLCJnZXRNb2R1bGVJZCIsInVuZGVmaW5lZCIsImdldFdyYXBwZWROYW1lIiwib3V0ZXJUeXBlIiwiaW5uZXJUeXBlIiwid3JhcHBlck5hbWUiLCJkaXNwbGF5TmFtZSIsImZ1bmN0aW9uTmFtZSIsIm5hbWUiLCJnZXRDb250ZXh0TmFtZSIsIlJFQUNUX0NMSUVOVF9SRUZFUkVOQ0UkMSIsImdldENvbXBvbmVudE5hbWVGcm9tVHlwZSIsInRhZyIsImNvbnRleHQiLCJwcm92aWRlciIsIl9jb250ZXh0IiwicmVuZGVyIiwib3V0ZXJOYW1lIiwibGF6eUNvbXBvbmVudCIsInBheWxvYWQiLCJfcGF5bG9hZCIsImluaXQiLCJfaW5pdCIsIngiLCJhc3NpZ24iLCJPYmplY3QiLCJkaXNhYmxlZERlcHRoIiwicHJldkxvZyIsInByZXZJbmZvIiwicHJldldhcm4iLCJwcmV2RXJyb3IiLCJwcmV2R3JvdXAiLCJwcmV2R3JvdXBDb2xsYXBzZWQiLCJwcmV2R3JvdXBFbmQiLCJkaXNhYmxlZExvZyIsIl9fcmVhY3REaXNhYmxlZExvZyIsImRpc2FibGVMb2dzIiwibG9nIiwiaW5mbyIsIndhcm4iLCJncm91cCIsImdyb3VwQ29sbGFwc2VkIiwiZ3JvdXBFbmQiLCJwcm9wcyIsImNvbmZpZ3VyYWJsZSIsImVudW1lcmFibGUiLCJ2YWx1ZSIsIndyaXRhYmxlIiwiZGVmaW5lUHJvcGVydGllcyIsInJlZW5hYmxlTG9ncyIsIlJlYWN0Q3VycmVudERpc3BhdGNoZXIiLCJwcmVmaXgiLCJkZXNjcmliZUJ1aWx0SW5Db21wb25lbnRGcmFtZSIsInNvdXJjZSIsIm93bmVyRm4iLCJFcnJvciIsIm1hdGNoIiwidHJpbSIsInJlZW50cnkiLCJjb21wb25lbnRGcmFtZUNhY2hlIiwiUG9zc2libHlXZWFrTWFwIiwiV2Vha01hcCIsIk1hcCIsImRlc2NyaWJlTmF0aXZlQ29tcG9uZW50RnJhbWUiLCJmbiIsImNvbnN0cnVjdCIsImZyYW1lIiwiZ2V0IiwicHJldmlvdXNQcmVwYXJlU3RhY2tUcmFjZSIsInByZXBhcmVTdGFja1RyYWNlIiwicHJldmlvdXNEaXNwYXRjaGVyIiwiY3VycmVudCIsIlJ1bkluUm9vdEZyYW1lIiwiRGV0ZXJtaW5lQ29tcG9uZW50RnJhbWVSb290IiwiY29udHJvbCIsIkZha2UiLCJkZWZpbmVQcm9wZXJ0eSIsInNldCIsIlJlZmxlY3QiLCJtYXliZVByb21pc2UiLCJjYXRjaCIsInNhbXBsZSIsIm5hbWVQcm9wRGVzY3JpcHRvciIsImdldE93blByb3BlcnR5RGVzY3JpcHRvciIsIl9SdW5JblJvb3RGcmFtZSREZXRlciIsInNhbXBsZVN0YWNrIiwiY29udHJvbFN0YWNrIiwic2FtcGxlTGluZXMiLCJzcGxpdCIsImNvbnRyb2xMaW5lcyIsInMiLCJjIiwiaW5jbHVkZXMiLCJfZnJhbWUiLCJyZXBsYWNlIiwic3ludGhldGljRnJhbWUiLCJkZXNjcmliZUZ1bmN0aW9uQ29tcG9uZW50RnJhbWUiLCJzaG91bGRDb25zdHJ1Y3QiLCJDb21wb25lbnQiLCJpc1JlYWN0Q29tcG9uZW50IiwiZGVzY3JpYmVVbmtub3duRWxlbWVudFR5cGVGcmFtZUluREVWIiwiaGFzT3duUHJvcGVydHkiLCJsb2dnZWRUeXBlRmFpbHVyZXMiLCJSZWFjdERlYnVnQ3VycmVudEZyYW1lJDEiLCJzZXRDdXJyZW50bHlWYWxpZGF0aW5nRWxlbWVudCQxIiwiZWxlbWVudCIsIm93bmVyIiwiX293bmVyIiwiX3NvdXJjZSIsInNldEV4dHJhU3RhY2tGcmFtZSIsImNoZWNrUHJvcFR5cGVzIiwidHlwZVNwZWNzIiwidmFsdWVzIiwibG9jYXRpb24iLCJjb21wb25lbnROYW1lIiwiaGFzIiwiYmluZCIsInR5cGVTcGVjTmFtZSIsImVycm9yJDEiLCJlcnIiLCJleCIsIm1lc3NhZ2UiLCJpc0FycmF5SW1wbCIsImlzQXJyYXkiLCJhIiwidHlwZU5hbWUiLCJoYXNUb1N0cmluZ1RhZyIsInRvU3RyaW5nVGFnIiwiY29uc3RydWN0b3IiLCJ3aWxsQ29lcmNpb25UaHJvdyIsInRlc3RTdHJpbmdDb2VyY2lvbiIsImUiLCJjaGVja0tleVN0cmluZ0NvZXJjaW9uIiwiUmVhY3RDdXJyZW50T3duZXIkMSIsIlJlYWN0Q3VycmVudE93bmVyIiwiUkVTRVJWRURfUFJPUFMiLCJrZXkiLCJyZWYiLCJfX3NlbGYiLCJfX3NvdXJjZSIsInNwZWNpYWxQcm9wS2V5V2FybmluZ1Nob3duIiwic3BlY2lhbFByb3BSZWZXYXJuaW5nU2hvd24iLCJkaWRXYXJuQWJvdXRTdHJpbmdSZWZzIiwiaGFzVmFsaWRSZWYiLCJjb25maWciLCJnZXR0ZXIiLCJpc1JlYWN0V2FybmluZyIsImhhc1ZhbGlkS2V5Iiwid2FybklmU3RyaW5nUmVmQ2Fubm90QmVBdXRvQ29udmVydGVkIiwic2VsZiIsInN0YXRlTm9kZSIsImRlZmluZUtleVByb3BXYXJuaW5nR2V0dGVyIiwid2FybkFib3V0QWNjZXNzaW5nS2V5IiwiZGVmaW5lUmVmUHJvcFdhcm5pbmdHZXR0ZXIiLCJ3YXJuQWJvdXRBY2Nlc3NpbmdSZWYiLCJSZWFjdEVsZW1lbnQiLCJfc3RvcmUiLCJmcmVlemUiLCJqc3hERVYkMSIsIm1heWJlS2V5IiwicHJvcE5hbWUiLCJkZWZhdWx0UHJvcHMiLCJSRUFDVF9DTElFTlRfUkVGRVJFTkNFIiwic2V0Q3VycmVudGx5VmFsaWRhdGluZ0VsZW1lbnQiLCJwcm9wVHlwZXNNaXNzcGVsbFdhcm5pbmdTaG93biIsImlzVmFsaWRFbGVtZW50Iiwib2JqZWN0IiwiZ2V0RGVjbGFyYXRpb25FcnJvckFkZGVuZHVtIiwiZ2V0U291cmNlSW5mb0Vycm9yQWRkZW5kdW0iLCJmaWxlTmFtZSIsImxpbmVOdW1iZXIiLCJvd25lckhhc0tleVVzZVdhcm5pbmciLCJnZXRDdXJyZW50Q29tcG9uZW50RXJyb3JJbmZvIiwicGFyZW50VHlwZSIsInBhcmVudE5hbWUiLCJ2YWxpZGF0ZUV4cGxpY2l0S2V5IiwidmFsaWRhdGVkIiwiY3VycmVudENvbXBvbmVudEVycm9ySW5mbyIsImNoaWxkT3duZXIiLCJ2YWxpZGF0ZUNoaWxkS2V5cyIsIm5vZGUiLCJpIiwiY2hpbGQiLCJpdGVyYXRvckZuIiwiZW50cmllcyIsInN0ZXAiLCJuZXh0IiwiZG9uZSIsInZhbGlkYXRlUHJvcFR5cGVzIiwicHJvcFR5cGVzIiwiUHJvcFR5cGVzIiwiX25hbWUiLCJnZXREZWZhdWx0UHJvcHMiLCJpc1JlYWN0Q2xhc3NBcHByb3ZlZCIsInZhbGlkYXRlRnJhZ21lbnRQcm9wcyIsImZyYWdtZW50Iiwia2V5cyIsImRpZFdhcm5BYm91dEtleVNwcmVhZCIsImpzeFdpdGhWYWxpZGF0aW9uIiwiaXNTdGF0aWNDaGlsZHJlbiIsInZhbGlkVHlwZSIsInNvdXJjZUluZm8iLCJ0eXBlU3RyaW5nIiwiY2hpbGRyZW4iLCJmaWx0ZXIiLCJrIiwiYmVmb3JlRXhhbXBsZSIsImpvaW4iLCJhZnRlckV4YW1wbGUiLCJqc3hERVYiLCJleHBvcnRzIiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js":
/*!******************************************************************!*\
  !*** ./node_modules/next/dist/compiled/react/jsx-dev-runtime.js ***!
  \******************************************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/react-jsx-dev-runtime.development.js */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/cjs/react-jsx-dev-runtime.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9uZXh0L2Rpc3QvY29tcGlsZWQvcmVhY3QvanN4LWRldi1ydW50aW1lLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBRUEsSUFBSUEsS0FBeUIsRUFBYyxFQUUxQyxNQUFNO0lBQ0xDLDhMQUF5QjtBQUMzQiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvbmV4dC9kaXN0L2NvbXBpbGVkL3JlYWN0L2pzeC1kZXYtcnVudGltZS5qcz9jYTIwIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2Ugc3RyaWN0JztcblxuaWYgKHByb2Nlc3MuZW52Lk5PREVfRU5WID09PSAncHJvZHVjdGlvbicpIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9yZWFjdC1qc3gtZGV2LXJ1bnRpbWUucHJvZHVjdGlvbi5taW4uanMnKTtcbn0gZWxzZSB7XG4gIG1vZHVsZS5leHBvcnRzID0gcmVxdWlyZSgnLi9janMvcmVhY3QtanN4LWRldi1ydW50aW1lLmRldmVsb3BtZW50LmpzJyk7XG59XG4iXSwibmFtZXMiOlsicHJvY2VzcyIsIm1vZHVsZSIsImV4cG9ydHMiLCJyZXF1aXJlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/property-expr/index.js":
/*!*********************************************!*\
  !*** ./node_modules/property-expr/index.js ***!
  \*********************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Based on Kendo UI Core expression code <https://github.com/telerik/kendo-ui-core#license-information>\n */ \nfunction Cache(maxSize) {\n    this._maxSize = maxSize;\n    this.clear();\n}\n_c = Cache;\nCache.prototype.clear = function() {\n    this._size = 0;\n    this._values = Object.create(null);\n};\nCache.prototype.get = function(key) {\n    return this._values[key];\n};\nCache.prototype.set = function(key, value) {\n    this._size >= this._maxSize && this.clear();\n    if (!(key in this._values)) this._size++;\n    return this._values[key] = value;\n};\nvar SPLIT_REGEX = /[^.^\\]^[]+|(?=\\[\\]|\\.\\.)/g, DIGIT_REGEX = /^\\d+$/, LEAD_DIGIT_REGEX = /^\\d/, SPEC_CHAR_REGEX = /[~`!#$%\\^&*+=\\-\\[\\]\\\\';,/{}|\\\\\":<>\\?]/g, CLEAN_QUOTES_REGEX = /^\\s*(['\"]?)(.*?)(\\1)\\s*$/, MAX_CACHE_SIZE = 512;\nvar pathCache = new Cache(MAX_CACHE_SIZE), setCache = new Cache(MAX_CACHE_SIZE), getCache = new Cache(MAX_CACHE_SIZE);\nvar config;\nmodule.exports = {\n    Cache: Cache,\n    split: split,\n    normalizePath: normalizePath,\n    setter: function(path) {\n        var parts = normalizePath(path);\n        return setCache.get(path) || setCache.set(path, function setter(obj, value) {\n            var index = 0;\n            var len = parts.length;\n            var data = obj;\n            while(index < len - 1){\n                var part = parts[index];\n                if (part === \"__proto__\" || part === \"constructor\" || part === \"prototype\") {\n                    return obj;\n                }\n                data = data[parts[index++]];\n            }\n            data[parts[index]] = value;\n        });\n    },\n    getter: function(path, safe) {\n        var parts = normalizePath(path);\n        return getCache.get(path) || getCache.set(path, function getter(data) {\n            var index = 0, len = parts.length;\n            while(index < len){\n                if (data != null || !safe) data = data[parts[index++]];\n                else return;\n            }\n            return data;\n        });\n    },\n    join: function(segments) {\n        return segments.reduce(function(path, part) {\n            return path + (isQuoted(part) || DIGIT_REGEX.test(part) ? \"[\" + part + \"]\" : (path ? \".\" : \"\") + part);\n        }, \"\");\n    },\n    forEach: function(path, cb, thisArg) {\n        forEach(Array.isArray(path) ? path : split(path), cb, thisArg);\n    }\n};\nfunction normalizePath(path) {\n    return pathCache.get(path) || pathCache.set(path, split(path).map(function(part) {\n        return part.replace(CLEAN_QUOTES_REGEX, \"$2\");\n    }));\n}\nfunction split(path) {\n    return path.match(SPLIT_REGEX) || [\n        \"\"\n    ];\n}\nfunction forEach(parts, iter, thisArg) {\n    var len = parts.length, part, idx, isArray, isBracket;\n    for(idx = 0; idx < len; idx++){\n        part = parts[idx];\n        if (part) {\n            if (shouldBeQuoted(part)) {\n                part = '\"' + part + '\"';\n            }\n            isBracket = isQuoted(part);\n            isArray = !isBracket && /^\\d+$/.test(part);\n            iter.call(thisArg, part, isBracket, isArray, idx, parts);\n        }\n    }\n}\nfunction isQuoted(str) {\n    return typeof str === \"string\" && str && [\n        \"'\",\n        '\"'\n    ].indexOf(str.charAt(0)) !== -1;\n}\nfunction hasLeadingNumber(part) {\n    return part.match(LEAD_DIGIT_REGEX) && !part.match(DIGIT_REGEX);\n}\nfunction hasSpecialChars(part) {\n    return SPEC_CHAR_REGEX.test(part);\n}\nfunction shouldBeQuoted(part) {\n    return !isQuoted(part) && (hasLeadingNumber(part) || hasSpecialChars(part));\n}\nvar _c;\n$RefreshReg$(_c, \"Cache\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1leHByL2luZGV4LmpzIiwibWFwcGluZ3MiOiJBQUFBOztDQUVDLEdBQ0Q7QUFFQSxTQUFTQSxNQUFNQyxPQUFPO0lBQ3BCLElBQUksQ0FBQ0MsUUFBUSxHQUFHRDtJQUNoQixJQUFJLENBQUNFLEtBQUs7QUFDWjtLQUhTSDtBQUlUQSxNQUFNSSxTQUFTLENBQUNELEtBQUssR0FBRztJQUN0QixJQUFJLENBQUNFLEtBQUssR0FBRztJQUNiLElBQUksQ0FBQ0MsT0FBTyxHQUFHQyxPQUFPQyxNQUFNLENBQUM7QUFDL0I7QUFDQVIsTUFBTUksU0FBUyxDQUFDSyxHQUFHLEdBQUcsU0FBVUMsR0FBRztJQUNqQyxPQUFPLElBQUksQ0FBQ0osT0FBTyxDQUFDSSxJQUFJO0FBQzFCO0FBQ0FWLE1BQU1JLFNBQVMsQ0FBQ08sR0FBRyxHQUFHLFNBQVVELEdBQUcsRUFBRUUsS0FBSztJQUN4QyxJQUFJLENBQUNQLEtBQUssSUFBSSxJQUFJLENBQUNILFFBQVEsSUFBSSxJQUFJLENBQUNDLEtBQUs7SUFDekMsSUFBSSxDQUFFTyxDQUFBQSxPQUFPLElBQUksQ0FBQ0osT0FBTyxHQUFHLElBQUksQ0FBQ0QsS0FBSztJQUV0QyxPQUFRLElBQUksQ0FBQ0MsT0FBTyxDQUFDSSxJQUFJLEdBQUdFO0FBQzlCO0FBRUEsSUFBSUMsY0FBYyw2QkFDaEJDLGNBQWMsU0FDZEMsbUJBQW1CLE9BQ25CQyxrQkFBa0IsMENBQ2xCQyxxQkFBcUIsNEJBQ3JCQyxpQkFBaUI7QUFFbkIsSUFBSUMsWUFBWSxJQUFJbkIsTUFBTWtCLGlCQUN4QkUsV0FBVyxJQUFJcEIsTUFBTWtCLGlCQUNyQkcsV0FBVyxJQUFJckIsTUFBTWtCO0FBRXZCLElBQUlJO0FBRUpDLE9BQU9DLE9BQU8sR0FBRztJQUNmeEIsT0FBT0E7SUFFUHlCLE9BQU9BO0lBRVBDLGVBQWVBO0lBRWZDLFFBQVEsU0FBVUMsSUFBSTtRQUNwQixJQUFJQyxR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QUFDbkMscUJBQXFCLENBQUNvQixLQUFLZSxLQUFLLENBQUNwQztBQUNyRDtBQUVBLFNBQVM4QyxnQkFBZ0J6QixJQUFJO0lBQzNCLE9BQU9uQixnQkFBZ0IwQixJQUFJLENBQUNQO0FBQzlCO0FBRUEsU0FBU21CLGVBQWVuQixJQUFJO0lBQzFCLE9BQU8sQ0FBQ00sU0FBU04sU0FBVXdCLENBQUFBLGlCQUFpQnhCLFNBQVN5QixnQkFBZ0J6QixLQUFJO0FBQzNFIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9wcm9wZXJ0eS1leHByL2luZGV4LmpzPzRmZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqXG4gKiBCYXNlZCBvbiBLZW5kbyBVSSBDb3JlIGV4cHJlc3Npb24gY29kZSA8aHR0cHM6Ly9naXRodWIuY29tL3RlbGVyaWsva2VuZG8tdWktY29yZSNsaWNlbnNlLWluZm9ybWF0aW9uPlxuICovXG4ndXNlIHN0cmljdCdcblxuZnVuY3Rpb24gQ2FjaGUobWF4U2l6ZSkge1xuICB0aGlzLl9tYXhTaXplID0gbWF4U2l6ZVxuICB0aGlzLmNsZWFyKClcbn1cbkNhY2hlLnByb3RvdHlwZS5jbGVhciA9IGZ1bmN0aW9uICgpIHtcbiAgdGhpcy5fc2l6ZSA9IDBcbiAgdGhpcy5fdmFsdWVzID0gT2JqZWN0LmNyZWF0ZShudWxsKVxufVxuQ2FjaGUucHJvdG90eXBlLmdldCA9IGZ1bmN0aW9uIChrZXkpIHtcbiAgcmV0dXJuIHRoaXMuX3ZhbHVlc1trZXldXG59XG5DYWNoZS5wcm90b3R5cGUuc2V0ID0gZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgdGhpcy5fc2l6ZSA+PSB0aGlzLl9tYXhTaXplICYmIHRoaXMuY2xlYXIoKVxuICBpZiAoIShrZXkgaW4gdGhpcy5fdmFsdWVzKSkgdGhpcy5fc2l6ZSsrXG5cbiAgcmV0dXJuICh0aGlzLl92YWx1ZXNba2V5XSA9IHZhbHVlKVxufVxuXG52YXIgU1BMSVRfUkVHRVggPSAvW14uXlxcXV5bXSt8KD89XFxbXFxdfFxcLlxcLikvZyxcbiAgRElHSVRfUkVHRVggPSAvXlxcZCskLyxcbiAgTEVBRF9ESUdJVF9SRUdFWCA9IC9eXFxkLyxcbiAgU1BFQ19DSEFSX1JFR0VYID0gL1t+YCEjJCVcXF4mKis9XFwtXFxbXFxdXFxcXCc7LC97fXxcXFxcXCI6PD5cXD9dL2csXG4gIENMRUFOX1FVT1RFU19SRUdFWCA9IC9eXFxzKihbJ1wiXT8pKC4qPykoXFwxKVxccyokLyxcbiAgTUFYX0NBQ0hFX1NJWkUgPSA1MTJcblxudmFyIHBhdGhDYWNoZSA9IG5ldyBDYWNoZShNQVhfQ0FDSEVfU0laRSksXG4gIHNldENhY2hlID0gbmV3IENhY2hlKE1BWF9DQUNIRV9TSVpFKSxcbiAgZ2V0Q2FjaGUgPSBuZXcgQ2FjaGUoTUFYX0NBQ0hFX1NJWkUpXG5cbnZhciBjb25maWdcblxubW9kdWxlLmV4cG9ydHMgPSB7XG4gIENhY2hlOiBDYWNoZSxcblxuICBzcGxpdDogc3BsaXQsXG5cbiAgbm9ybWFsaXplUGF0aDogbm9ybWFsaXplUGF0aCxcblxuICBzZXR0ZXI6IGZ1bmN0aW9uIChwYXRoKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuXG4gICAgcmV0dXJuIChcbiAgICAgIHNldENhY2hlLmdldChwYXRoKSB8fFxuICAgICAgc2V0Q2FjaGUuc2V0KHBhdGgsIGZ1bmN0aW9uIHNldHRlcihvYmosIHZhbHVlKSB7XG4gICAgICAgIHZhciBpbmRleCA9IDBcbiAgICAgICAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB2YXIgZGF0YSA9IG9ialxuXG4gICAgICAgIHdoaWxlIChpbmRleCA8IGxlbiAtIDEpIHtcbiAgICAgICAgICB2YXIgcGFydCA9IHBhcnRzW2luZGV4XVxuICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIHBhcnQgPT09ICdfX3Byb3RvX18nIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAnY29uc3RydWN0b3InIHx8XG4gICAgICAgICAgICBwYXJ0ID09PSAncHJvdG90eXBlJ1xuICAgICAgICAgICkge1xuICAgICAgICAgICAgcmV0dXJuIG9ialxuICAgICAgICAgIH1cblxuICAgICAgICAgIGRhdGEgPSBkYXRhW3BhcnRzW2luZGV4KytdXVxuICAgICAgICB9XG4gICAgICAgIGRhdGFbcGFydHNbaW5kZXhdXSA9IHZhbHVlXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBnZXR0ZXI6IGZ1bmN0aW9uIChwYXRoLCBzYWZlKSB7XG4gICAgdmFyIHBhcnRzID0gbm9ybWFsaXplUGF0aChwYXRoKVxuICAgIHJldHVybiAoXG4gICAgICBnZXRDYWNoZS5nZXQocGF0aCkgfHxcbiAgICAgIGdldENhY2hlLnNldChwYXRoLCBmdW5jdGlvbiBnZXR0ZXIoZGF0YSkge1xuICAgICAgICB2YXIgaW5kZXggPSAwLFxuICAgICAgICAgIGxlbiA9IHBhcnRzLmxlbmd0aFxuICAgICAgICB3aGlsZSAoaW5kZXggPCBsZW4pIHtcbiAgICAgICAgICBpZiAoZGF0YSAhPSBudWxsIHx8ICFzYWZlKSBkYXRhID0gZGF0YVtwYXJ0c1tpbmRleCsrXV1cbiAgICAgICAgICBlbHNlIHJldHVyblxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBkYXRhXG4gICAgICB9KVxuICAgIClcbiAgfSxcblxuICBqb2luOiBmdW5jdGlvbiAoc2VnbWVudHMpIHtcbiAgICByZXR1cm4gc2VnbWVudHMucmVkdWNlKGZ1bmN0aW9uIChwYXRoLCBwYXJ0KSB7XG4gICAgICByZXR1cm4gKFxuICAgICAgICBwYXRoICtcbiAgICAgICAgKGlzUXVvdGVkKHBhcnQpIHx8IERJR0lUX1JFR0VYLnRlc3QocGFydClcbiAgICAgICAgICA/ICdbJyArIHBhcnQgKyAnXSdcbiAgICAgICAgICA6IChwYXRoID8gJy4nIDogJycpICsgcGFydClcbiAgICAgIClcbiAgICB9LCAnJylcbiAgfSxcblxuICBmb3JFYWNoOiBmdW5jdGlvbiAocGF0aCwgY2IsIHRoaXNBcmcpIHtcbiAgICBmb3JFYWNoKEFycmF5LmlzQXJyYXkocGF0aCkgPyBwYXRoIDogc3BsaXQocGF0aCksIGNiLCB0aGlzQXJnKVxuICB9LFxufVxuXG5mdW5jdGlvbiBub3JtYWxpemVQYXRoKHBhdGgpIHtcbiAgcmV0dXJuIChcbiAgICBwYXRoQ2FjaGUuZ2V0KHBhdGgpIHx8XG4gICAgcGF0aENhY2hlLnNldChcbiAgICAgIHBhdGgsXG4gICAgICBzcGxpdChwYXRoKS5tYXAoZnVuY3Rpb24gKHBhcnQpIHtcbiAgICAgICAgcmV0dXJuIHBhcnQucmVwbGFjZShDTEVBTl9RVU9URVNfUkVHRVgsICckMicpXG4gICAgICB9KVxuICAgIClcbiAgKVxufVxuXG5mdW5jdGlvbiBzcGxpdChwYXRoKSB7XG4gIHJldHVybiBwYXRoLm1hdGNoKFNQTElUX1JFR0VYKSB8fCBbJyddXG59XG5cbmZ1bmN0aW9uIGZvckVhY2gocGFydHMsIGl0ZXIsIHRoaXNBcmcpIHtcbiAgdmFyIGxlbiA9IHBhcnRzLmxlbmd0aCxcbiAgICBwYXJ0LFxuICAgIGlkeCxcbiAgICBpc0FycmF5LFxuICAgIGlzQnJhY2tldFxuXG4gIGZvciAoaWR4ID0gMDsgaWR4IDwgbGVuOyBpZHgrKykge1xuICAgIHBhcnQgPSBwYXJ0c1tpZHhdXG5cbiAgICBpZiAocGFydCkge1xuICAgICAgaWYgKHNob3VsZEJlUXVvdGVkKHBhcnQpKSB7XG4gICAgICAgIHBhcnQgPSAnXCInICsgcGFydCArICdcIidcbiAgICAgIH1cblxuICAgICAgaXNCcmFja2V0ID0gaXNRdW90ZWQocGFydClcbiAgICAgIGlzQXJyYXkgPSAhaXNCcmFja2V0ICYmIC9eXFxkKyQvLnRlc3QocGFydClcblxuICAgICAgaXRlci5jYWxsKHRoaXNBcmcsIHBhcnQsIGlzQnJhY2tldCwgaXNBcnJheSwgaWR4LCBwYXJ0cylcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNRdW90ZWQoc3RyKSB7XG4gIHJldHVybiAoXG4gICAgdHlwZW9mIHN0ciA9PT0gJ3N0cmluZycgJiYgc3RyICYmIFtcIidcIiwgJ1wiJ10uaW5kZXhPZihzdHIuY2hhckF0KDApKSAhPT0gLTFcbiAgKVxufVxuXG5mdW5jdGlvbiBoYXNMZWFkaW5nTnVtYmVyKHBhcnQpIHtcbiAgcmV0dXJuIHBhcnQubWF0Y2goTEVBRF9ESUdJVF9SRUdFWCkgJiYgIXBhcnQubWF0Y2goRElHSVRfUkVHRVgpXG59XG5cbmZ1bmN0aW9uIGhhc1NwZWNpYWxDaGFycyhwYXJ0KSB7XG4gIHJldHVybiBTUEVDX0NIQVJfUkVHRVgudGVzdChwYXJ0KVxufVxuXG5mdW5jdGlvbiBzaG91bGRCZVF1b3RlZChwYXJ0KSB7XG4gIHJldHVybiAhaXNRdW90ZWQocGFydCkgJiYgKGhhc0xlYWRpbmdOdW1iZXIocGFydCkgfHwgaGFzU3BlY2lhbENoYXJzKHBhcnQpKVxufVxuIl0sIm5hbWVzIjpbIkNhY2hlIiwibWF4U2l6ZSIsIl9tYXhTaXplIiwiY2xlYXIiLCJwcm90b3R5cGUiLCJfc2l6ZSIsIl92YWx1ZXMiLCJPYmplY3QiLCJjcmVhdGUiLCJnZXQiLCJrZXkiLCJzZXQiLCJ2YWx1ZSIsIlNQTElUX1JFR0VYIiwiRElHSVRfUkVHRVgiLCJMRUFEX0RJR0lUX1JFR0VYIiwiU1BFQ19DSEFSX1JFR0VYIiwiQ0xFQU5fUVVPVEVTX1JFR0VYIiwiTUFYX0NBQ0hFX1NJWkUiLCJwYXRoQ2FjaGUiLCJzZXRDYWNoZSIsImdldENhY2hlIiwiY29uZmlnIiwibW9kdWxlIiwiZXhwb3J0cyIsInNwbGl0Iiwibm9ybWFsaXplUGF0aCIsInNldHRlciIsInBhdGgiLCJwYXJ0cyIsIm9iaiIsImluZGV4IiwibGVuIiwibGVuZ3RoIiwiZGF0YSIsInBhcnQiLCJnZXR0ZXIiLCJzYWZlIiwiam9pbiIsInNlZ21lbnRzIiwicmVkdWNlIiwiaXNRdW90ZWQiLCJ0ZXN0IiwiZm9yRWFjaCIsImNiIiwidGhpc0FyZyIsIkFycmF5IiwiaXNBcnJheSIsIm1hcCIsInJlcGxhY2UiLCJtYXRjaCIsIml0ZXIiLCJpZHgiLCJpc0JyYWNrZXQiLCJzaG91bGRCZVF1b3RlZCIsImNhbGwiLCJzdHIiLCJpbmRleE9mIiwiY2hhckF0IiwiaGFzTGVhZGluZ051bWJlciIsImhhc1NwZWNpYWxDaGFycyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/property-expr/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/tiny-case/index.js":
/*!*****************************************!*\
  !*** ./node_modules/tiny-case/index.js ***!
  \*****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("\nconst reWords = /[A-Z\\xc0-\\xd6\\xd8-\\xde]?[a-z\\xdf-\\xf6\\xf8-\\xff]+(?:['’](?:d|ll|m|re|s|t|ve))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde]|$)|(?:[A-Z\\xc0-\\xd6\\xd8-\\xde]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:D|LL|M|RE|S|T|VE))?(?=[\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000]|[A-Z\\xc0-\\xd6\\xd8-\\xde](?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])|$)|[A-Z\\xc0-\\xd6\\xd8-\\xde]?(?:[a-z\\xdf-\\xf6\\xf8-\\xff]|[^\\ud800-\\udfff\\xac\\xb1\\xd7\\xf7\\x00-\\x2f\\x3a-\\x40\\x5b-\\x60\\x7b-\\xbf\\u2000-\\u206f \\t\\x0b\\f\\xa0\\ufeff\\n\\r\\u2028\\u2029\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u202f\\u205f\\u3000\\d+\\u2700-\\u27bfa-z\\xdf-\\xf6\\xf8-\\xffA-Z\\xc0-\\xd6\\xd8-\\xde])+(?:['’](?:d|ll|m|re|s|t|ve))?|[A-Z\\xc0-\\xd6\\xd8-\\xde]+(?:['’](?:D|LL|M|RE|S|T|VE))?|\\d*(?:1ST|2ND|3RD|(?![123])\\dTH)(?=\\b|[a-z_])|\\d*(?:1st|2nd|3rd|(?![123])\\dth)(?=\\b|[A-Z_])|\\d+|(?:[\\u2700-\\u27bf]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?(?:\\u200d(?:[^\\ud800-\\udfff]|(?:\\ud83c[\\udde6-\\uddff]){2}|[\\ud800-\\udbff][\\udc00-\\udfff])[\\ufe0e\\ufe0f]?(?:[\\u0300-\\u036f\\ufe20-\\ufe2f\\u20d0-\\u20ff]|\\ud83c[\\udffb-\\udfff])?)*/g;\nconst words = (str)=>str.match(reWords) || [];\nconst upperFirst = (str)=>str[0].toUpperCase() + str.slice(1);\nconst join = (str, d)=>words(str).join(d).toLowerCase();\nconst camelCase = (str)=>words(str).reduce((acc, next)=>\"\".concat(acc).concat(!acc ? next.toLowerCase() : next[0].toUpperCase() + next.slice(1).toLowerCase()), \"\");\nconst pascalCase = (str)=>upperFirst(camelCase(str));\nconst snakeCase = (str)=>join(str, \"_\");\nconst kebabCase = (str)=>join(str, \"-\");\nconst sentenceCase = (str)=>upperFirst(join(str, \" \"));\nconst titleCase = (str)=>words(str).map(upperFirst).join(\" \");\nmodule.exports = {\n    words,\n    upperFirst,\n    camelCase,\n    pascalCase,\n    snakeCase,\n    kebabCase,\n    sentenceCase,\n    titleCase\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90aW55LWNhc2UvaW5kZXguanMiLCJtYXBwaW5ncyI6IjtBQUFBLE1BQU1BLFVBQVU7QUFFaEIsTUFBTUMsUUFBUSxDQUFDQyxNQUFRQSxJQUFJQyxLQUFLLENBQUNILFlBQVksRUFBRTtBQUUvQyxNQUFNSSxhQUFhLENBQUNGLE1BQVFBLEdBQUcsQ0FBQyxFQUFFLENBQUNHLFdBQVcsS0FBS0gsSUFBSUksS0FBSyxDQUFDO0FBRTdELE1BQU1DLE9BQU8sQ0FBQ0wsS0FBS00sSUFBTVAsTUFBTUMsS0FBS0ssSUFBSSxDQUFDQyxHQUFHQyxXQUFXO0FBRXZELE1BQU1DLFlBQVksQ0FBQ1IsTUFDakJELE1BQU1DLEtBQUtTLE1BQU0sQ0FDZixDQUFDQyxLQUFLQyxPQUNKLEdBQ0UsT0FEQ0QsS0FJRixPQUhDLENBQUNBLE1BQ0dDLEtBQUtKLFdBQVcsS0FDaEJJLElBQUksQ0FBQyxFQUFFLENBQUNSLFdBQVcsS0FBS1EsS0FBS1AsS0FBSyxDQUFDLEdBQUdHLFdBQVcsS0FFekQ7QUFHSixNQUFNSyxhQUFhLENBQUNaLE1BQVFFLFdBQVdNLFVBQVVSO0FBRWpELE1BQU1hLFlBQVksQ0FBQ2IsTUFBUUssS0FBS0wsS0FBSztBQUVyQyxNQUFNYyxZQUFZLENBQUNkLE1BQVFLLEtBQUtMLEtBQUs7QUFFckMsTUFBTWUsZUFBZSxDQUFDZixNQUFRRSxXQUFXRyxLQUFLTCxLQUFLO0FBRW5ELE1BQU1nQixZQUFZLENBQUNoQixNQUFRRCxNQUFNQyxLQUFLaUIsR0FBRyxDQUFDZixZQUFZRyxJQUFJLENBQUM7QUFFM0RhLE9BQU9DLE9BQU8sR0FBRztJQUNmcEI7SUFDQUc7SUFDQU07SUFDQUk7SUFDQUM7SUFDQUM7SUFDQUM7SUFDQUM7QUFDRiIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvdGlueS1jYXNlL2luZGV4LmpzP2ZmODAiXSwic291cmNlc0NvbnRlbnQiOlsiY29uc3QgcmVXb3JkcyA9IC9bQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0/W2EtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdKyg/Olsn4oCZXSg/OmR8bGx8bXxyZXxzfHR8dmUpKT8oPz1bXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMF18W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdfCQpfCg/OltBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXXxbXlxcdWQ4MDAtXFx1ZGZmZlxceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXGQrXFx1MjcwMC1cXHUyN2JmYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKSsoPzpbJ+KAmV0oPzpEfExMfE18UkV8U3xUfFZFKSk/KD89W1xceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBdfFtBLVpcXHhjMC1cXHhkNlxceGQ4LVxceGRlXSg/OlthLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmXXxbXlxcdWQ4MDAtXFx1ZGZmZlxceGFjXFx4YjFcXHhkN1xceGY3XFx4MDAtXFx4MmZcXHgzYS1cXHg0MFxceDViLVxceDYwXFx4N2ItXFx4YmZcXHUyMDAwLVxcdTIwNmYgXFx0XFx4MGJcXGZcXHhhMFxcdWZlZmZcXG5cXHJcXHUyMDI4XFx1MjAyOVxcdTE2ODBcXHUxODBlXFx1MjAwMFxcdTIwMDFcXHUyMDAyXFx1MjAwM1xcdTIwMDRcXHUyMDA1XFx1MjAwNlxcdTIwMDdcXHUyMDA4XFx1MjAwOVxcdTIwMGFcXHUyMDJmXFx1MjA1ZlxcdTMwMDBcXGQrXFx1MjcwMC1cXHUyN2JmYS16XFx4ZGYtXFx4ZjZcXHhmOC1cXHhmZkEtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKXwkKXxbQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0/KD86W2EtelxceGRmLVxceGY2XFx4ZjgtXFx4ZmZdfFteXFx1ZDgwMC1cXHVkZmZmXFx4YWNcXHhiMVxceGQ3XFx4ZjdcXHgwMC1cXHgyZlxceDNhLVxceDQwXFx4NWItXFx4NjBcXHg3Yi1cXHhiZlxcdTIwMDAtXFx1MjA2ZiBcXHRcXHgwYlxcZlxceGEwXFx1ZmVmZlxcblxcclxcdTIwMjhcXHUyMDI5XFx1MTY4MFxcdTE4MGVcXHUyMDAwXFx1MjAwMVxcdTIwMDJcXHUyMDAzXFx1MjAwNFxcdTIwMDVcXHUyMDA2XFx1MjAwN1xcdTIwMDhcXHUyMDA5XFx1MjAwYVxcdTIwMmZcXHUyMDVmXFx1MzAwMFxcZCtcXHUyNzAwLVxcdTI3YmZhLXpcXHhkZi1cXHhmNlxceGY4LVxceGZmQS1aXFx4YzAtXFx4ZDZcXHhkOC1cXHhkZV0pKyg/Olsn4oCZXSg/OmR8bGx8bXxyZXxzfHR8dmUpKT98W0EtWlxceGMwLVxceGQ2XFx4ZDgtXFx4ZGVdKyg/Olsn4oCZXSg/OkR8TEx8TXxSRXxTfFR8VkUpKT98XFxkKig/OjFTVHwyTkR8M1JEfCg/IVsxMjNdKVxcZFRIKSg/PVxcYnxbYS16X10pfFxcZCooPzoxc3R8Mm5kfDNyZHwoPyFbMTIzXSlcXGR0aCkoPz1cXGJ8W0EtWl9dKXxcXGQrfCg/OltcXHUyNzAwLVxcdTI3YmZdfCg/OlxcdWQ4M2NbXFx1ZGRlNi1cXHVkZGZmXSl7Mn18W1xcdWQ4MDAtXFx1ZGJmZl1bXFx1ZGMwMC1cXHVkZmZmXSlbXFx1ZmUwZVxcdWZlMGZdPyg/OltcXHUwMzAwLVxcdTAzNmZcXHVmZTIwLVxcdWZlMmZcXHUyMGQwLVxcdTIwZmZdfFxcdWQ4M2NbXFx1ZGZmYi1cXHVkZmZmXSk/KD86XFx1MjAwZCg/OlteXFx1ZDgwMC1cXHVkZmZmXXwoPzpcXHVkODNjW1xcdWRkZTYtXFx1ZGRmZl0pezJ9fFtcXHVkODAwLVxcdWRiZmZdW1xcdWRjMDAtXFx1ZGZmZl0pW1xcdWZlMGVcXHVmZTBmXT8oPzpbXFx1MDMwMC1cXHUwMzZmXFx1ZmUyMC1cXHVmZTJmXFx1MjBkMC1cXHUyMGZmXXxcXHVkODNjW1xcdWRmZmItXFx1ZGZmZl0pPykqL2dcblxuY29uc3Qgd29yZHMgPSAoc3RyKSA9PiBzdHIubWF0Y2gocmVXb3JkcykgfHwgW11cblxuY29uc3QgdXBwZXJGaXJzdCA9IChzdHIpID0+IHN0clswXS50b1VwcGVyQ2FzZSgpICsgc3RyLnNsaWNlKDEpXG5cbmNvbnN0IGpvaW4gPSAoc3RyLCBkKSA9PiB3b3JkcyhzdHIpLmpvaW4oZCkudG9Mb3dlckNhc2UoKVxuXG5jb25zdCBjYW1lbENhc2UgPSAoc3RyKSA9PlxuICB3b3JkcyhzdHIpLnJlZHVjZShcbiAgICAoYWNjLCBuZXh0KSA9PlxuICAgICAgYCR7YWNjfSR7XG4gICAgICAgICFhY2NcbiAgICAgICAgICA/IG5leHQudG9Mb3dlckNhc2UoKVxuICAgICAgICAgIDogbmV4dFswXS50b1VwcGVyQ2FzZSgpICsgbmV4dC5zbGljZSgxKS50b0xvd2VyQ2FzZSgpXG4gICAgICB9YCxcbiAgICAnJyxcbiAgKVxuXG5jb25zdCBwYXNjYWxDYXNlID0gKHN0cikgPT4gdXBwZXJGaXJzdChjYW1lbENhc2Uoc3RyKSlcblxuY29uc3Qgc25ha2VDYXNlID0gKHN0cikgPT4gam9pbihzdHIsICdfJylcblxuY29uc3Qga2ViYWJDYXNlID0gKHN0cikgPT4gam9pbihzdHIsICctJylcblxuY29uc3Qgc2VudGVuY2VDYXNlID0gKHN0cikgPT4gdXBwZXJGaXJzdChqb2luKHN0ciwgJyAnKSlcblxuY29uc3QgdGl0bGVDYXNlID0gKHN0cikgPT4gd29yZHMoc3RyKS5tYXAodXBwZXJGaXJzdCkuam9pbignICcpXG5cbm1vZHVsZS5leHBvcnRzID0ge1xuICB3b3JkcyxcbiAgdXBwZXJGaXJzdCxcbiAgY2FtZWxDYXNlLFxuICBwYXNjYWxDYXNlLFxuICBzbmFrZUNhc2UsXG4gIGtlYmFiQ2FzZSxcbiAgc2VudGVuY2VDYXNlLFxuICB0aXRsZUNhc2UsXG59XG4iXSwibmFtZXMiOlsicmVXb3JkcyIsIndvcmRzIiwic3RyIiwibWF0Y2giLCJ1cHBlckZpcnN0IiwidG9VcHBlckNhc2UiLCJzbGljZSIsImpvaW4iLCJkIiwidG9Mb3dlckNhc2UiLCJjYW1lbENhc2UiLCJyZWR1Y2UiLCJhY2MiLCJuZXh0IiwicGFzY2FsQ2FzZSIsInNuYWtlQ2FzZSIsImtlYmFiQ2FzZSIsInNlbnRlbmNlQ2FzZSIsInRpdGxlQ2FzZSIsIm1hcCIsIm1vZHVsZSIsImV4cG9ydHMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/tiny-case/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/toposort/index.js":
/*!****************************************!*\
  !*** ./node_modules/toposort/index.js ***!
  \****************************************/
/***/ (function(module, __unused_webpack_exports, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("/**\n * Topological sorting function\n *\n * @param {Array} edges\n * @returns {Array}\n */ \nmodule.exports = function(edges) {\n    return toposort(uniqueNodes(edges), edges);\n};\nmodule.exports.array = toposort;\nfunction toposort(nodes, edges) {\n    var cursor = nodes.length, sorted = new Array(cursor), visited = {}, i = cursor, outgoingEdges = makeOutgoingEdges(edges), nodesHash = makeNodesHash(nodes);\n    // check for unknown nodes\n    edges.forEach(function(edge) {\n        if (!nodesHash.has(edge[0]) || !nodesHash.has(edge[1])) {\n            throw new Error(\"Unknown node. There is an unknown node in the supplied edges.\");\n        }\n    });\n    while(i--){\n        if (!visited[i]) visit(nodes[i], i, new Set());\n    }\n    return sorted;\n    function visit(node, i, predecessors) {\n        if (predecessors.has(node)) {\n            var nodeRep;\n            try {\n                nodeRep = \", node was:\" + JSON.stringify(node);\n            } catch (e) {\n                nodeRep = \"\";\n            }\n            throw new Error(\"Cyclic dependency\" + nodeRep);\n        }\n        if (!nodesHash.has(node)) {\n            throw new Error(\"Found unknown node. Make sure to provided all involved nodes. Unknown node: \" + JSON.stringify(node));\n        }\n        if (visited[i]) return;\n        visited[i] = true;\n        var outgoing = outgoingEdges.get(node) || new Set();\n        outgoing = Array.from(outgoing);\n        if (i = outgoing.length) {\n            predecessors.add(node);\n            do {\n                var child = outgoing[--i];\n                visit(child, nodesHash.get(child), predecessors);\n            }while (i);\n            predecessors.delete(node);\n        }\n        sorted[--cursor] = node;\n    }\n}\nfunction uniqueNodes(arr) {\n    var res = new Set();\n    for(var i = 0, len = arr.length; i < len; i++){\n        var edge = arr[i];\n        res.add(edge[0]);\n        res.add(edge[1]);\n    }\n    return Array.from(res);\n}\nfunction makeOutgoingEdges(arr) {\n    var edges = new Map();\n    for(var i = 0, len = arr.length; i < len; i++){\n        var edge = arr[i];\n        if (!edges.has(edge[0])) edges.set(edge[0], new Set());\n        if (!edges.has(edge[1])) edges.set(edge[1], new Set());\n        edges.get(edge[0]).add(edge[1]);\n    }\n    return edges;\n}\nfunction makeNodesHash(arr) {\n    var res = new Map();\n    for(var i = 0, len = arr.length; i < len; i++){\n        res.set(arr[i], i);\n    }\n    return res;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy90b3Bvc29ydC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiQUFDQTs7Ozs7Q0FLQztBQUVEQSxPQUFPQyxPQUFPLEdBQUcsU0FBU0MsS0FBSztJQUM3QixPQUFPQyxTQUFTQyxZQUFZRixRQUFRQTtBQUN0QztBQUVBRixvQkFBb0IsR0FBR0c7QUFFdkIsU0FBU0EsU0FBU0csS0FBSyxFQUFFSixLQUFLO0lBQzVCLElBQUlLLFNBQVNELE1BQU1FLE1BQU0sRUFDckJDLFNBQVMsSUFBSUMsTUFBTUgsU0FDbkJJLFVBQVUsQ0FBQyxHQUNYQyxJQUFJTCxRQUVKTSxnQkFBZ0JDLGtCQUFrQlosUUFDbENhLFlBQVlDLGNBQWNWO0lBRTlCLDBCQUEwQjtJQUMxQkosTUFBTWUsT0FBTyxDQUFDLFNBQVNDLElBQUk7UUFDekIsSUFBSSxDQUFDSCxVQUFVSSxHQUFHLENBQUNELElBQUksQ0FBQyxFQUFFLEtBQUssQ0FBQ0gsVUFBVUksR0FBRyxDQUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHO1lBQ3RELE1BQU0sSUFBSUUsTUFBTTtRQUNsQjtJQUNGO0lBRUEsTUFBT1IsSUFBSztRQUNWLElBQUksQ0FBQ0QsT0FBTyxDQUFDQyxFQUFFLEVBQUVTLE1BQU1mLEtBQUssQ0FBQ00sRUFBRSxFQUFFQSxHQUFHLElBQUlVO0lBQzFDO0lBRUEsT0FBT2I7SUFFUCxTQUFTWSxNQUFNRSxJQUFJLEVBQUVYLENBQUMsRUFBRVksWUFBWTtRQUNsQyxJQUFHQSxhQUFhTCxHQUFHLENBQUNJLE9BQU87WUFDekIsSUFBSUU7WUFDSixJQUFJO2dCQUNGQSxVQUFVLGdCQUFnQkMsS0FBS0MsU0FBUyxDQUFDSjtZQUMzQyxFQUFFLE9BQU1LLEdBQUc7Z0JBQ1RILFVBQVU7WUFDWjtZQUNBLE1BQU0sSUFBSUwsTUFBTSxzQkFBc0JLO1FBQ3hDO1FBRUEsSUFBSSxDQUFDVixVQUFVSSxHQUFHLENBQUNJLE9BQU87WUFDeEIsTUFBTSxJQUFJSCxNQUFNLGlGQUErRU0sS0FBS0MsU0FBUyxDQUFDSjtRQUNoSDtRQUVBLElBQUlaLE9BQU8sQ0FBQ0MsRUFBRSxFQUFFO1FBQ2hCRCxPQUFPLENBQUNDLEVBQUUsR0FBRztRQUViLElBQUlpQixXQUFXaEIsY0FBY2lCLEdBQUcsQ0FBQ1AsU0FBUyxJQUFJRDtRQUM5Q08sV0FBV25CLE1BQU1xQixJQUFJLENBQUNGO1FBRXRCLElBQUlqQixJQUFJaUIsU0FBU3JCLE1BQU0sRUFBRTtZQUN2QmdCLGFBQWFRLEdBQUcsQ0FBQ1Q7WUFDakIsR0FBRztnQkFDRCxJQUFJVSxRQUFRSixRQUFRLENBQUMsRUFBRWpCLEVBQUU7Z0JBQ3pCUyxNQUFNWSxPQUFPbEIsVUFBVWUsR0FBRyxDQUFDRyxRQUFRVDtZQUNyQyxRQUFTWixHQUFFO1lBQ1hZLGFBQWFVLE1BQU0sQ0FBQ1g7UUFDdEI7UUFFQWQsTUFBTSxDQUFDLEVBQUVGLE9BQU8sR0FBR2dCO0lBQ3JCO0FBQ0Y7QUFFQSxTQUFTbkIsWUFBWStCLEdBQUc7SUFDdEIsSUFBSUMsTUFBTSxJQUFJZDtJQUNkLElBQUssSUFBSVYsSUFBSSxHQUFHeUIsTUFBTUYsSUFBSTNCLE1BQU0sRUFBRUksSUFBSXlCLEtBQUt6QixJQUFLO1FBQzlDLElBQUlNLE9BQU9pQixHQUFHLENBQUN2QixFQUFFO1FBQ2pCd0IsSUFBSUosR0FBRyxDQUFDZCxJQUFJLENBQUMsRUFBRTtRQUNma0IsSUFBSUosR0FBRyxDQUFDZCxJQUFJLENBQUMsRUFBRTtJQUNqQjtJQUNBLE9BQU9SLE1BQU1xQixJQUFJLENBQUNLO0FBQ3BCO0FBRUEsU0FBU3RCLGtCQUFrQnFCLEdBQUc7SUFDNUIsSUFBSWpDLFFBQVEsSUFBSW9DO0lBQ2hCLElBQUssSUFBSTFCLElBQUksR0FBR3lCLE1BQU1GLElBQUkzQixNQUFNLEVBQUVJLElBQUl5QixLQUFLekIsSUFBSztRQUM5QyxJQUFJTSxPQUFPaUIsR0FBRyxDQUFDdkIsRUFBRTtRQUNqQixJQUFJLENBQUNWLE1BQU1pQixHQUFHLENBQUNELElBQUksQ0FBQyxFQUFFLEdBQUdoQixNQUFNcUMsR0FBRyxDQUFDckIsSUFBSSxDQUFDLEVBQUUsRUFBRSxJQUFJSTtRQUNoRCxJQUFJLENBQUNwQixNQUFNaUIsR0FBRyxDQUFDRCxJQUFJLENBQUMsRUFBRSxHQUFHaEIsTUFBTXFDLEdBQUcsQ0FBQ3JCLElBQUksQ0FBQyxFQUFFLEVBQUUsSUFBSUk7UUFDaERwQixNQUFNNEIsR0FBRyxDQUFDWixJQUFJLENBQUMsRUFBRSxFQUFFYyxHQUFHLENBQUNkLElBQUksQ0FBQyxFQUFFO0lBQ2hDO0lBQ0EsT0FBT2hCO0FBQ1Q7QUFFQSxTQUFTYyxjQUFjbUIsR0FBRztJQUN4QixJQUFJQyxNQUFNLElBQUlFO0lBQ2QsSUFBSyxJQUFJMUIsSUFBSSxHQUFHeUIsTUFBTUYsSUFBSTNCLE1BQU0sRUFBRUksSUFBSXlCLEtBQUt6QixJQUFLO1FBQzlDd0IsSUFBSUcsR0FBRyxDQUFDSixHQUFHLENBQUN2QixFQUFFLEVBQUVBO0lBQ2xCO0lBQ0EsT0FBT3dCO0FBQ1QiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3RvcG9zb3J0L2luZGV4LmpzP2YxYTYiXSwic291cmNlc0NvbnRlbnQiOlsiXG4vKipcbiAqIFRvcG9sb2dpY2FsIHNvcnRpbmcgZnVuY3Rpb25cbiAqXG4gKiBAcGFyYW0ge0FycmF5fSBlZGdlc1xuICogQHJldHVybnMge0FycmF5fVxuICovXG5cbm1vZHVsZS5leHBvcnRzID0gZnVuY3Rpb24oZWRnZXMpIHtcbiAgcmV0dXJuIHRvcG9zb3J0KHVuaXF1ZU5vZGVzKGVkZ2VzKSwgZWRnZXMpXG59XG5cbm1vZHVsZS5leHBvcnRzLmFycmF5ID0gdG9wb3NvcnRcblxuZnVuY3Rpb24gdG9wb3NvcnQobm9kZXMsIGVkZ2VzKSB7XG4gIHZhciBjdXJzb3IgPSBub2Rlcy5sZW5ndGhcbiAgICAsIHNvcnRlZCA9IG5ldyBBcnJheShjdXJzb3IpXG4gICAgLCB2aXNpdGVkID0ge31cbiAgICAsIGkgPSBjdXJzb3JcbiAgICAvLyBCZXR0ZXIgZGF0YSBzdHJ1Y3R1cmVzIG1ha2UgYWxnb3JpdGhtIG11Y2ggZmFzdGVyLlxuICAgICwgb3V0Z29pbmdFZGdlcyA9IG1ha2VPdXRnb2luZ0VkZ2VzKGVkZ2VzKVxuICAgICwgbm9kZXNIYXNoID0gbWFrZU5vZGVzSGFzaChub2RlcylcblxuICAvLyBjaGVjayBmb3IgdW5rbm93biBub2Rlc1xuICBlZGdlcy5mb3JFYWNoKGZ1bmN0aW9uKGVkZ2UpIHtcbiAgICBpZiAoIW5vZGVzSGFzaC5oYXMoZWRnZVswXSkgfHwgIW5vZGVzSGFzaC5oYXMoZWRnZVsxXSkpIHtcbiAgICAgIHRocm93IG5ldyBFcnJvcignVW5rbm93biBub2RlLiBUaGVyZSBpcyBhbiB1bmtub3duIG5vZGUgaW4gdGhlIHN1cHBsaWVkIGVkZ2VzLicpXG4gICAgfVxuICB9KVxuXG4gIHdoaWxlIChpLS0pIHtcbiAgICBpZiAoIXZpc2l0ZWRbaV0pIHZpc2l0KG5vZGVzW2ldLCBpLCBuZXcgU2V0KCkpXG4gIH1cblxuICByZXR1cm4gc29ydGVkXG5cbiAgZnVuY3Rpb24gdmlzaXQobm9kZSwgaSwgcHJlZGVjZXNzb3JzKSB7XG4gICAgaWYocHJlZGVjZXNzb3JzLmhhcyhub2RlKSkge1xuICAgICAgdmFyIG5vZGVSZXBcbiAgICAgIHRyeSB7XG4gICAgICAgIG5vZGVSZXAgPSBcIiwgbm9kZSB3YXM6XCIgKyBKU09OLnN0cmluZ2lmeShub2RlKVxuICAgICAgfSBjYXRjaChlKSB7XG4gICAgICAgIG5vZGVSZXAgPSBcIlwiXG4gICAgICB9XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0N5Y2xpYyBkZXBlbmRlbmN5JyArIG5vZGVSZXApXG4gICAgfVxuXG4gICAgaWYgKCFub2Rlc0hhc2guaGFzKG5vZGUpKSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZvdW5kIHVua25vd24gbm9kZS4gTWFrZSBzdXJlIHRvIHByb3ZpZGVkIGFsbCBpbnZvbHZlZCBub2Rlcy4gVW5rbm93biBub2RlOiAnK0pTT04uc3RyaW5naWZ5KG5vZGUpKVxuICAgIH1cblxuICAgIGlmICh2aXNpdGVkW2ldKSByZXR1cm47XG4gICAgdmlzaXRlZFtpXSA9IHRydWVcblxuICAgIHZhciBvdXRnb2luZyA9IG91dGdvaW5nRWRnZXMuZ2V0KG5vZGUpIHx8IG5ldyBTZXQoKVxuICAgIG91dGdvaW5nID0gQXJyYXkuZnJvbShvdXRnb2luZylcblxuICAgIGlmIChpID0gb3V0Z29pbmcubGVuZ3RoKSB7XG4gICAgICBwcmVkZWNlc3NvcnMuYWRkKG5vZGUpXG4gICAgICBkbyB7XG4gICAgICAgIHZhciBjaGlsZCA9IG91dGdvaW5nWy0taV1cbiAgICAgICAgdmlzaXQoY2hpbGQsIG5vZGVzSGFzaC5nZXQoY2hpbGQpLCBwcmVkZWNlc3NvcnMpXG4gICAgICB9IHdoaWxlIChpKVxuICAgICAgcHJlZGVjZXNzb3JzLmRlbGV0ZShub2RlKVxuICAgIH1cblxuICAgIHNvcnRlZFstLWN1cnNvcl0gPSBub2RlXG4gIH1cbn1cblxuZnVuY3Rpb24gdW5pcXVlTm9kZXMoYXJyKXtcbiAgdmFyIHJlcyA9IG5ldyBTZXQoKVxuICBmb3IgKHZhciBpID0gMCwgbGVuID0gYXJyLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgdmFyIGVkZ2UgPSBhcnJbaV1cbiAgICByZXMuYWRkKGVkZ2VbMF0pXG4gICAgcmVzLmFkZChlZGdlWzFdKVxuICB9XG4gIHJldHVybiBBcnJheS5mcm9tKHJlcylcbn1cblxuZnVuY3Rpb24gbWFrZU91dGdvaW5nRWRnZXMoYXJyKXtcbiAgdmFyIGVkZ2VzID0gbmV3IE1hcCgpXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICB2YXIgZWRnZSA9IGFycltpXVxuICAgIGlmICghZWRnZXMuaGFzKGVkZ2VbMF0pKSBlZGdlcy5zZXQoZWRnZVswXSwgbmV3IFNldCgpKVxuICAgIGlmICghZWRnZXMuaGFzKGVkZ2VbMV0pKSBlZGdlcy5zZXQoZWRnZVsxXSwgbmV3IFNldCgpKVxuICAgIGVkZ2VzLmdldChlZGdlWzBdKS5hZGQoZWRnZVsxXSlcbiAgfVxuICByZXR1cm4gZWRnZXNcbn1cblxuZnVuY3Rpb24gbWFrZU5vZGVzSGFzaChhcnIpe1xuICB2YXIgcmVzID0gbmV3IE1hcCgpXG4gIGZvciAodmFyIGkgPSAwLCBsZW4gPSBhcnIubGVuZ3RoOyBpIDwgbGVuOyBpKyspIHtcbiAgICByZXMuc2V0KGFycltpXSwgaSlcbiAgfVxuICByZXR1cm4gcmVzXG59XG4iXSwibmFtZXMiOlsibW9kdWxlIiwiZXhwb3J0cyIsImVkZ2VzIiwidG9wb3NvcnQiLCJ1bmlxdWVOb2RlcyIsImFycmF5Iiwibm9kZXMiLCJjdXJzb3IiLCJsZW5ndGgiLCJzb3J0ZWQiLCJBcnJheSIsInZpc2l0ZWQiLCJpIiwib3V0Z29pbmdFZGdlcyIsIm1ha2VPdXRnb2luZ0VkZ2VzIiwibm9kZXNIYXNoIiwibWFrZU5vZGVzSGFzaCIsImZvckVhY2giLCJlZGdlIiwiaGFzIiwiRXJyb3IiLCJ2aXNpdCIsIlNldCIsIm5vZGUiLCJwcmVkZWNlc3NvcnMiLCJub2RlUmVwIiwiSlNPTiIsInN0cmluZ2lmeSIsImUiLCJvdXRnb2luZyIsImdldCIsImZyb20iLCJhZGQiLCJjaGlsZCIsImRlbGV0ZSIsImFyciIsInJlcyIsImxlbiIsIk1hcCIsInNldCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/toposort/index.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/yup/index.esm.js":
/*!***************************************!*\
  !*** ./node_modules/yup/index.esm.js ***!
  \***************************************/
/***/ (function(__unused_webpack_module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ArraySchema: function() { return /* binding */ ArraySchema; },\n/* harmony export */   BooleanSchema: function() { return /* binding */ BooleanSchema; },\n/* harmony export */   DateSchema: function() { return /* binding */ DateSchema; },\n/* harmony export */   LazySchema: function() { return /* binding */ Lazy; },\n/* harmony export */   MixedSchema: function() { return /* binding */ MixedSchema; },\n/* harmony export */   NumberSchema: function() { return /* binding */ NumberSchema; },\n/* harmony export */   ObjectSchema: function() { return /* binding */ ObjectSchema; },\n/* harmony export */   Schema: function() { return /* binding */ Schema; },\n/* harmony export */   StringSchema: function() { return /* binding */ StringSchema; },\n/* harmony export */   TupleSchema: function() { return /* binding */ TupleSchema; },\n/* harmony export */   ValidationError: function() { return /* binding */ ValidationError; },\n/* harmony export */   addMethod: function() { return /* binding */ addMethod; },\n/* harmony export */   array: function() { return /* binding */ create$2; },\n/* harmony export */   bool: function() { return /* binding */ create$7; },\n/* harmony export */   boolean: function() { return /* binding */ create$7; },\n/* harmony export */   date: function() { return /* binding */ create$4; },\n/* harmony export */   defaultLocale: function() { return /* binding */ locale; },\n/* harmony export */   getIn: function() { return /* binding */ getIn; },\n/* harmony export */   isSchema: function() { return /* binding */ isSchema; },\n/* harmony export */   lazy: function() { return /* binding */ create; },\n/* harmony export */   mixed: function() { return /* binding */ create$8; },\n/* harmony export */   number: function() { return /* binding */ create$5; },\n/* harmony export */   object: function() { return /* binding */ create$3; },\n/* harmony export */   printValue: function() { return /* binding */ printValue; },\n/* harmony export */   reach: function() { return /* binding */ reach; },\n/* harmony export */   ref: function() { return /* binding */ create$9; },\n/* harmony export */   setLocale: function() { return /* binding */ setLocale; },\n/* harmony export */   string: function() { return /* binding */ create$6; },\n/* harmony export */   tuple: function() { return /* binding */ create$1; }\n/* harmony export */ });\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! property-expr */ \"(app-pages-browser)/./node_modules/property-expr/index.js\");\n/* harmony import */ var property_expr__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(property_expr__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! tiny-case */ \"(app-pages-browser)/./node_modules/tiny-case/index.js\");\n/* harmony import */ var tiny_case__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(tiny_case__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! toposort */ \"(app-pages-browser)/./node_modules/toposort/index.js\");\n/* harmony import */ var toposort__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(toposort__WEBPACK_IMPORTED_MODULE_2__);\n\n\n\nconst toString = Object.prototype.toString;\nconst errorToString = Error.prototype.toString;\nconst regExpToString = RegExp.prototype.toString;\nconst symbolToString = typeof Symbol !== \"undefined\" ? Symbol.prototype.toString : ()=>\"\";\nconst SYMBOL_REGEXP = /^Symbol\\((.*)\\)(.*)$/;\nfunction printNumber(val) {\n    if (val != +val) return \"NaN\";\n    const isNegativeZero = val === 0 && 1 / val < 0;\n    return isNegativeZero ? \"-0\" : \"\" + val;\n}\nfunction printSimpleValue(val) {\n    let quoteStrings = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : false;\n    if (val == null || val === true || val === false) return \"\" + val;\n    const typeOf = typeof val;\n    if (typeOf === \"number\") return printNumber(val);\n    if (typeOf === \"string\") return quoteStrings ? '\"'.concat(val, '\"') : val;\n    if (typeOf === \"function\") return \"[Function \" + (val.name || \"anonymous\") + \"]\";\n    if (typeOf === \"symbol\") return symbolToString.call(val).replace(SYMBOL_REGEXP, \"Symbol($1)\");\n    const tag = toString.call(val).slice(8, -1);\n    if (tag === \"Date\") return isNaN(val.getTime()) ? \"\" + val : val.toISOString(val);\n    if (tag === \"Error\" || val instanceof Error) return \"[\" + errorToString.call(val) + \"]\";\n    if (tag === \"RegExp\") return regExpToString.call(val);\n    return null;\n}\nfunction printValue(value, quoteStrings) {\n    let result = printSimpleValue(value, quoteStrings);\n    if (result !== null) return result;\n    return JSON.stringify(value, function(key, value) {\n        let result = printSimpleValue(this[key], quoteStrings);\n        if (result !== null) return result;\n        return value;\n    }, 2);\n}\nfunction toArray(value) {\n    return value == null ? [] : [].concat(value);\n}\nlet _Symbol$toStringTag, _Symbol$hasInstance, _Symbol$toStringTag2;\nlet strReg = /\\$\\{\\s*(\\w+)\\s*\\}/g;\n_Symbol$toStringTag = Symbol.toStringTag;\nclass ValidationErrorNoStack {\n    constructor(errorOrErrors, value, field, type){\n        this.name = void 0;\n        this.message = void 0;\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = void 0;\n        this.inner = void 0;\n        this[_Symbol$toStringTag] = \"Error\";\n        this.name = \"ValidationError\";\n        this.value = value;\n        this.path = field;\n        this.type = type;\n        this.errors = [];\n        this.inner = [];\n        toArray(errorOrErrors).forEach((err)=>{\n            if (ValidationError.isError(err)) {\n                this.errors.push(...err.errors);\n                const innerErrors = err.inner.length ? err.inner : [\n                    err\n                ];\n                this.inner.push(...innerErrors);\n            } else {\n                this.errors.push(err);\n            }\n        });\n        this.message = this.errors.length > 1 ? \"\".concat(this.errors.length, \" errors occurred\") : this.errors[0];\n    }\n}\n_Symbol$hasInstance = Symbol.hasInstance;\n_Symbol$toStringTag2 = Symbol.toStringTag;\nclass ValidationError extends Error {\n    static formatError(message, params) {\n        // Attempt to make the path more friendly for error message interpolation.\n        const path = params.label || params.path || \"this\";\n        // Store the original path under `originalPath` so it isn't lost to custom\n        // message functions; e.g., ones provided in `setLocale()` calls.\n        params = Object.assign({}, params, {\n            path,\n            originalPath: params.path\n        });\n        if (typeof message === \"string\") return message.replace(strReg, (_, key)=>printValue(params[key]));\n        if (typeof message === \"function\") return message(params);\n        return message;\n    }\n    static isError(err) {\n        return err && err.name === \"ValidationError\";\n    }\n    static [_Symbol$hasInstance](inst) {\n        return ValidationErrorNoStack[Symbol.hasInstance](inst) || super[Symbol.hasInstance](inst);\n    }\n    constructor(errorOrErrors, value, field, type, disableStack){\n        const errorNoStack = new ValidationErrorNoStack(errorOrErrors, value, field, type);\n        if (disableStack) {\n            return errorNoStack;\n        }\n        super();\n        this.value = void 0;\n        this.path = void 0;\n        this.type = void 0;\n        this.params = void 0;\n        this.errors = [];\n        this.inner = [];\n        this[_Symbol$toStringTag2] = \"Error\";\n        this.name = errorNoStack.name;\n        this.message = errorNoStack.message;\n        this.type = errorNoStack.type;\n        this.value = errorNoStack.value;\n        this.path = errorNoStack.path;\n        this.errors = errorNoStack.errors;\n        this.inner = errorNoStack.inner;\n        if (Error.captureStackTrace) {\n            Error.captureStackTrace(this, ValidationError);\n        }\n    }\n}\nlet mixed = {\n    default: \"${path} is invalid\",\n    required: \"${path} is a required field\",\n    defined: \"${path} must be defined\",\n    notNull: \"${path} cannot be null\",\n    oneOf: \"${path} must be one of the following values: ${values}\",\n    notOneOf: \"${path} must not be one of the following values: ${values}\",\n    notType: (param)=>{\n        let { path, type, value, originalValue } = param;\n        const castMsg = originalValue != null && originalValue !== value ? \" (cast from the value `\".concat(printValue(originalValue, true), \"`).\") : \".\";\n        return type !== \"mixed\" ? \"\".concat(path, \" must be a `\").concat(type, \"` type, \") + \"but the final value was: `\".concat(printValue(value, true), \"`\") + castMsg : \"\".concat(path, \" must match the configured type. \") + \"The validated value was: `\".concat(printValue(value, true), \"`\") + castMsg;\n    }\n};\nlet string = {\n    length: \"${path} must be exactly ${length} characters\",\n    min: \"${path} must be at least ${min} characters\",\n    max: \"${path} must be at most ${max} characters\",\n    matches: '${path} must match the following: \"${regex}\"',\n    email: \"${path} must be a valid email\",\n    url: \"${path} must be a valid URL\",\n    uuid: \"${path} must be a valid UUID\",\n    datetime: \"${path} must be a valid ISO date-time\",\n    datetime_precision: \"${path} must be a valid ISO date-time with a sub-second precision of exactly ${precision} digits\",\n    datetime_offset: '${path} must be a valid ISO date-time with UTC \"Z\" timezone',\n    trim: \"${path} must be a trimmed string\",\n    lowercase: \"${path} must be a lowercase string\",\n    uppercase: \"${path} must be a upper case string\"\n};\nlet number = {\n    min: \"${path} must be greater than or equal to ${min}\",\n    max: \"${path} must be less than or equal to ${max}\",\n    lessThan: \"${path} must be less than ${less}\",\n    moreThan: \"${path} must be greater than ${more}\",\n    positive: \"${path} must be a positive number\",\n    negative: \"${path} must be a negative number\",\n    integer: \"${path} must be an integer\"\n};\nlet date = {\n    min: \"${path} field must be later than ${min}\",\n    max: \"${path} field must be at earlier than ${max}\"\n};\nlet boolean = {\n    isValue: \"${path} field must be ${value}\"\n};\nlet object = {\n    noUnknown: \"${path} field has unspecified keys: ${unknown}\",\n    exact: \"${path} object contains unknown properties: ${properties}\"\n};\nlet array = {\n    min: \"${path} field must have at least ${min} items\",\n    max: \"${path} field must have less than or equal to ${max} items\",\n    length: \"${path} must have ${length} items\"\n};\nlet tuple = {\n    notType: (params)=>{\n        const { path, value, spec } = params;\n        const typeLen = spec.types.length;\n        if (Array.isArray(value)) {\n            if (value.length < typeLen) return \"\".concat(path, \" tuple value has too few items, expected a length of \").concat(typeLen, \" but got \").concat(value.length, \" for value: `\").concat(printValue(value, true), \"`\");\n            if (value.length > typeLen) return \"\".concat(path, \" tuple value has too many items, expected a length of \").concat(typeLen, \" but got \").concat(value.length, \" for value: `\").concat(printValue(value, true), \"`\");\n        }\n        return ValidationError.formatError(mixed.notType, params);\n    }\n};\nvar locale = Object.assign(Object.create(null), {\n    mixed,\n    string,\n    number,\n    date,\n    object,\n    array,\n    boolean,\n    tuple\n});\nconst isSchema = (obj)=>obj && obj.__isYupSchema__;\nclass Condition {\n    static fromOptions(refs, config) {\n        if (!config.then && !config.otherwise) throw new TypeError(\"either `then:` or `otherwise:` is required for `when()` conditions\");\n        let { is, then, otherwise } = config;\n        let check = typeof is === \"function\" ? is : function() {\n            for(var _len = arguments.length, values = new Array(_len), _key = 0; _key < _len; _key++){\n                values[_key] = arguments[_key];\n            }\n            return values.every((value)=>value === is);\n        };\n        return new Condition(refs, (values, schema)=>{\n            var _branch;\n            let branch = check(...values) ? then : otherwise;\n            return (_branch = branch == null ? void 0 : branch(schema)) != null ? _branch : schema;\n        });\n    }\n    resolve(base, options) {\n        let values = this.refs.map((ref)=>// TODO: ? operator here?\n            ref.getValue(options == null ? void 0 : options.value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context));\n        let schema = this.fn(values, base, options);\n        if (schema === undefined || // @ts-ignore this can be base\n        schema === base) {\n            return base;\n        }\n        if (!isSchema(schema)) throw new TypeError(\"conditions must return a schema object\");\n        return schema.resolve(options);\n    }\n    constructor(refs, builder){\n        this.fn = void 0;\n        this.refs = refs;\n        this.refs = refs;\n        this.fn = builder;\n    }\n}\nconst prefixes = {\n    context: \"$\",\n    value: \".\"\n};\nfunction create$9(key, options) {\n    return new Reference(key, options);\n}\nclass Reference {\n    getValue(value, parent, context) {\n        let result = this.isContext ? context : this.isValue ? value : parent;\n        if (this.getter) result = this.getter(result || {});\n        if (this.map) result = this.map(result);\n        return result;\n    }\n    /**\n   *\n   * @param {*} value\n   * @param {Object} options\n   * @param {Object=} options.context\n   * @param {Object=} options.parent\n   */ cast(value, options) {\n        return this.getValue(value, options == null ? void 0 : options.parent, options == null ? void 0 : options.context);\n    }\n    resolve() {\n        return this;\n    }\n    describe() {\n        return {\n            type: \"ref\",\n            key: this.key\n        };\n    }\n    toString() {\n        return \"Ref(\".concat(this.key, \")\");\n    }\n    static isRef(value) {\n        return value && value.__isYupRef;\n    }\n    constructor(key, options = {}){\n        this.key = void 0;\n        this.isContext = void 0;\n        this.isValue = void 0;\n        this.isSibling = void 0;\n        this.path = void 0;\n        this.getter = void 0;\n        this.map = void 0;\n        if (typeof key !== \"string\") throw new TypeError(\"ref must be a string, got: \" + key);\n        this.key = key.trim();\n        if (key === \"\") throw new TypeError(\"ref must be a non-empty string\");\n        this.isContext = this.key[0] === prefixes.context;\n        this.isValue = this.key[0] === prefixes.value;\n        this.isSibling = !this.isContext && !this.isValue;\n        let prefix = this.isContext ? prefixes.context : this.isValue ? prefixes.value : \"\";\n        this.path = this.key.slice(prefix.length);\n        this.getter = this.path && (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(this.path, true);\n        this.map = options.map;\n    }\n}\n// @ts-ignore\nReference.prototype.__isYupRef = true;\nconst isAbsent = (value)=>value == null;\nfunction createValidation(config) {\n    function validate(param, panic, next) {\n        let { value, path = \"\", options, originalValue, schema } = param;\n        const { name, test, params, message, skipAbsent } = config;\n        let { parent, context, abortEarly = schema.spec.abortEarly, disableStackTrace = schema.spec.disableStackTrace } = options;\n        function resolve(item) {\n            return Reference.isRef(item) ? item.getValue(value, parent, context) : item;\n        }\n        function createError() {\n            let overrides = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n            const nextParams = Object.assign({\n                value,\n                originalValue,\n                label: schema.spec.label,\n                path: overrides.path || path,\n                spec: schema.spec,\n                disableStackTrace: overrides.disableStackTrace || disableStackTrace\n            }, params, overrides.params);\n            for (const key of Object.keys(nextParams))nextParams[key] = resolve(nextParams[key]);\n            const error = new ValidationError(ValidationError.formatError(overrides.message || message, nextParams), value, nextParams.path, overrides.type || name, nextParams.disableStackTrace);\n            error.params = nextParams;\n            return error;\n        }\n        const invalid = abortEarly ? panic : next;\n        let ctx = {\n            path,\n            parent,\n            type: name,\n            from: options.from,\n            createError,\n            resolve,\n            options,\n            originalValue,\n            schema\n        };\n        const handleResult = (validOrError)=>{\n            if (ValidationError.isError(validOrError)) invalid(validOrError);\n            else if (!validOrError) invalid(createError());\n            else next(null);\n        };\n        const handleError = (err)=>{\n            if (ValidationError.isError(err)) invalid(err);\n            else panic(err);\n        };\n        const shouldSkip = skipAbsent && isAbsent(value);\n        if (shouldSkip) {\n            return handleResult(true);\n        }\n        let result;\n        try {\n            var _result;\n            result = test.call(ctx, value, ctx);\n            if (typeof ((_result = result) == null ? void 0 : _result.then) === \"function\") {\n                if (options.sync) {\n                    throw new Error('Validation test of type: \"'.concat(ctx.type, '\" returned a Promise during a synchronous validate. ') + \"This test will finish after the validate call has returned\");\n                }\n                return Promise.resolve(result).then(handleResult, handleError);\n            }\n        } catch (err) {\n            handleError(err);\n            return;\n        }\n        handleResult(result);\n    }\n    validate.OPTIONS = config;\n    return validate;\n}\nfunction getIn(schema, path, value) {\n    let context = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : value;\n    let parent, lastPart, lastPartDebug;\n    // root path: ''\n    if (!path) return {\n        parent,\n        parentPath: path,\n        schema\n    };\n    (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.forEach)(path, (_part, isBracket, isArray)=>{\n        let part = isBracket ? _part.slice(1, _part.length - 1) : _part;\n        schema = schema.resolve({\n            context,\n            parent,\n            value\n        });\n        let isTuple = schema.type === \"tuple\";\n        let idx = isArray ? parseInt(part, 10) : 0;\n        if (schema.innerType || isTuple) {\n            if (isTuple && !isArray) throw new Error('Yup.reach cannot implicitly index into a tuple type. the path part \"'.concat(lastPartDebug, '\" must contain an index to the tuple element, e.g. \"').concat(lastPartDebug, '[0]\"'));\n            if (value && idx >= value.length) {\n                throw new Error(\"Yup.reach cannot resolve an array item at index: \".concat(_part, \", in the path: \").concat(path, \". \") + \"because there is no value at that index. \");\n            }\n            parent = value;\n            value = value && value[idx];\n            schema = isTuple ? schema.spec.types[idx] : schema.innerType;\n        }\n        // sometimes the array index part of a path doesn't exist: \"nested.arr.child\"\n        // in these cases the current part is the next schema and should be processed\n        // in this iteration. For cases where the index signature is included this\n        // check will fail and we'll handle the `child` part on the next iteration like normal\n        if (!isArray) {\n            if (!schema.fields || !schema.fields[part]) throw new Error(\"The schema does not contain the path: \".concat(path, \". \") + \"(failed at: \".concat(lastPartDebug, ' which is a type: \"').concat(schema.type, '\")'));\n            parent = value;\n            value = value && value[part];\n            schema = schema.fields[part];\n        }\n        lastPart = part;\n        lastPartDebug = isBracket ? \"[\" + _part + \"]\" : \".\" + _part;\n    });\n    return {\n        schema,\n        parent,\n        parentPath: lastPart\n    };\n}\nfunction reach(obj, path, value, context) {\n    return getIn(obj, path, value, context).schema;\n}\nclass ReferenceSet extends Set {\n    describe() {\n        const description = [];\n        for (const item of this.values()){\n            description.push(Reference.isRef(item) ? item.describe() : item);\n        }\n        return description;\n    }\n    resolveAll(resolve) {\n        let result = [];\n        for (const item of this.values()){\n            result.push(resolve(item));\n        }\n        return result;\n    }\n    clone() {\n        return new ReferenceSet(this.values());\n    }\n    merge(newItems, removeItems) {\n        const next = this.clone();\n        newItems.forEach((value)=>next.add(value));\n        removeItems.forEach((value)=>next.delete(value));\n        return next;\n    }\n}\n// tweaked from https://github.com/Kelin2025/nanoclone/blob/0abeb7635bda9b68ef2277093f76dbe3bf3948e1/src/index.js\nfunction clone(src) {\n    let seen = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : new Map();\n    if (isSchema(src) || !src || typeof src !== \"object\") return src;\n    if (seen.has(src)) return seen.get(src);\n    let copy;\n    if (src instanceof Date) {\n        // Date\n        copy = new Date(src.getTime());\n        seen.set(src, copy);\n    } else if (src instanceof RegExp) {\n        // RegExp\n        copy = new RegExp(src);\n        seen.set(src, copy);\n    } else if (Array.isArray(src)) {\n        // Array\n        copy = new Array(src.length);\n        seen.set(src, copy);\n        for(let i = 0; i < src.length; i++)copy[i] = clone(src[i], seen);\n    } else if (src instanceof Map) {\n        // Map\n        copy = new Map();\n        seen.set(src, copy);\n        for (const [k, v] of src.entries())copy.set(k, clone(v, seen));\n    } else if (src instanceof Set) {\n        // Set\n        copy = new Set();\n        seen.set(src, copy);\n        for (const v of src)copy.add(clone(v, seen));\n    } else if (src instanceof Object) {\n        // Object\n        copy = {};\n        seen.set(src, copy);\n        for (const [k, v] of Object.entries(src))copy[k] = clone(v, seen);\n    } else {\n        throw Error(\"Unable to clone \".concat(src));\n    }\n    return copy;\n}\n// If `CustomSchemaMeta` isn't extended with any keys, we'll fall back to a\n// loose Record definition allowing free form usage.\nclass Schema {\n    // TODO: remove\n    get _type() {\n        return this.type;\n    }\n    clone(spec) {\n        if (this._mutate) {\n            if (spec) Object.assign(this.spec, spec);\n            return this;\n        }\n        // if the nested value is a schema we can skip cloning, since\n        // they are already immutable\n        const next = Object.create(Object.getPrototypeOf(this));\n        // @ts-expect-error this is readonly\n        next.type = this.type;\n        next._typeCheck = this._typeCheck;\n        next._whitelist = this._whitelist.clone();\n        next._blacklist = this._blacklist.clone();\n        next.internalTests = Object.assign({}, this.internalTests);\n        next.exclusiveTests = Object.assign({}, this.exclusiveTests);\n        // @ts-expect-error this is readonly\n        next.deps = [\n            ...this.deps\n        ];\n        next.conditions = [\n            ...this.conditions\n        ];\n        next.tests = [\n            ...this.tests\n        ];\n        next.transforms = [\n            ...this.transforms\n        ];\n        next.spec = clone(Object.assign({}, this.spec, spec));\n        return next;\n    }\n    label(label) {\n        let next = this.clone();\n        next.spec.label = label;\n        return next;\n    }\n    meta() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    withMutation(fn) {\n        let before = this._mutate;\n        this._mutate = true;\n        let result = fn(this);\n        this._mutate = before;\n        return result;\n    }\n    concat(schema) {\n        if (!schema || schema === this) return this;\n        if (schema.type !== this.type && this.type !== \"mixed\") throw new TypeError(\"You cannot `concat()` schema's of different types: \".concat(this.type, \" and \").concat(schema.type));\n        let base = this;\n        let combined = schema.clone();\n        const mergedSpec = Object.assign({}, base.spec, combined.spec);\n        combined.spec = mergedSpec;\n        combined.internalTests = Object.assign({}, base.internalTests, combined.internalTests);\n        // manually merge the blacklist/whitelist (the other `schema` takes\n        // precedence in case of conflicts)\n        combined._whitelist = base._whitelist.merge(schema._whitelist, schema._blacklist);\n        combined._blacklist = base._blacklist.merge(schema._blacklist, schema._whitelist);\n        // start with the current tests\n        combined.tests = base.tests;\n        combined.exclusiveTests = base.exclusiveTests;\n        // manually add the new tests to ensure\n        // the deduping logic is consistent\n        combined.withMutation((next)=>{\n            schema.tests.forEach((fn)=>{\n                next.test(fn.OPTIONS);\n            });\n        });\n        combined.transforms = [\n            ...base.transforms,\n            ...combined.transforms\n        ];\n        return combined;\n    }\n    isType(v) {\n        if (v == null) {\n            if (this.spec.nullable && v === null) return true;\n            if (this.spec.optional && v === undefined) return true;\n            return false;\n        }\n        return this._typeCheck(v);\n    }\n    resolve(options) {\n        let schema = this;\n        if (schema.conditions.length) {\n            let conditions = schema.conditions;\n            schema = schema.clone();\n            schema.conditions = [];\n            schema = conditions.reduce((prevSchema, condition)=>condition.resolve(prevSchema, options), schema);\n            schema = schema.resolve(options);\n        }\n        return schema;\n    }\n    resolveOptions(options) {\n        var _options$strict, _options$abortEarly, _options$recursive, _options$disableStack;\n        return Object.assign({}, options, {\n            from: options.from || [],\n            strict: (_options$strict = options.strict) != null ? _options$strict : this.spec.strict,\n            abortEarly: (_options$abortEarly = options.abortEarly) != null ? _options$abortEarly : this.spec.abortEarly,\n            recursive: (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive,\n            disableStackTrace: (_options$disableStack = options.disableStackTrace) != null ? _options$disableStack : this.spec.disableStackTrace\n        });\n    }\n    /**\n   * Run the configured transform pipeline over an input value.\n   */ cast(value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let resolvedSchema = this.resolve(Object.assign({\n            value\n        }, options));\n        let allowOptionality = options.assert === \"ignore-optionality\";\n        let result = resolvedSchema._cast(value, options);\n        if (options.assert !== false && !resolvedSchema.isType(result)) {\n            if (allowOptionality && isAbsent(result)) {\n                return result;\n            }\n            let formattedValue = printValue(value);\n            let formattedResult = printValue(result);\n            throw new TypeError(\"The value of \".concat(options.path || \"field\", \" could not be cast to a value \") + 'that satisfies the schema type: \"'.concat(resolvedSchema.type, '\". \\n\\n') + \"attempted value: \".concat(formattedValue, \" \\n\") + (formattedResult !== formattedValue ? \"result of cast: \".concat(formattedResult) : \"\"));\n        }\n        return result;\n    }\n    _cast(rawValue, options) {\n        let value = rawValue === undefined ? rawValue : this.transforms.reduce((prevValue, fn)=>fn.call(this, prevValue, rawValue, this), rawValue);\n        if (value === undefined) {\n            value = this.getDefault(options);\n        }\n        return value;\n    }\n    _validate(_value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, panic = arguments.length > 2 ? arguments[2] : void 0, next = arguments.length > 3 ? arguments[3] : void 0;\n        let { path, originalValue = _value, strict = this.spec.strict } = options;\n        let value = _value;\n        if (!strict) {\n            value = this._cast(value, Object.assign({\n                assert: false\n            }, options));\n        }\n        let initialTests = [];\n        for (let test of Object.values(this.internalTests)){\n            if (test) initialTests.push(test);\n        }\n        this.runTests({\n            path,\n            value,\n            originalValue,\n            options,\n            tests: initialTests\n        }, panic, (initialErrors)=>{\n            // even if we aren't ending early we can't proceed further if the types aren't correct\n            if (initialErrors.length) {\n                return next(initialErrors, value);\n            }\n            this.runTests({\n                path,\n                value,\n                originalValue,\n                options,\n                tests: this.tests\n            }, panic, next);\n        });\n    }\n    /**\n   * Executes a set of validations, either schema, produced Tests or a nested\n   * schema validate result.\n   */ runTests(runOptions, panic, next) {\n        let fired = false;\n        let { tests, value, originalValue, path, options } = runOptions;\n        let panicOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            panic(arg, value);\n        };\n        let nextOnce = (arg)=>{\n            if (fired) return;\n            fired = true;\n            next(arg, value);\n        };\n        let count = tests.length;\n        let nestedErrors = [];\n        if (!count) return nextOnce([]);\n        let args = {\n            value,\n            originalValue,\n            path,\n            options,\n            schema: this\n        };\n        for(let i = 0; i < tests.length; i++){\n            const test = tests[i];\n            test(args, panicOnce, function finishTestRun(err) {\n                if (err) {\n                    Array.isArray(err) ? nestedErrors.push(...err) : nestedErrors.push(err);\n                }\n                if (--count <= 0) {\n                    nextOnce(nestedErrors);\n                }\n            });\n        }\n    }\n    asNestedTest(param) {\n        let { key, index, parent, parentPath, originalParent, options } = param;\n        const k = key != null ? key : index;\n        if (k == null) {\n            throw TypeError(\"Must include `key` or `index` for nested validations\");\n        }\n        const isIndex = typeof k === \"number\";\n        let value = parent[k];\n        const testOptions = Object.assign({}, options, {\n            // Nested validations fields are always strict:\n            //    1. parent isn't strict so the casting will also have cast inner values\n            //    2. parent is strict in which case the nested values weren't cast either\n            strict: true,\n            parent,\n            value,\n            originalValue: originalParent[k],\n            // FIXME: tests depend on `index` being passed around deeply,\n            //   we should not let the options.key/index bleed through\n            key: undefined,\n            // index: undefined,\n            [isIndex ? \"index\" : \"key\"]: k,\n            path: isIndex || k.includes(\".\") ? \"\".concat(parentPath || \"\", \"[\").concat(isIndex ? k : '\"'.concat(k, '\"'), \"]\") : (parentPath ? \"\".concat(parentPath, \".\") : \"\") + key\n        });\n        return (_, panic, next)=>this.resolve(testOptions)._validate(value, testOptions, panic, next);\n    }\n    validate(value, options) {\n        var _options$disableStack2;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let disableStackTrace = (_options$disableStack2 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack2 : schema.spec.disableStackTrace;\n        return new Promise((resolve, reject)=>schema._validate(value, options, (error, parsed)=>{\n                if (ValidationError.isError(error)) error.value = parsed;\n                reject(error);\n            }, (errors, validated)=>{\n                if (errors.length) reject(new ValidationError(errors, validated, undefined, undefined, disableStackTrace));\n                else resolve(validated);\n            }));\n    }\n    validateSync(value, options) {\n        var _options$disableStack3;\n        let schema = this.resolve(Object.assign({}, options, {\n            value\n        }));\n        let result;\n        let disableStackTrace = (_options$disableStack3 = options == null ? void 0 : options.disableStackTrace) != null ? _options$disableStack3 : schema.spec.disableStackTrace;\n        schema._validate(value, Object.assign({}, options, {\n            sync: true\n        }), (error, parsed)=>{\n            if (ValidationError.isError(error)) error.value = parsed;\n            throw error;\n        }, (errors, validated)=>{\n            if (errors.length) throw new ValidationError(errors, value, undefined, undefined, disableStackTrace);\n            result = validated;\n        });\n        return result;\n    }\n    isValid(value, options) {\n        return this.validate(value, options).then(()=>true, (err)=>{\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        });\n    }\n    isValidSync(value, options) {\n        try {\n            this.validateSync(value, options);\n            return true;\n        } catch (err) {\n            if (ValidationError.isError(err)) return false;\n            throw err;\n        }\n    }\n    _getDefault(options) {\n        let defaultValue = this.spec.default;\n        if (defaultValue == null) {\n            return defaultValue;\n        }\n        return typeof defaultValue === \"function\" ? defaultValue.call(this, options) : clone(defaultValue);\n    }\n    getDefault(options) {\n        let schema = this.resolve(options || {});\n        return schema._getDefault(options);\n    }\n    default(def) {\n        if (arguments.length === 0) {\n            return this._getDefault();\n        }\n        let next = this.clone({\n            default: def\n        });\n        return next;\n    }\n    strict() {\n        let isStrict = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        return this.clone({\n            strict: isStrict\n        });\n    }\n    nullability(nullable, message) {\n        const next = this.clone({\n            nullable\n        });\n        next.internalTests.nullable = createValidation({\n            message,\n            name: \"nullable\",\n            test (value) {\n                return value === null ? this.schema.spec.nullable : true;\n            }\n        });\n        return next;\n    }\n    optionality(optional, message) {\n        const next = this.clone({\n            optional\n        });\n        next.internalTests.optionality = createValidation({\n            message,\n            name: \"optionality\",\n            test (value) {\n                return value === undefined ? this.schema.spec.optional : true;\n            }\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    defined() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mixed.defined;\n        return this.optionality(false, message);\n    }\n    nullable() {\n        return this.nullability(true);\n    }\n    nonNullable() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mixed.notNull;\n        return this.nullability(false, message);\n    }\n    required() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : mixed.required;\n        return this.clone().withMutation((next)=>next.nonNullable(message).defined(message));\n    }\n    notRequired() {\n        return this.clone().withMutation((next)=>next.nullable().optional());\n    }\n    transform(fn) {\n        let next = this.clone();\n        next.transforms.push(fn);\n        return next;\n    }\n    /**\n   * Adds a test function to the schema's queue of tests.\n   * tests can be exclusive or non-exclusive.\n   *\n   * - exclusive tests, will replace any existing tests of the same name.\n   * - non-exclusive: can be stacked\n   *\n   * If a non-exclusive test is added to a schema with an exclusive test of the same name\n   * the exclusive test is removed and further tests of the same name will be stacked.\n   *\n   * If an exclusive test is added to a schema with non-exclusive tests of the same name\n   * the previous tests are removed and further tests of the same name will replace each other.\n   */ test() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        let opts;\n        if (args.length === 1) {\n            if (typeof args[0] === \"function\") {\n                opts = {\n                    test: args[0]\n                };\n            } else {\n                opts = args[0];\n            }\n        } else if (args.length === 2) {\n            opts = {\n                name: args[0],\n                test: args[1]\n            };\n        } else {\n            opts = {\n                name: args[0],\n                message: args[1],\n                test: args[2]\n            };\n        }\n        if (opts.message === undefined) opts.message = mixed.default;\n        if (typeof opts.test !== \"function\") throw new TypeError(\"`test` is a required parameters\");\n        let next = this.clone();\n        let validate = createValidation(opts);\n        let isExclusive = opts.exclusive || opts.name && next.exclusiveTests[opts.name] === true;\n        if (opts.exclusive) {\n            if (!opts.name) throw new TypeError(\"Exclusive tests must provide a unique `name` identifying the test\");\n        }\n        if (opts.name) next.exclusiveTests[opts.name] = !!opts.exclusive;\n        next.tests = next.tests.filter((fn)=>{\n            if (fn.OPTIONS.name === opts.name) {\n                if (isExclusive) return false;\n                if (fn.OPTIONS.test === validate.OPTIONS.test) return false;\n            }\n            return true;\n        });\n        next.tests.push(validate);\n        return next;\n    }\n    when(keys, options) {\n        if (!Array.isArray(keys) && typeof keys !== \"string\") {\n            options = keys;\n            keys = \".\";\n        }\n        let next = this.clone();\n        let deps = toArray(keys).map((key)=>new Reference(key));\n        deps.forEach((dep)=>{\n            // @ts-ignore readonly array\n            if (dep.isSibling) next.deps.push(dep.key);\n        });\n        next.conditions.push(typeof options === \"function\" ? new Condition(deps, options) : Condition.fromOptions(deps, options));\n        return next;\n    }\n    typeError(message) {\n        let next = this.clone();\n        next.internalTests.typeError = createValidation({\n            message,\n            name: \"typeError\",\n            skipAbsent: true,\n            test (value) {\n                if (!this.schema._typeCheck(value)) return this.createError({\n                    params: {\n                        type: this.schema.type\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    oneOf(enums) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mixed.oneOf;\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._whitelist.add(val);\n            next._blacklist.delete(val);\n        });\n        next.internalTests.whiteList = createValidation({\n            message,\n            name: \"oneOf\",\n            skipAbsent: true,\n            test (value) {\n                let valids = this.schema._whitelist;\n                let resolved = valids.resolveAll(this.resolve);\n                return resolved.includes(value) ? true : this.createError({\n                    params: {\n                        values: Array.from(valids).join(\", \"),\n                        resolved\n                    }\n                });\n            }\n        });\n        return next;\n    }\n    notOneOf(enums) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : mixed.notOneOf;\n        let next = this.clone();\n        enums.forEach((val)=>{\n            next._blacklist.add(val);\n            next._whitelist.delete(val);\n        });\n        next.internalTests.blacklist = createValidation({\n            message,\n            name: \"notOneOf\",\n            test (value) {\n                let invalids = this.schema._blacklist;\n                let resolved = invalids.resolveAll(this.resolve);\n                if (resolved.includes(value)) return this.createError({\n                    params: {\n                        values: Array.from(invalids).join(\", \"),\n                        resolved\n                    }\n                });\n                return true;\n            }\n        });\n        return next;\n    }\n    strip() {\n        let strip = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true;\n        let next = this.clone();\n        next.spec.strip = strip;\n        return next;\n    }\n    /**\n   * Return a serialized description of the schema including validations, flags, types etc.\n   *\n   * @param options Provide any needed context for resolving runtime schema alterations (lazy, when conditions, etc).\n   */ describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const { label, meta, optional, nullable } = next.spec;\n        const description = {\n            meta,\n            label,\n            optional,\n            nullable,\n            default: next.getDefault(options),\n            type: next.type,\n            oneOf: next._whitelist.describe(),\n            notOneOf: next._blacklist.describe(),\n            tests: next.tests.map((fn)=>({\n                    name: fn.OPTIONS.name,\n                    params: fn.OPTIONS.params\n                })).filter((n, idx, list)=>list.findIndex((c)=>c.name === n.name) === idx)\n        };\n        return description;\n    }\n    constructor(options){\n        this.type = void 0;\n        this.deps = [];\n        this.tests = void 0;\n        this.transforms = void 0;\n        this.conditions = [];\n        this._mutate = void 0;\n        this.internalTests = {};\n        this._whitelist = new ReferenceSet();\n        this._blacklist = new ReferenceSet();\n        this.exclusiveTests = Object.create(null);\n        this._typeCheck = void 0;\n        this.spec = void 0;\n        this.tests = [];\n        this.transforms = [];\n        this.withMutation(()=>{\n            this.typeError(mixed.notType);\n        });\n        this.type = options.type;\n        this._typeCheck = options.check;\n        this.spec = Object.assign({\n            strip: false,\n            strict: false,\n            abortEarly: true,\n            recursive: true,\n            disableStackTrace: false,\n            nullable: false,\n            optional: true,\n            coerce: true\n        }, options == null ? void 0 : options.spec);\n        this.withMutation((s)=>{\n            s.nonNullable();\n        });\n    }\n}\n// @ts-expect-error\nSchema.prototype.__isYupSchema__ = true;\nfor (const method of [\n    \"validate\",\n    \"validateSync\"\n])Schema.prototype[\"\".concat(method, \"At\")] = function(path, value) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    const { parent, parentPath, schema } = getIn(this, path, value, options.context);\n    return schema[method](parent && parent[parentPath], Object.assign({}, options, {\n        parent,\n        path\n    }));\n};\nfor (const alias of [\n    \"equals\",\n    \"is\"\n])Schema.prototype[alias] = Schema.prototype.oneOf;\nfor (const alias of [\n    \"not\",\n    \"nope\"\n])Schema.prototype[alias] = Schema.prototype.notOneOf;\nconst returnsTrue = ()=>true;\nfunction create$8(spec) {\n    return new MixedSchema(spec);\n}\nclass MixedSchema extends Schema {\n    constructor(spec){\n        super(typeof spec === \"function\" ? {\n            type: \"mixed\",\n            check: spec\n        } : Object.assign({\n            type: \"mixed\",\n            check: returnsTrue\n        }, spec));\n    }\n}\ncreate$8.prototype = MixedSchema.prototype;\nfunction create$7() {\n    return new BooleanSchema();\n}\nclass BooleanSchema extends Schema {\n    isTrue() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : boolean.isValue;\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"true\"\n            },\n            test (value) {\n                return isAbsent(value) || value === true;\n            }\n        });\n    }\n    isFalse() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : boolean.isValue;\n        return this.test({\n            message,\n            name: \"is-value\",\n            exclusive: true,\n            params: {\n                value: \"false\"\n            },\n            test (value) {\n                return isAbsent(value) || value === false;\n            }\n        });\n    }\n    default(def) {\n        return super.default(def);\n    }\n    defined(msg) {\n        return super.defined(msg);\n    }\n    optional() {\n        return super.optional();\n    }\n    required(msg) {\n        return super.required(msg);\n    }\n    notRequired() {\n        return super.notRequired();\n    }\n    nullable() {\n        return super.nullable();\n    }\n    nonNullable(msg) {\n        return super.nonNullable(msg);\n    }\n    strip(v) {\n        return super.strip(v);\n    }\n    constructor(){\n        super({\n            type: \"boolean\",\n            check (v) {\n                if (v instanceof Boolean) v = v.valueOf();\n                return typeof v === \"boolean\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (ctx.spec.coerce && !ctx.isType(value)) {\n                    if (/^(true|1)$/i.test(String(value))) return true;\n                    if (/^(false|0)$/i.test(String(value))) return false;\n                }\n                return value;\n            });\n        });\n    }\n}\ncreate$7.prototype = BooleanSchema.prototype;\n/**\n * This file is a modified version of the file from the following repository:\n * Date.parse with progressive enhancement for ISO 8601 <https://github.com/csnover/js-iso8601>\n * NON-CONFORMANT EDITION.\n * © 2011 Colin Snover <http://zetafleet.com>\n * Released under MIT license.\n */ // prettier-ignore\n//                1 YYYY                2 MM        3 DD              4 HH     5 mm        6 ss           7 msec         8 Z 9 ±   10 tzHH    11 tzmm\nconst isoReg = /^(\\d{4}|[+-]\\d{6})(?:-?(\\d{2})(?:-?(\\d{2}))?)?(?:[ T]?(\\d{2}):?(\\d{2})(?::?(\\d{2})(?:[,.](\\d{1,}))?)?(?:(Z)|([+-])(\\d{2})(?::?(\\d{2}))?)?)?$/;\nfunction parseIsoDate(date) {\n    const struct = parseDateStruct(date);\n    if (!struct) return Date.parse ? Date.parse(date) : Number.NaN;\n    // timestamps without timezone identifiers should be considered local time\n    if (struct.z === undefined && struct.plusMinus === undefined) {\n        return new Date(struct.year, struct.month, struct.day, struct.hour, struct.minute, struct.second, struct.millisecond).valueOf();\n    }\n    let totalMinutesOffset = 0;\n    if (struct.z !== \"Z\" && struct.plusMinus !== undefined) {\n        totalMinutesOffset = struct.hourOffset * 60 + struct.minuteOffset;\n        if (struct.plusMinus === \"+\") totalMinutesOffset = 0 - totalMinutesOffset;\n    }\n    return Date.UTC(struct.year, struct.month, struct.day, struct.hour, struct.minute + totalMinutesOffset, struct.second, struct.millisecond);\n}\nfunction parseDateStruct(date) {\n    var _regexResult$7$length, _regexResult$;\n    const regexResult = isoReg.exec(date);\n    if (!regexResult) return null;\n    // use of toNumber() avoids NaN timestamps caused by “undefined”\n    // values being passed to Date constructor\n    return {\n        year: toNumber(regexResult[1]),\n        month: toNumber(regexResult[2], 1) - 1,\n        day: toNumber(regexResult[3], 1),\n        hour: toNumber(regexResult[4]),\n        minute: toNumber(regexResult[5]),\n        second: toNumber(regexResult[6]),\n        millisecond: regexResult[7] ? // allow arbitrary sub-second precision beyond milliseconds\n        toNumber(regexResult[7].substring(0, 3)) : 0,\n        precision: (_regexResult$7$length = (_regexResult$ = regexResult[7]) == null ? void 0 : _regexResult$.length) != null ? _regexResult$7$length : undefined,\n        z: regexResult[8] || undefined,\n        plusMinus: regexResult[9] || undefined,\n        hourOffset: toNumber(regexResult[10]),\n        minuteOffset: toNumber(regexResult[11])\n    };\n}\nfunction toNumber(str) {\n    let defaultValue = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : 0;\n    return Number(str) || defaultValue;\n}\n// Taken from HTML spec: https://html.spec.whatwg.org/multipage/input.html#valid-e-mail-address\nlet rEmail = // eslint-disable-next-line\n/^[a-zA-Z0-9.!#$%&'*+\\/=?^_`{|}~-]+@[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?(?:\\.[a-zA-Z0-9](?:[a-zA-Z0-9-]{0,61}[a-zA-Z0-9])?)*$/;\nlet rUrl = // eslint-disable-next-line\n/^((https?|ftp):)?\\/\\/(((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:)*@)?(((\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5])\\.(\\d|[1-9]\\d|1\\d\\d|2[0-4]\\d|25[0-5]))|((([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|\\d|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.)+(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])*([a-z]|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])))\\.?)(:\\d*)?)(\\/((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)+(\\/(([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)*)*)?)?(\\?((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|[\\uE000-\\uF8FF]|\\/|\\?)*)?(\\#((([a-z]|\\d|-|\\.|_|~|[\\u00A0-\\uD7FF\\uF900-\\uFDCF\\uFDF0-\\uFFEF])|(%[\\da-f]{2})|[!\\$&'\\(\\)\\*\\+,;=]|:|@)|\\/|\\?)*)?$/i;\n// eslint-disable-next-line\nlet rUUID = /^(?:[0-9a-f]{8}-[0-9a-f]{4}-[1-5][0-9a-f]{3}-[89ab][0-9a-f]{3}-[0-9a-f]{12}|00000000-0000-0000-0000-000000000000)$/i;\nlet yearMonthDay = \"^\\\\d{4}-\\\\d{2}-\\\\d{2}\";\nlet hourMinuteSecond = \"\\\\d{2}:\\\\d{2}:\\\\d{2}\";\nlet zOrOffset = \"(([+-]\\\\d{2}(:?\\\\d{2})?)|Z)\";\nlet rIsoDateTime = new RegExp(\"\".concat(yearMonthDay, \"T\").concat(hourMinuteSecond, \"(\\\\.\\\\d+)?\").concat(zOrOffset, \"$\"));\nlet isTrimmed = (value)=>isAbsent(value) || value === value.trim();\nlet objStringTag = ({}).toString();\nfunction create$6() {\n    return new StringSchema();\n}\nclass StringSchema extends Schema {\n    required(message) {\n        return super.required(message).withMutation((schema)=>schema.test({\n                message: message || mixed.required,\n                name: \"required\",\n                skipAbsent: true,\n                test: (value)=>!!value.length\n            }));\n    }\n    notRequired() {\n        return super.notRequired().withMutation((schema)=>{\n            schema.tests = schema.tests.filter((t)=>t.OPTIONS.name !== \"required\");\n            return schema;\n        });\n    }\n    length(length) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : string.length;\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : string.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : string.max;\n        return this.test({\n            name: \"max\",\n            exclusive: true,\n            message,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    matches(regex, options) {\n        let excludeEmptyString = false;\n        let message;\n        let name;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ excludeEmptyString = false, message, name } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.test({\n            name: name || \"matches\",\n            message: message || string.matches,\n            params: {\n                regex\n            },\n            skipAbsent: true,\n            test: (value)=>value === \"\" && excludeEmptyString || value.search(regex) !== -1\n        });\n    }\n    email() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.email;\n        return this.matches(rEmail, {\n            name: \"email\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    url() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.url;\n        return this.matches(rUrl, {\n            name: \"url\",\n            message,\n            excludeEmptyString: true\n        });\n    }\n    uuid() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.uuid;\n        return this.matches(rUUID, {\n            name: \"uuid\",\n            message,\n            excludeEmptyString: false\n        });\n    }\n    datetime(options) {\n        let message = \"\";\n        let allowOffset;\n        let precision;\n        if (options) {\n            if (typeof options === \"object\") {\n                ({ message = \"\", allowOffset = false, precision = undefined } = options);\n            } else {\n                message = options;\n            }\n        }\n        return this.matches(rIsoDateTime, {\n            name: \"datetime\",\n            message: message || string.datetime,\n            excludeEmptyString: true\n        }).test({\n            name: \"datetime_offset\",\n            message: message || string.datetime_offset,\n            params: {\n                allowOffset\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || allowOffset) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return !!struct.z;\n            }\n        }).test({\n            name: \"datetime_precision\",\n            message: message || string.datetime_precision,\n            params: {\n                precision\n            },\n            skipAbsent: true,\n            test: (value)=>{\n                if (!value || precision == undefined) return true;\n                const struct = parseDateStruct(value);\n                if (!struct) return false;\n                return struct.precision === precision;\n            }\n        });\n    }\n    //-- transforms --\n    ensure() {\n        return this.default(\"\").transform((val)=>val === null ? \"\" : val);\n    }\n    trim() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.trim;\n        return this.transform((val)=>val != null ? val.trim() : val).test({\n            message,\n            name: \"trim\",\n            test: isTrimmed\n        });\n    }\n    lowercase() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.lowercase;\n        return this.transform((value)=>!isAbsent(value) ? value.toLowerCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toLowerCase()\n        });\n    }\n    uppercase() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : string.uppercase;\n        return this.transform((value)=>!isAbsent(value) ? value.toUpperCase() : value).test({\n            message,\n            name: \"string_case\",\n            exclusive: true,\n            skipAbsent: true,\n            test: (value)=>isAbsent(value) || value === value.toUpperCase()\n        });\n    }\n    constructor(){\n        super({\n            type: \"string\",\n            check (value) {\n                if (value instanceof String) value = value.valueOf();\n                return typeof value === \"string\";\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce || ctx.isType(value)) return value;\n                // don't ever convert arrays\n                if (Array.isArray(value)) return value;\n                const strValue = value != null && value.toString ? value.toString() : value;\n                // no one wants plain objects converted to [Object object]\n                if (strValue === objStringTag) return value;\n                return strValue;\n            });\n        });\n    }\n}\ncreate$6.prototype = StringSchema.prototype;\n//\n// String Interfaces\n//\nlet isNaN$1 = (value)=>value != +value;\nfunction create$5() {\n    return new NumberSchema();\n}\nclass NumberSchema extends Schema {\n    min(min) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : number.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(min);\n            }\n        });\n    }\n    max(max) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : number.max;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(max);\n            }\n        });\n    }\n    lessThan(less) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : number.lessThan;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                less\n            },\n            skipAbsent: true,\n            test (value) {\n                return value < this.resolve(less);\n            }\n        });\n    }\n    moreThan(more) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : number.moreThan;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                more\n            },\n            skipAbsent: true,\n            test (value) {\n                return value > this.resolve(more);\n            }\n        });\n    }\n    positive() {\n        let msg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : number.positive;\n        return this.moreThan(0, msg);\n    }\n    negative() {\n        let msg = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : number.negative;\n        return this.lessThan(0, msg);\n    }\n    integer() {\n        let message = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : number.integer;\n        return this.test({\n            name: \"integer\",\n            message,\n            skipAbsent: true,\n            test: (val)=>Number.isInteger(val)\n        });\n    }\n    truncate() {\n        return this.transform((value)=>!isAbsent(value) ? value | 0 : value);\n    }\n    round(method) {\n        var _method;\n        let avail = [\n            \"ceil\",\n            \"floor\",\n            \"round\",\n            \"trunc\"\n        ];\n        method = ((_method = method) == null ? void 0 : _method.toLowerCase()) || \"round\";\n        // this exists for symemtry with the new Math.trunc\n        if (method === \"trunc\") return this.truncate();\n        if (avail.indexOf(method.toLowerCase()) === -1) throw new TypeError(\"Only valid options for round() are: \" + avail.join(\", \"));\n        return this.transform((value)=>!isAbsent(value) ? Math[method](value) : value);\n    }\n    constructor(){\n        super({\n            type: \"number\",\n            check (value) {\n                if (value instanceof Number) value = value.valueOf();\n                return typeof value === \"number\" && !isNaN$1(value);\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                if (!ctx.spec.coerce) return value;\n                let parsed = value;\n                if (typeof parsed === \"string\") {\n                    parsed = parsed.replace(/\\s/g, \"\");\n                    if (parsed === \"\") return NaN;\n                    // don't use parseFloat to avoid positives on alpha-numeric strings\n                    parsed = +parsed;\n                }\n                // null -> NaN isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (ctx.isType(parsed) || parsed === null) return parsed;\n                return parseFloat(parsed);\n            });\n        });\n    }\n}\ncreate$5.prototype = NumberSchema.prototype;\n//\n// Number Interfaces\n//\nlet invalidDate = new Date(\"\");\nlet isDate = (obj)=>Object.prototype.toString.call(obj) === \"[object Date]\";\nfunction create$4() {\n    return new DateSchema();\n}\nclass DateSchema extends Schema {\n    prepareParam(ref, name) {\n        let param;\n        if (!Reference.isRef(ref)) {\n            let cast = this.cast(ref);\n            if (!this._typeCheck(cast)) throw new TypeError(\"`\".concat(name, \"` must be a Date or a value that can be `cast()` to a Date\"));\n            param = cast;\n        } else {\n            param = ref;\n        }\n        return param;\n    }\n    min(min) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : date.min;\n        let limit = this.prepareParam(min, \"min\");\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            test (value) {\n                return value >= this.resolve(limit);\n            }\n        });\n    }\n    max(max) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : date.max;\n        let limit = this.prepareParam(max, \"max\");\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value <= this.resolve(limit);\n            }\n        });\n    }\n    constructor(){\n        super({\n            type: \"date\",\n            check (v) {\n                return isDate(v) && !isNaN(v.getTime());\n            }\n        });\n        this.withMutation(()=>{\n            this.transform((value, _raw, ctx)=>{\n                // null -> InvalidDate isn't useful; treat all nulls as null and let it fail on\n                // nullability check vs TypeErrors\n                if (!ctx.spec.coerce || ctx.isType(value) || value === null) return value;\n                value = parseIsoDate(value);\n                // 0 is a valid timestamp equivalent to 1970-01-01T00:00:00Z(unix epoch) or before.\n                return !isNaN(value) ? new Date(value) : DateSchema.INVALID_DATE;\n            });\n        });\n    }\n}\nDateSchema.INVALID_DATE = invalidDate;\ncreate$4.prototype = DateSchema.prototype;\ncreate$4.INVALID_DATE = invalidDate;\n// @ts-expect-error\nfunction sortFields(fields) {\n    let excludedEdges = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n    let edges = [];\n    let nodes = new Set();\n    let excludes = new Set(excludedEdges.map((param)=>{\n        let [a, b] = param;\n        return \"\".concat(a, \"-\").concat(b);\n    }));\n    function addNode(depPath, key) {\n        let node = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.split)(depPath)[0];\n        nodes.add(node);\n        if (!excludes.has(\"\".concat(key, \"-\").concat(node))) edges.push([\n            key,\n            node\n        ]);\n    }\n    for (const key of Object.keys(fields)){\n        let value = fields[key];\n        nodes.add(key);\n        if (Reference.isRef(value) && value.isSibling) addNode(value.path, key);\n        else if (isSchema(value) && \"deps\" in value) value.deps.forEach((path)=>addNode(path, key));\n    }\n    return toposort__WEBPACK_IMPORTED_MODULE_2___default().array(Array.from(nodes), edges).reverse();\n}\nfunction findIndex(arr, err) {\n    let idx = Infinity;\n    arr.some((key, ii)=>{\n        var _err$path;\n        if ((_err$path = err.path) != null && _err$path.includes(key)) {\n            idx = ii;\n            return true;\n        }\n    });\n    return idx;\n}\nfunction sortByKeyOrder(keys) {\n    return (a, b)=>{\n        return findIndex(keys, a) - findIndex(keys, b);\n    };\n}\nconst parseJson = (value, _, ctx)=>{\n    if (typeof value !== \"string\") {\n        return value;\n    }\n    let parsed = value;\n    try {\n        parsed = JSON.parse(value);\n    } catch (err) {\n    /* */ }\n    return ctx.isType(parsed) ? parsed : value;\n};\n// @ts-ignore\nfunction deepPartial(schema) {\n    if (\"fields\" in schema) {\n        const partial = {};\n        for (const [key, fieldSchema] of Object.entries(schema.fields)){\n            partial[key] = deepPartial(fieldSchema);\n        }\n        return schema.setFields(partial);\n    }\n    if (schema.type === \"array\") {\n        const nextArray = schema.optional();\n        if (nextArray.innerType) nextArray.innerType = deepPartial(nextArray.innerType);\n        return nextArray;\n    }\n    if (schema.type === \"tuple\") {\n        return schema.optional().clone({\n            types: schema.spec.types.map(deepPartial)\n        });\n    }\n    if (\"optional\" in schema) {\n        return schema.optional();\n    }\n    return schema;\n}\nconst deepHas = (obj, p)=>{\n    const path = [\n        ...(0,property_expr__WEBPACK_IMPORTED_MODULE_0__.normalizePath)(p)\n    ];\n    if (path.length === 1) return path[0] in obj;\n    let last = path.pop();\n    let parent = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)((0,property_expr__WEBPACK_IMPORTED_MODULE_0__.join)(path), true)(obj);\n    return !!(parent && last in parent);\n};\nlet isObject = (obj)=>Object.prototype.toString.call(obj) === \"[object Object]\";\nfunction unknown(ctx, value) {\n    let known = Object.keys(ctx.fields);\n    return Object.keys(value).filter((key)=>known.indexOf(key) === -1);\n}\nconst defaultSort = sortByKeyOrder([]);\nfunction create$3(spec) {\n    return new ObjectSchema(spec);\n}\nclass ObjectSchema extends Schema {\n    _cast(_value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        var _options$stripUnknown;\n        let value = super._cast(_value, options);\n        //should ignore nulls here\n        if (value === undefined) return this.getDefault(options);\n        if (!this._typeCheck(value)) return value;\n        let fields = this.fields;\n        let strip = (_options$stripUnknown = options.stripUnknown) != null ? _options$stripUnknown : this.spec.noUnknown;\n        let props = [].concat(this._nodes, Object.keys(value).filter((v)=>!this._nodes.includes(v)));\n        let intermediateValue = {}; // is filled during the transform below\n        let innerOptions = Object.assign({}, options, {\n            parent: intermediateValue,\n            __validating: options.__validating || false\n        });\n        let isChanged = false;\n        for (const prop of props){\n            let field = fields[prop];\n            let exists = prop in value;\n            if (field) {\n                let fieldValue;\n                let inputValue = value[prop];\n                // safe to mutate since this is fired in sequence\n                innerOptions.path = (options.path ? \"\".concat(options.path, \".\") : \"\") + prop;\n                field = field.resolve({\n                    value: inputValue,\n                    context: options.context,\n                    parent: intermediateValue\n                });\n                let fieldSpec = field instanceof Schema ? field.spec : undefined;\n                let strict = fieldSpec == null ? void 0 : fieldSpec.strict;\n                if (fieldSpec != null && fieldSpec.strip) {\n                    isChanged = isChanged || prop in value;\n                    continue;\n                }\n                fieldValue = !options.__validating || !strict ? // TODO: use _cast, this is double resolving\n                field.cast(value[prop], innerOptions) : value[prop];\n                if (fieldValue !== undefined) {\n                    intermediateValue[prop] = fieldValue;\n                }\n            } else if (exists && !strip) {\n                intermediateValue[prop] = value[prop];\n            }\n            if (exists !== prop in intermediateValue || intermediateValue[prop] !== value[prop]) {\n                isChanged = true;\n            }\n        }\n        return isChanged ? intermediateValue : value;\n    }\n    _validate(_value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, panic = arguments.length > 2 ? arguments[2] : void 0, next = arguments.length > 3 ? arguments[3] : void 0;\n        let { from = [], originalValue = _value, recursive = this.spec.recursive } = options;\n        options.from = [\n            {\n                schema: this,\n                value: originalValue\n            },\n            ...from\n        ];\n        // this flag is needed for handling `strict` correctly in the context of\n        // validation vs just casting. e.g strict() on a field is only used when validating\n        options.__validating = true;\n        options.originalValue = originalValue;\n        super._validate(_value, options, panic, (objectErrors, value)=>{\n            if (!recursive || !isObject(value)) {\n                next(objectErrors, value);\n                return;\n            }\n            originalValue = originalValue || value;\n            let tests = [];\n            for (let key of this._nodes){\n                let field = this.fields[key];\n                if (!field || Reference.isRef(field)) {\n                    continue;\n                }\n                tests.push(field.asNestedTest({\n                    options,\n                    key,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: originalValue\n                }));\n            }\n            this.runTests({\n                tests,\n                value,\n                originalValue,\n                options\n            }, panic, (fieldErrors)=>{\n                next(fieldErrors.sort(this._sortErrors).concat(objectErrors), value);\n            });\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        next.fields = Object.assign({}, this.fields);\n        next._nodes = this._nodes;\n        next._excludedEdges = this._excludedEdges;\n        next._sortErrors = this._sortErrors;\n        return next;\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        let nextFields = next.fields;\n        for (let [field, schemaOrRef] of Object.entries(this.fields)){\n            const target = nextFields[field];\n            nextFields[field] = target === undefined ? schemaOrRef : target;\n        }\n        return next.withMutation((s)=>// XXX: excludes here is wrong\n            s.setFields(nextFields, [\n                ...this._excludedEdges,\n                ...schema._excludedEdges\n            ]));\n    }\n    _getDefault(options) {\n        if (\"default\" in this.spec) {\n            return super._getDefault(options);\n        }\n        // if there is no default set invent one\n        if (!this._nodes.length) {\n            return undefined;\n        }\n        let dft = {};\n        this._nodes.forEach((key)=>{\n            var _innerOptions;\n            const field = this.fields[key];\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            dft[key] = field && \"getDefault\" in field ? field.getDefault(innerOptions) : undefined;\n        });\n        return dft;\n    }\n    setFields(shape, excludedEdges) {\n        let next = this.clone();\n        next.fields = shape;\n        next._nodes = sortFields(shape, excludedEdges);\n        next._sortErrors = sortByKeyOrder(Object.keys(shape));\n        // XXX: this carries over edges which may not be what you want\n        if (excludedEdges) next._excludedEdges = excludedEdges;\n        return next;\n    }\n    shape(additions) {\n        let excludes = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [];\n        return this.clone().withMutation((next)=>{\n            let edges = next._excludedEdges;\n            if (excludes.length) {\n                if (!Array.isArray(excludes[0])) excludes = [\n                    excludes\n                ];\n                edges = [\n                    ...next._excludedEdges,\n                    ...excludes\n                ];\n            }\n            // XXX: excludes here is wrong\n            return next.setFields(Object.assign(next.fields, additions), edges);\n        });\n    }\n    partial() {\n        const partial = {};\n        for (const [key, schema] of Object.entries(this.fields)){\n            partial[key] = \"optional\" in schema && schema.optional instanceof Function ? schema.optional() : schema;\n        }\n        return this.setFields(partial);\n    }\n    deepPartial() {\n        const next = deepPartial(this);\n        return next;\n    }\n    pick(keys) {\n        const picked = {};\n        for (const key of keys){\n            if (this.fields[key]) picked[key] = this.fields[key];\n        }\n        return this.setFields(picked, this._excludedEdges.filter((param)=>{\n            let [a, b] = param;\n            return keys.includes(a) && keys.includes(b);\n        }));\n    }\n    omit(keys) {\n        const remaining = [];\n        for (const key of Object.keys(this.fields)){\n            if (keys.includes(key)) continue;\n            remaining.push(key);\n        }\n        return this.pick(remaining);\n    }\n    from(from, to, alias) {\n        let fromGetter = (0,property_expr__WEBPACK_IMPORTED_MODULE_0__.getter)(from, true);\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            let newObj = obj;\n            if (deepHas(obj, from)) {\n                newObj = Object.assign({}, obj);\n                if (!alias) delete newObj[from];\n                newObj[to] = fromGetter(obj);\n            }\n            return newObj;\n        });\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    /**\n   * Similar to `noUnknown` but only validates that an object is the right shape without stripping the unknown keys\n   */ exact(message) {\n        return this.test({\n            name: \"exact\",\n            exclusive: true,\n            message: message || object.exact,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return unknownKeys.length === 0 || this.createError({\n                    params: {\n                        properties: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n    }\n    stripUnknown() {\n        return this.clone({\n            noUnknown: true\n        });\n    }\n    noUnknown() {\n        let noAllow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.noUnknown;\n        if (typeof noAllow !== \"boolean\") {\n            message = noAllow;\n            noAllow = true;\n        }\n        let next = this.test({\n            name: \"noUnknown\",\n            exclusive: true,\n            message: message,\n            test (value) {\n                if (value == null) return true;\n                const unknownKeys = unknown(this.schema, value);\n                return !noAllow || unknownKeys.length === 0 || this.createError({\n                    params: {\n                        unknown: unknownKeys.join(\", \")\n                    }\n                });\n            }\n        });\n        next.spec.noUnknown = noAllow;\n        return next;\n    }\n    unknown() {\n        let allow = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : true, message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : object.noUnknown;\n        return this.noUnknown(!allow, message);\n    }\n    transformKeys(fn) {\n        return this.transform((obj)=>{\n            if (!obj) return obj;\n            const result = {};\n            for (const key of Object.keys(obj))result[fn(key)] = obj[key];\n            return result;\n        });\n    }\n    camelCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.camelCase);\n    }\n    snakeCase() {\n        return this.transformKeys(tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase);\n    }\n    constantCase() {\n        return this.transformKeys((key)=>(0,tiny_case__WEBPACK_IMPORTED_MODULE_1__.snakeCase)(key).toUpperCase());\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.fields = {};\n        for (const [key, value] of Object.entries(next.fields)){\n            var _innerOptions2;\n            let innerOptions = options;\n            if ((_innerOptions2 = innerOptions) != null && _innerOptions2.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[key]\n                });\n            }\n            base.fields[key] = value.describe(innerOptions);\n        }\n        return base;\n    }\n    constructor(spec){\n        super({\n            type: \"object\",\n            check (value) {\n                return isObject(value) || typeof value === \"function\";\n            }\n        });\n        this.fields = Object.create(null);\n        this._sortErrors = defaultSort;\n        this._nodes = [];\n        this._excludedEdges = [];\n        this.withMutation(()=>{\n            if (spec) {\n                this.shape(spec);\n            }\n        });\n    }\n}\ncreate$3.prototype = ObjectSchema.prototype;\nfunction create$2(type) {\n    return new ArraySchema(type);\n}\nclass ArraySchema extends Schema {\n    _cast(_value, _opts) {\n        const value = super._cast(_value, _opts);\n        // should ignore nulls here\n        if (!this._typeCheck(value) || !this.innerType) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = value.map((v, idx)=>{\n            const castElement = this.innerType.cast(v, Object.assign({}, _opts, {\n                path: \"\".concat(_opts.path || \"\", \"[\").concat(idx, \"]\")\n            }));\n            if (castElement !== v) {\n                isChanged = true;\n            }\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, panic = arguments.length > 2 ? arguments[2] : void 0, next = arguments.length > 3 ? arguments[3] : void 0;\n        var _options$recursive;\n        // let sync = options.sync;\n        // let path = options.path;\n        let innerType = this.innerType;\n        // let endEarly = options.abortEarly ?? this.spec.abortEarly;\n        let recursive = (_options$recursive = options.recursive) != null ? _options$recursive : this.spec.recursive;\n        options.originalValue != null ? options.originalValue : _value;\n        super._validate(_value, options, panic, (arrayErrors, value)=>{\n            var _options$originalValu2;\n            if (!recursive || !innerType || !this._typeCheck(value)) {\n                next(arrayErrors, value);\n                return;\n            }\n            // #950 Ensure that sparse array empty slots are validated\n            let tests = new Array(value.length);\n            for(let index = 0; index < value.length; index++){\n                var _options$originalValu;\n                tests[index] = innerType.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(arrayErrors), value));\n        });\n    }\n    clone(spec) {\n        const next = super.clone(spec);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        return next;\n    }\n    /** Parse an input JSON string to an object */ json() {\n        return this.transform(parseJson);\n    }\n    concat(schema) {\n        let next = super.concat(schema);\n        // @ts-expect-error readonly\n        next.innerType = this.innerType;\n        if (schema.innerType) // @ts-expect-error readonly\n        next.innerType = next.innerType ? // @ts-expect-error Lazy doesn't have concat and will break\n        next.innerType.concat(schema.innerType) : schema.innerType;\n        return next;\n    }\n    of(schema) {\n        // FIXME: this should return a new instance of array without the default to be\n        let next = this.clone();\n        if (!isSchema(schema)) throw new TypeError(\"`array.of()` sub-schema must be a valid yup schema not: \" + printValue(schema));\n        // @ts-expect-error readonly\n        next.innerType = schema;\n        next.spec = Object.assign({}, next.spec, {\n            types: schema\n        });\n        return next;\n    }\n    length(length) {\n        let message = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : array.length;\n        return this.test({\n            message,\n            name: \"length\",\n            exclusive: true,\n            params: {\n                length\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length === this.resolve(length);\n            }\n        });\n    }\n    min(min, message) {\n        message = message || array.min;\n        return this.test({\n            message,\n            name: \"min\",\n            exclusive: true,\n            params: {\n                min\n            },\n            skipAbsent: true,\n            // FIXME(ts): Array<typeof T>\n            test (value) {\n                return value.length >= this.resolve(min);\n            }\n        });\n    }\n    max(max, message) {\n        message = message || array.max;\n        return this.test({\n            message,\n            name: \"max\",\n            exclusive: true,\n            params: {\n                max\n            },\n            skipAbsent: true,\n            test (value) {\n                return value.length <= this.resolve(max);\n            }\n        });\n    }\n    ensure() {\n        return this.default(()=>[]).transform((val, original)=>{\n            // We don't want to return `null` for nullable schema\n            if (this._typeCheck(val)) return val;\n            return original == null ? [] : [].concat(original);\n        });\n    }\n    compact(rejector) {\n        let reject = !rejector ? (v)=>!!v : (v, i, a)=>!rejector(v, i, a);\n        return this.transform((values)=>values != null ? values.filter(reject) : values);\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        if (next.innerType) {\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[0]\n                });\n            }\n            base.innerType = next.innerType.describe(innerOptions);\n        }\n        return base;\n    }\n    constructor(type){\n        super({\n            type: \"array\",\n            spec: {\n                types: type\n            },\n            check (v) {\n                return Array.isArray(v);\n            }\n        });\n        // `undefined` specifically means uninitialized, as opposed to \"no subtype\"\n        this.innerType = void 0;\n        this.innerType = type;\n    }\n}\ncreate$2.prototype = ArraySchema.prototype;\n// @ts-ignore\nfunction create$1(schemas) {\n    return new TupleSchema(schemas);\n}\nclass TupleSchema extends Schema {\n    _cast(inputValue, options) {\n        const { types } = this.spec;\n        const value = super._cast(inputValue, options);\n        if (!this._typeCheck(value)) {\n            return value;\n        }\n        let isChanged = false;\n        const castArray = types.map((type, idx)=>{\n            const castElement = type.cast(value[idx], Object.assign({}, options, {\n                path: \"\".concat(options.path || \"\", \"[\").concat(idx, \"]\")\n            }));\n            if (castElement !== value[idx]) isChanged = true;\n            return castElement;\n        });\n        return isChanged ? castArray : value;\n    }\n    _validate(_value) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {}, panic = arguments.length > 2 ? arguments[2] : void 0, next = arguments.length > 3 ? arguments[3] : void 0;\n        let itemTypes = this.spec.types;\n        super._validate(_value, options, panic, (tupleErrors, value)=>{\n            var _options$originalValu2;\n            // intentionally not respecting recursive\n            if (!this._typeCheck(value)) {\n                next(tupleErrors, value);\n                return;\n            }\n            let tests = [];\n            for (let [index, itemSchema] of itemTypes.entries()){\n                var _options$originalValu;\n                tests[index] = itemSchema.asNestedTest({\n                    options,\n                    index,\n                    parent: value,\n                    parentPath: options.path,\n                    originalParent: (_options$originalValu = options.originalValue) != null ? _options$originalValu : _value\n                });\n            }\n            this.runTests({\n                value,\n                tests,\n                originalValue: (_options$originalValu2 = options.originalValue) != null ? _options$originalValu2 : _value,\n                options\n            }, panic, (innerTypeErrors)=>next(innerTypeErrors.concat(tupleErrors), value));\n        });\n    }\n    describe(options) {\n        const next = (options ? this.resolve(options) : this).clone();\n        const base = super.describe(options);\n        base.innerType = next.spec.types.map((schema, index)=>{\n            var _innerOptions;\n            let innerOptions = options;\n            if ((_innerOptions = innerOptions) != null && _innerOptions.value) {\n                innerOptions = Object.assign({}, innerOptions, {\n                    parent: innerOptions.value,\n                    value: innerOptions.value[index]\n                });\n            }\n            return schema.describe(innerOptions);\n        });\n        return base;\n    }\n    constructor(schemas){\n        super({\n            type: \"tuple\",\n            spec: {\n                types: schemas\n            },\n            check (v) {\n                const types = this.spec.types;\n                return Array.isArray(v) && v.length === types.length;\n            }\n        });\n        this.withMutation(()=>{\n            this.typeError(tuple.notType);\n        });\n    }\n}\ncreate$1.prototype = TupleSchema.prototype;\nfunction create(builder) {\n    return new Lazy(builder);\n}\nfunction catchValidationError(fn) {\n    try {\n        return fn();\n    } catch (err) {\n        if (ValidationError.isError(err)) return Promise.reject(err);\n        throw err;\n    }\n}\nclass Lazy {\n    clone(spec) {\n        const next = new Lazy(this.builder);\n        next.spec = Object.assign({}, this.spec, spec);\n        return next;\n    }\n    optionality(optional) {\n        const next = this.clone({\n            optional\n        });\n        return next;\n    }\n    optional() {\n        return this.optionality(true);\n    }\n    resolve(options) {\n        return this._resolve(options.value, options);\n    }\n    cast(value, options) {\n        return this._resolve(value, options).cast(value, options);\n    }\n    asNestedTest(config) {\n        let { key, index, parent, options } = config;\n        let value = parent[index != null ? index : key];\n        return this._resolve(value, Object.assign({}, options, {\n            value,\n            parent\n        })).asNestedTest(config);\n    }\n    validate(value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validate(value, options));\n    }\n    validateSync(value, options) {\n        return this._resolve(value, options).validateSync(value, options);\n    }\n    validateAt(path, value, options) {\n        return catchValidationError(()=>this._resolve(value, options).validateAt(path, value, options));\n    }\n    validateSyncAt(path, value, options) {\n        return this._resolve(value, options).validateSyncAt(path, value, options);\n    }\n    isValid(value, options) {\n        try {\n            return this._resolve(value, options).isValid(value, options);\n        } catch (err) {\n            if (ValidationError.isError(err)) {\n                return Promise.resolve(false);\n            }\n            throw err;\n        }\n    }\n    isValidSync(value, options) {\n        return this._resolve(value, options).isValidSync(value, options);\n    }\n    describe(options) {\n        return options ? this.resolve(options).describe(options) : {\n            type: \"lazy\",\n            meta: this.spec.meta,\n            label: undefined\n        };\n    }\n    meta() {\n        for(var _len = arguments.length, args = new Array(_len), _key = 0; _key < _len; _key++){\n            args[_key] = arguments[_key];\n        }\n        if (args.length === 0) return this.spec.meta;\n        let next = this.clone();\n        next.spec.meta = Object.assign(next.spec.meta || {}, args[0]);\n        return next;\n    }\n    constructor(builder){\n        var _this = this;\n        this.type = \"lazy\";\n        this.__isYupSchema__ = true;\n        this.spec = void 0;\n        this._resolve = function(value) {\n            let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n            let schema = _this.builder(value, options);\n            if (!isSchema(schema)) throw new TypeError(\"lazy() functions must return a valid schema\");\n            if (_this.spec.optional) schema = schema.optional();\n            return schema.resolve(options);\n        };\n        this.builder = builder;\n        this.spec = {\n            meta: undefined,\n            optional: false\n        };\n    }\n}\nfunction setLocale(custom) {\n    Object.keys(custom).forEach((type)=>{\n        // @ts-ignore\n        Object.keys(custom[type]).forEach((method)=>{\n            // @ts-ignore\n            locale[type][method] = custom[type][method];\n        });\n    });\n}\nfunction addMethod(schemaType, name, fn) {\n    if (!schemaType || !isSchema(schemaType.prototype)) throw new TypeError(\"You must provide a yup schema constructor function\");\n    if (typeof name !== \"string\") throw new TypeError(\"A Method name must be provided\");\n    if (typeof fn !== \"function\") throw new TypeError(\"Method function must be provided\");\n    schemaType.prototype[name] = fn;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy95dXAvaW5kZXguZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQTRFO0FBQzNCO0FBQ2pCO0FBRWhDLE1BQU1RLFdBQVdDLE9BQU9DLFNBQVMsQ0FBQ0YsUUFBUTtBQUMxQyxNQUFNRyxnQkFBZ0JDLE1BQU1GLFNBQVMsQ0FBQ0YsUUFBUTtBQUM5QyxNQUFNSyxpQkFBaUJDLE9BQU9KLFNBQVMsQ0FBQ0YsUUFBUTtBQUNoRCxNQUFNTyxpQkFBaUIsT0FBT0MsV0FBVyxjQUFjQSxPQUFPTixTQUFTLENBQUNGLFFBQVEsR0FBRyxJQUFNO0FBQ3pGLE1BQU1TLGdCQUFnQjtBQUN0QixTQUFTQyxZQUFZQyxHQUFHO0lBQ3RCLElBQUlBLE9BQU8sQ0FBQ0EsS0FBSyxPQUFPO0lBQ3hCLE1BQU1DLGlCQUFpQkQsUUFBUSxLQUFLLElBQUlBLE1BQU07SUFDOUMsT0FBT0MsaUJBQWlCLE9BQU8sS0FBS0Q7QUFDdEM7QUFDQSxTQUFTRSxpQkFBaUJGLEdBQUc7UUFBRUcsZUFBQUEsaUVBQWU7SUFDNUMsSUFBSUgsT0FBTyxRQUFRQSxRQUFRLFFBQVFBLFFBQVEsT0FBTyxPQUFPLEtBQUtBO0lBQzlELE1BQU1JLFNBQVMsT0FBT0o7SUFDdEIsSUFBSUksV0FBVyxVQUFVLE9BQU9MLFlBQVlDO0lBQzVDLElBQUlJLFdBQVcsVUFBVSxPQUFPRCxlQUFlLElBQVEsT0FBSkgsS0FBSSxPQUFLQTtJQUM1RCxJQUFJSSxXQUFXLFlBQVksT0FBTyxlQUFnQkosQ0FBQUEsSUFBSUssSUFBSSxJQUFJLFdBQVUsSUFBSztJQUM3RSxJQUFJRCxXQUFXLFVBQVUsT0FBT1IsZUFBZVUsSUFBSSxDQUFDTixLQUFLTyxPQUFPLENBQUNULGVBQWU7SUFDaEYsTUFBTVUsTUFBTW5CLFNBQVNpQixJQUFJLENBQUNOLEtBQUtTLEtBQUssQ0FBQyxHQUFHLENBQUM7SUFDekMsSUFB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VTtZQUMzQyxJQUFJLE1BQUtoQixJQUFJLENBQUMrSCxRQUFRLEVBQUUxRyxTQUFTQSxPQUFPMEcsUUFBUTtZQUNoRCxPQUFPMUcsT0FBT0csT0FBTyxDQUFDRTtRQUN4QjtRQUNBLElBQUksQ0FBQ1EsT0FBTyxHQUFHQTtRQUNmLElBQUksQ0FBQ2xDLElBQUksR0FBRztZQUNWdUgsTUFBTXRGO1lBQ044RixVQUFVO1FBQ1o7SUFDRjtBQXdFRjtBQUVBLFNBQVNrUSxVQUFVQyxNQUFNO0lBQ3ZCcmUsT0FBTzZKLElBQUksQ0FBQ3dVLFFBQVE3ZSxPQUFPLENBQUNnRCxDQUFBQTtRQUMxQixhQUFhO1FBQ2J4QyxPQUFPNkosSUFBSSxDQUFDd1UsTUFBTSxDQUFDN2IsS0FBSyxFQUFFaEQsT0FBTyxDQUFDdVQsQ0FBQUE7WUFDaEMsYUFBYTtZQUNidk0sTUFBTSxDQUFDaEUsS0FBSyxDQUFDdVEsT0FBTyxHQUFHc0wsTUFBTSxDQUFDN2IsS0FBSyxDQUFDdVEsT0FBTztRQUM3QztJQUNGO0FBQ0Y7QUFFQSxTQUFTdUwsVUFBVUMsVUFBVSxFQUFFeGQsSUFBSSxFQUFFb0gsRUFBRTtJQUNyQyxJQUFJLENBQUNvVyxjQUFjLENBQUM3WCxTQUFTNlgsV0FBV3RlLFNBQVMsR0FBRyxNQUFNLElBQUlrSCxVQUFVO0lBQ3hFLElBQUksT0FBT3BHLFNBQVMsVUFBVSxNQUFNLElBQUlvRyxVQUFVO0lBQ2xELElBQUksT0FBT2dCLE9BQU8sWUFBWSxNQUFNLElBQUloQixVQUFVO0lBQ2xEb1gsV0FBV3RlLFNBQVMsQ0FBQ2MsS0FBSyxHQUFHb0g7QUFDL0I7QUFFcWMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vbm9kZV9tb2R1bGVzL3l1cC9pbmRleC5lc20uanM/MmVmZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBnZXR0ZXIsIGZvckVhY2gsIHNwbGl0LCBub3JtYWxpemVQYXRoLCBqb2luIH0gZnJvbSAncHJvcGVydHktZXhwcic7XG5pbXBvcnQgeyBjYW1lbENhc2UsIHNuYWtlQ2FzZSB9IGZyb20gJ3RpbnktY2FzZSc7XG5pbXBvcnQgdG9wb3NvcnQgZnJvbSAndG9wb3NvcnQnO1xuXG5jb25zdCB0b1N0cmluZyA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmc7XG5jb25zdCBlcnJvclRvU3RyaW5nID0gRXJyb3IucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3QgcmVnRXhwVG9TdHJpbmcgPSBSZWdFeHAucHJvdG90eXBlLnRvU3RyaW5nO1xuY29uc3Qgc3ltYm9sVG9TdHJpbmcgPSB0eXBlb2YgU3ltYm9sICE9PSAndW5kZWZpbmVkJyA/IFN5bWJvbC5wcm90b3R5cGUudG9TdHJpbmcgOiAoKSA9PiAnJztcbmNvbnN0IFNZTUJPTF9SRUdFWFAgPSAvXlN5bWJvbFxcKCguKilcXCkoLiopJC87XG5mdW5jdGlvbiBwcmludE51bWJlcih2YWwpIHtcbiAgaWYgKHZhbCAhPSArdmFsKSByZXR1cm4gJ05hTic7XG4gIGNvbnN0IGlzTmVnYXRpdmVaZXJvID0gdmFsID09PSAwICYmIDEgLyB2YWwgPCAwO1xuICByZXR1cm4gaXNOZWdhdGl2ZVplcm8gPyAnLTAnIDogJycgKyB2YWw7XG59XG5mdW5jdGlvbiBwcmludFNpbXBsZVZhbHVlKHZhbCwgcXVvdGVTdHJpbmdzID0gZmFsc2UpIHtcbiAgaWYgKHZhbCA9PSBudWxsIHx8IHZhbCA9PT0gdHJ1ZSB8fCB2YWwgPT09IGZhbHNlKSByZXR1cm4gJycgKyB2YWw7XG4gIGNvbnN0IHR5cGVPZiA9IHR5cGVvZiB2YWw7XG4gIGlmICh0eXBlT2YgPT09ICdudW1iZXInKSByZXR1cm4gcHJpbnROdW1iZXIodmFsKTtcbiAgaWYgKHR5cGVPZiA9PT0gJ3N0cmluZycpIHJldHVybiBxdW90ZVN0cmluZ3MgPyBgXCIke3ZhbH1cImAgOiB2YWw7XG4gIGlmICh0eXBlT2YgPT09ICdmdW5jdGlvbicpIHJldHVybiAnW0Z1bmN0aW9uICcgKyAodmFsLm5hbWUgfHwgJ2Fub255bW91cycpICsgJ10nO1xuICBpZiAodHlwZU9mID09PSAnc3ltYm9sJykgcmV0dXJuIHN5bWJvbFRvU3RyaW5nLmNhbGwodmFsKS5yZXBsYWNlKFNZTUJPTF9SRUdFWFAsICdTeW1ib2woJDEpJyk7XG4gIGNvbnN0IHRhZyA9IHRvU3RyaW5nLmNhbGwodmFsKS5zbGljZSg4LCAtMSk7XG4gIGlmICh0YWcgPT09ICdEYXRlJykgcmV0dXJuIGlzTmFOKHZhbC5nZXRUaW1lKCkpID8gJycgKyB2YWwgOiB2YWwudG9JU09TdHJpbmcodmFsKTtcbiAgaWYgKHRhZyA9PT0gJ0Vycm9yJyB8fCB2YWwgaW5zdGFuY2VvZiBFcnJvcikgcmV0dXJuICdbJyArIGVycm9yVG9TdHJpbmcuY2FsbCh2YWwpICsgJ10nO1xuICBpZiAodGFnID09PSAnUmVnRXhwJykgcmV0dXJuIHJlZ0V4cFRvU3RyaW5nLmNhbGwodmFsKTtcbiAgcmV0dXJuIG51bGw7XG59XG5mdW5jdGlvbiBwcmludFZhbHVlKHZhbHVlLCBxdW90ZVN0cmluZ3MpIHtcbiAgbGV0IHJlc3VsdCA9IHByaW50U2ltcGxlVmFsdWUodmFsdWUsIHF1b3RlU3RyaW5ncyk7XG4gIGlmIChyZXN1bHQgIT09IG51bGwpIHJldHVybiByZXN1bHQ7XG4gIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSwgZnVuY3Rpb24gKGtleSwgdmFsdWUpIHtcbiAgICBsZXQgcmVzdWx0ID0gcHJpbnRTaW1wbGVWYWx1ZSh0aGlzW2tleV0sIHF1b3RlU3RyaW5ncyk7XG4gICAgaWYgKHJlc3VsdCAhPT0gbnVsbCkgcmV0dXJuIHJlc3VsdDtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH0sIDIpO1xufVxuXG5mdW5jdGlvbiB0b0FycmF5KHZhbHVlKSB7XG4gIHJldHVybiB2YWx1ZSA9PSBudWxsID8gW10gOiBbXS5jb25jYXQodmFsdWUpO1xufVxuXG5sZXQgX1N5bWJvbCR0b1N0cmluZ1RhZywgX1N5bWJvbCRoYXNJbnN0YW5jZSwgX1N5bWJvbCR0b1N0cmluZ1RhZzI7XG5sZXQgc3RyUmVnID0gL1xcJFxce1xccyooXFx3KylcXHMqXFx9L2c7XG5fU3ltYm9sJHRvU3RyaW5nVGFnID0gU3ltYm9sLnRvU3RyaW5nVGFnO1xuY2xhc3MgVmFsaWRhdGlvbkVycm9yTm9TdGFjayB7XG4gIGNvbnN0cnVjdG9yKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSkge1xuICAgIHRoaXMubmFtZSA9IHZvaWQgMDtcbiAgICB0aGlzLm1lc3NhZ2UgPSB2b2lkIDA7XG4gICAgdGhpcy52YWx1ZSA9IHZvaWQgMDtcbiAgICB0aGlzLnBhdGggPSB2b2lkIDA7XG4gICAgdGhpcy50eXBlID0gdm9pZCAwO1xuICAgIHRoaXMucGFyYW1zID0gdm9pZCAwO1xuICAgIHRoaXMuZXJyb3JzID0gdm9pZCAwO1xuICAgIHRoaXMuaW5uZXIgPSB2b2lkIDA7XG4gICAgdGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnXSA9ICdFcnJvcic7XG4gICAgdGhpcy5uYW1lID0gJ1ZhbGlkYXRpb25FcnJvcic7XG4gICAgdGhpcy52YWx1ZSA9IHZhbHVlO1xuICAgIHRoaXMucGF0aCA9IGZpZWxkO1xuICAgIHRoaXMudHlwZSA9IHR5cGU7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLmlubmVyID0gW107XG4gICAgdG9BcnJheShlcnJvck9yRXJyb3JzKS5mb3JFYWNoKGVyciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkge1xuICAgICAgICB0aGlzLmVycm9ycy5wdXNoKC4uLmVyci5lcnJvcnMpO1xuICAgICAgICBjb25zdCBpbm5lckVycm9ycyA9IGVyci5pbm5lci5sZW5ndGggPyBlcnIuaW5uZXIgOiBbZXJyXTtcbiAgICAgICAgdGhpcy5pbm5lci5wdXNoKC4uLmlubmVyRXJyb3JzKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHRoaXMuZXJyb3JzLnB1c2goZXJyKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLm1lc3NhZ2UgPSB0aGlzLmVycm9ycy5sZW5ndGggPiAxID8gYCR7dGhpcy5lcnJvcnMubGVuZ3RofSBlcnJvcnMgb2NjdXJyZWRgIDogdGhpcy5lcnJvcnNbMF07XG4gIH1cbn1cbl9TeW1ib2wkaGFzSW5zdGFuY2UgPSBTeW1ib2wuaGFzSW5zdGFuY2U7XG5fU3ltYm9sJHRvU3RyaW5nVGFnMiA9IFN5bWJvbC50b1N0cmluZ1RhZztcbmNsYXNzIFZhbGlkYXRpb25FcnJvciBleHRlbmRzIEVycm9yIHtcbiAgc3RhdGljIGZvcm1hdEVycm9yKG1lc3NhZ2UsIHBhcmFtcykge1xuICAgIC8vIEF0dGVtcHQgdG8gbWFrZSB0aGUgcGF0aCBtb3JlIGZyaWVuZGx5IGZvciBlcnJvciBtZXNzYWdlIGludGVycG9sYXRpb24uXG4gICAgY29uc3QgcGF0aCA9IHBhcmFtcy5sYWJlbCB8fCBwYXJhbXMucGF0aCB8fCAndGhpcyc7XG4gICAgLy8gU3RvcmUgdGhlIG9yaWdpbmFsIHBhdGggdW5kZXIgYG9yaWdpbmFsUGF0aGAgc28gaXQgaXNuJ3QgbG9zdCB0byBjdXN0b21cbiAgICAvLyBtZXNzYWdlIGZ1bmN0aW9uczsgZS5nLiwgb25lcyBwcm92aWRlZCBpbiBgc2V0TG9jYWxlKClgIGNhbGxzLlxuICAgIHBhcmFtcyA9IE9iamVjdC5hc3NpZ24oe30sIHBhcmFtcywge1xuICAgICAgcGF0aCxcbiAgICAgIG9yaWdpbmFsUGF0aDogcGFyYW1zLnBhdGhcbiAgICB9KTtcbiAgICBpZiAodHlwZW9mIG1lc3NhZ2UgPT09ICdzdHJpbmcnKSByZXR1cm4gbWVzc2FnZS5yZXBsYWNlKHN0clJlZywgKF8sIGtleSkgPT4gcHJpbnRWYWx1ZShwYXJhbXNba2V5XSkpO1xuICAgIGlmICh0eXBlb2YgbWVzc2FnZSA9PT0gJ2Z1bmN0aW9uJykgcmV0dXJuIG1lc3NhZ2UocGFyYW1zKTtcbiAgICByZXR1cm4gbWVzc2FnZTtcbiAgfVxuICBzdGF0aWMgaXNFcnJvcihlcnIpIHtcbiAgICByZXR1cm4gZXJyICYmIGVyci5uYW1lID09PSAnVmFsaWRhdGlvbkVycm9yJztcbiAgfVxuICBjb25zdHJ1Y3RvcihlcnJvck9yRXJyb3JzLCB2YWx1ZSwgZmllbGQsIHR5cGUsIGRpc2FibGVTdGFjaykge1xuICAgIGNvbnN0IGVycm9yTm9TdGFjayA9IG5ldyBWYWxpZGF0aW9uRXJyb3JOb1N0YWNrKGVycm9yT3JFcnJvcnMsIHZhbHVlLCBmaWVsZCwgdHlwZSk7XG4gICAgaWYgKGRpc2FibGVTdGFjaykge1xuICAgICAgcmV0dXJuIGVycm9yTm9TdGFjaztcbiAgICB9XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLnZhbHVlID0gdm9pZCAwO1xuICAgIHRoaXMucGF0aCA9IHZvaWQgMDtcbiAgICB0aGlzLnR5cGUgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXJhbXMgPSB2b2lkIDA7XG4gICAgdGhpcy5lcnJvcnMgPSBbXTtcbiAgICB0aGlzLmlubmVyID0gW107XG4gICAgdGhpc1tfU3ltYm9sJHRvU3RyaW5nVGFnMl0gPSAnRXJyb3InO1xuICAgIHRoaXMubmFtZSA9IGVycm9yTm9TdGFjay5uYW1lO1xuICAgIHRoaXMubWVzc2FnZSA9IGVycm9yTm9TdGFjay5tZXNzYWdlO1xuICAgIHRoaXMudHlwZSA9IGVycm9yTm9TdGFjay50eXBlO1xuICAgIHRoaXMudmFsdWUgPSBlcnJvck5vU3RhY2sudmFsdWU7XG4gICAgdGhpcy5wYXRoID0gZXJyb3JOb1N0YWNrLnBhdGg7XG4gICAgdGhpcy5lcnJvcnMgPSBlcnJvck5vU3RhY2suZXJyb3JzO1xuICAgIHRoaXMuaW5uZXIgPSBlcnJvck5vU3RhY2suaW5uZXI7XG4gICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XG4gICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSh0aGlzLCBWYWxpZGF0aW9uRXJyb3IpO1xuICAgIH1cbiAgfVxuICBzdGF0aWMgW19TeW1ib2wkaGFzSW5zdGFuY2VdKGluc3QpIHtcbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yTm9TdGFja1tTeW1ib2wuaGFzSW5zdGFuY2VdKGluc3QpIHx8IHN1cGVyW1N5bWJvbC5oYXNJbnN0YW5jZV0oaW5zdCk7XG4gIH1cbn1cblxubGV0IG1peGVkID0ge1xuICBkZWZhdWx0OiAnJHtwYXRofSBpcyBpbnZhbGlkJyxcbiAgcmVxdWlyZWQ6ICcke3BhdGh9IGlzIGEgcmVxdWlyZWQgZmllbGQnLFxuICBkZWZpbmVkOiAnJHtwYXRofSBtdXN0IGJlIGRlZmluZWQnLFxuICBub3ROdWxsOiAnJHtwYXRofSBjYW5ub3QgYmUgbnVsbCcsXG4gIG9uZU9mOiAnJHtwYXRofSBtdXN0IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczogJHt2YWx1ZXN9JyxcbiAgbm90T25lT2Y6ICcke3BhdGh9IG11c3Qgbm90IGJlIG9uZSBvZiB0aGUgZm9sbG93aW5nIHZhbHVlczogJHt2YWx1ZXN9JyxcbiAgbm90VHlwZTogKHtcbiAgICBwYXRoLFxuICAgIHR5cGUsXG4gICAgdmFsdWUsXG4gICAgb3JpZ2luYWxWYWx1ZVxuICB9KSA9PiB7XG4gICAgY29uc3QgY2FzdE1zZyA9IG9yaWdpbmFsVmFsdWUgIT0gbnVsbCAmJiBvcmlnaW5hbFZhbHVlICE9PSB2YWx1ZSA/IGAgKGNhc3QgZnJvbSB0aGUgdmFsdWUgXFxgJHtwcmludFZhbHVlKG9yaWdpbmFsVmFsdWUsIHRydWUpfVxcYCkuYCA6ICcuJztcbiAgICByZXR1cm4gdHlwZSAhPT0gJ21peGVkJyA/IGAke3BhdGh9IG11c3QgYmUgYSBcXGAke3R5cGV9XFxgIHR5cGUsIGAgKyBgYnV0IHRoZSBmaW5hbCB2YWx1ZSB3YXM6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYCArIGNhc3RNc2cgOiBgJHtwYXRofSBtdXN0IG1hdGNoIHRoZSBjb25maWd1cmVkIHR5cGUuIGAgKyBgVGhlIHZhbGlkYXRlZCB2YWx1ZSB3YXM6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYCArIGNhc3RNc2c7XG4gIH1cbn07XG5sZXQgc3RyaW5nID0ge1xuICBsZW5ndGg6ICcke3BhdGh9IG11c3QgYmUgZXhhY3RseSAke2xlbmd0aH0gY2hhcmFjdGVycycsXG4gIG1pbjogJyR7cGF0aH0gbXVzdCBiZSBhdCBsZWFzdCAke21pbn0gY2hhcmFjdGVycycsXG4gIG1heDogJyR7cGF0aH0gbXVzdCBiZSBhdCBtb3N0ICR7bWF4fSBjaGFyYWN0ZXJzJyxcbiAgbWF0Y2hlczogJyR7cGF0aH0gbXVzdCBtYXRjaCB0aGUgZm9sbG93aW5nOiBcIiR7cmVnZXh9XCInLFxuICBlbWFpbDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIGVtYWlsJyxcbiAgdXJsOiAnJHtwYXRofSBtdXN0IGJlIGEgdmFsaWQgVVJMJyxcbiAgdXVpZDogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIFVVSUQnLFxuICBkYXRldGltZTogJyR7cGF0aH0gbXVzdCBiZSBhIHZhbGlkIElTTyBkYXRlLXRpbWUnLFxuICBkYXRldGltZV9wcmVjaXNpb246ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBJU08gZGF0ZS10aW1lIHdpdGggYSBzdWItc2Vjb25kIHByZWNpc2lvbiBvZiBleGFjdGx5ICR7cHJlY2lzaW9ufSBkaWdpdHMnLFxuICBkYXRldGltZV9vZmZzZXQ6ICcke3BhdGh9IG11c3QgYmUgYSB2YWxpZCBJU08gZGF0ZS10aW1lIHdpdGggVVRDIFwiWlwiIHRpbWV6b25lJyxcbiAgdHJpbTogJyR7cGF0aH0gbXVzdCBiZSBhIHRyaW1tZWQgc3RyaW5nJyxcbiAgbG93ZXJjYXNlOiAnJHtwYXRofSBtdXN0IGJlIGEgbG93ZXJjYXNlIHN0cmluZycsXG4gIHVwcGVyY2FzZTogJyR7cGF0aH0gbXVzdCBiZSBhIHVwcGVyIGNhc2Ugc3RyaW5nJ1xufTtcbmxldCBudW1iZXIgPSB7XG4gIG1pbjogJyR7cGF0aH0gbXVzdCBiZSBncmVhdGVyIHRoYW4gb3IgZXF1YWwgdG8gJHttaW59JyxcbiAgbWF4OiAnJHtwYXRofSBtdXN0IGJlIGxlc3MgdGhhbiBvciBlcXVhbCB0byAke21heH0nLFxuICBsZXNzVGhhbjogJyR7cGF0aH0gbXVzdCBiZSBsZXNzIHRoYW4gJHtsZXNzfScsXG4gIG1vcmVUaGFuOiAnJHtwYXRofSBtdXN0IGJlIGdyZWF0ZXIgdGhhbiAke21vcmV9JyxcbiAgcG9zaXRpdmU6ICcke3BhdGh9IG11c3QgYmUgYSBwb3NpdGl2ZSBudW1iZXInLFxuICBuZWdhdGl2ZTogJyR7cGF0aH0gbXVzdCBiZSBhIG5lZ2F0aXZlIG51bWJlcicsXG4gIGludGVnZXI6ICcke3BhdGh9IG11c3QgYmUgYW4gaW50ZWdlcidcbn07XG5sZXQgZGF0ZSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlIGxhdGVyIHRoYW4gJHttaW59JyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGJlIGF0IGVhcmxpZXIgdGhhbiAke21heH0nXG59O1xubGV0IGJvb2xlYW4gPSB7XG4gIGlzVmFsdWU6ICcke3BhdGh9IGZpZWxkIG11c3QgYmUgJHt2YWx1ZX0nXG59O1xubGV0IG9iamVjdCA9IHtcbiAgbm9Vbmtub3duOiAnJHtwYXRofSBmaWVsZCBoYXMgdW5zcGVjaWZpZWQga2V5czogJHt1bmtub3dufScsXG4gIGV4YWN0OiAnJHtwYXRofSBvYmplY3QgY29udGFpbnMgdW5rbm93biBwcm9wZXJ0aWVzOiAke3Byb3BlcnRpZXN9J1xufTtcbmxldCBhcnJheSA9IHtcbiAgbWluOiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgYXQgbGVhc3QgJHttaW59IGl0ZW1zJyxcbiAgbWF4OiAnJHtwYXRofSBmaWVsZCBtdXN0IGhhdmUgbGVzcyB0aGFuIG9yIGVxdWFsIHRvICR7bWF4fSBpdGVtcycsXG4gIGxlbmd0aDogJyR7cGF0aH0gbXVzdCBoYXZlICR7bGVuZ3RofSBpdGVtcydcbn07XG5sZXQgdHVwbGUgPSB7XG4gIG5vdFR5cGU6IHBhcmFtcyA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgcGF0aCxcbiAgICAgIHZhbHVlLFxuICAgICAgc3BlY1xuICAgIH0gPSBwYXJhbXM7XG4gICAgY29uc3QgdHlwZUxlbiA9IHNwZWMudHlwZXMubGVuZ3RoO1xuICAgIGlmIChBcnJheS5pc0FycmF5KHZhbHVlKSkge1xuICAgICAgaWYgKHZhbHVlLmxlbmd0aCA8IHR5cGVMZW4pIHJldHVybiBgJHtwYXRofSB0dXBsZSB2YWx1ZSBoYXMgdG9vIGZldyBpdGVtcywgZXhwZWN0ZWQgYSBsZW5ndGggb2YgJHt0eXBlTGVufSBidXQgZ290ICR7dmFsdWUubGVuZ3RofSBmb3IgdmFsdWU6IFxcYCR7cHJpbnRWYWx1ZSh2YWx1ZSwgdHJ1ZSl9XFxgYDtcbiAgICAgIGlmICh2YWx1ZS5sZW5ndGggPiB0eXBlTGVuKSByZXR1cm4gYCR7cGF0aH0gdHVwbGUgdmFsdWUgaGFzIHRvbyBtYW55IGl0ZW1zLCBleHBlY3RlZCBhIGxlbmd0aCBvZiAke3R5cGVMZW59IGJ1dCBnb3QgJHt2YWx1ZS5sZW5ndGh9IGZvciB2YWx1ZTogXFxgJHtwcmludFZhbHVlKHZhbHVlLCB0cnVlKX1cXGBgO1xuICAgIH1cbiAgICByZXR1cm4gVmFsaWRhdGlvbkVycm9yLmZvcm1hdEVycm9yKG1peGVkLm5vdFR5cGUsIHBhcmFtcyk7XG4gIH1cbn07XG52YXIgbG9jYWxlID0gT2JqZWN0LmFzc2lnbihPYmplY3QuY3JlYXRlKG51bGwpLCB7XG4gIG1peGVkLFxuICBzdHJpbmcsXG4gIG51bWJlcixcbiAgZGF0ZSxcbiAgb2JqZWN0LFxuICBhcnJheSxcbiAgYm9vbGVhbixcbiAgdHVwbGVcbn0pO1xuXG5jb25zdCBpc1NjaGVtYSA9IG9iaiA9PiBvYmogJiYgb2JqLl9faXNZdXBTY2hlbWFfXztcblxuY2xhc3MgQ29uZGl0aW9uIHtcbiAgc3RhdGljIGZyb21PcHRpb25zKHJlZnMsIGNvbmZpZykge1xuICAgIGlmICghY29uZmlnLnRoZW4gJiYgIWNvbmZpZy5vdGhlcndpc2UpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2VpdGhlciBgdGhlbjpgIG9yIGBvdGhlcndpc2U6YCBpcyByZXF1aXJlZCBmb3IgYHdoZW4oKWAgY29uZGl0aW9ucycpO1xuICAgIGxldCB7XG4gICAgICBpcyxcbiAgICAgIHRoZW4sXG4gICAgICBvdGhlcndpc2VcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCBjaGVjayA9IHR5cGVvZiBpcyA9PT0gJ2Z1bmN0aW9uJyA/IGlzIDogKC4uLnZhbHVlcykgPT4gdmFsdWVzLmV2ZXJ5KHZhbHVlID0+IHZhbHVlID09PSBpcyk7XG4gICAgcmV0dXJuIG5ldyBDb25kaXRpb24ocmVmcywgKHZhbHVlcywgc2NoZW1hKSA9PiB7XG4gICAgICB2YXIgX2JyYW5jaDtcbiAgICAgIGxldCBicmFuY2ggPSBjaGVjayguLi52YWx1ZXMpID8gdGhlbiA6IG90aGVyd2lzZTtcbiAgICAgIHJldHVybiAoX2JyYW5jaCA9IGJyYW5jaCA9PSBudWxsID8gdm9pZCAwIDogYnJhbmNoKHNjaGVtYSkpICE9IG51bGwgPyBfYnJhbmNoIDogc2NoZW1hO1xuICAgIH0pO1xuICB9XG4gIGNvbnN0cnVjdG9yKHJlZnMsIGJ1aWxkZXIpIHtcbiAgICB0aGlzLmZuID0gdm9pZCAwO1xuICAgIHRoaXMucmVmcyA9IHJlZnM7XG4gICAgdGhpcy5yZWZzID0gcmVmcztcbiAgICB0aGlzLmZuID0gYnVpbGRlcjtcbiAgfVxuICByZXNvbHZlKGJhc2UsIG9wdGlvbnMpIHtcbiAgICBsZXQgdmFsdWVzID0gdGhpcy5yZWZzLm1hcChyZWYgPT5cbiAgICAvLyBUT0RPOiA/IG9wZXJhdG9yIGhlcmU/XG4gICAgcmVmLmdldFZhbHVlKG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMudmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpKTtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5mbih2YWx1ZXMsIGJhc2UsIG9wdGlvbnMpO1xuICAgIGlmIChzY2hlbWEgPT09IHVuZGVmaW5lZCB8fFxuICAgIC8vIEB0cy1pZ25vcmUgdGhpcyBjYW4gYmUgYmFzZVxuICAgIHNjaGVtYSA9PT0gYmFzZSkge1xuICAgICAgcmV0dXJuIGJhc2U7XG4gICAgfVxuICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignY29uZGl0aW9ucyBtdXN0IHJldHVybiBhIHNjaGVtYSBvYmplY3QnKTtcbiAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gIH1cbn1cblxuY29uc3QgcHJlZml4ZXMgPSB7XG4gIGNvbnRleHQ6ICckJyxcbiAgdmFsdWU6ICcuJ1xufTtcbmZ1bmN0aW9uIGNyZWF0ZSQ5KGtleSwgb3B0aW9ucykge1xuICByZXR1cm4gbmV3IFJlZmVyZW5jZShrZXksIG9wdGlvbnMpO1xufVxuY2xhc3MgUmVmZXJlbmNlIHtcbiAgY29uc3RydWN0b3Ioa2V5LCBvcHRpb25zID0ge30pIHtcbiAgICB0aGlzLmtleSA9IHZvaWQgMDtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHZvaWQgMDtcbiAgICB0aGlzLmlzVmFsdWUgPSB2b2lkIDA7XG4gICAgdGhpcy5pc1NpYmxpbmcgPSB2b2lkIDA7XG4gICAgdGhpcy5wYXRoID0gdm9pZCAwO1xuICAgIHRoaXMuZ2V0dGVyID0gdm9pZCAwO1xuICAgIHRoaXMubWFwID0gdm9pZCAwO1xuICAgIGlmICh0eXBlb2Yga2V5ICE9PSAnc3RyaW5nJykgdGhyb3cgbmV3IFR5cGVFcnJvcigncmVmIG11c3QgYmUgYSBzdHJpbmcsIGdvdDogJyArIGtleSk7XG4gICAgdGhpcy5rZXkgPSBrZXkudHJpbSgpO1xuICAgIGlmIChrZXkgPT09ICcnKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdyZWYgbXVzdCBiZSBhIG5vbi1lbXB0eSBzdHJpbmcnKTtcbiAgICB0aGlzLmlzQ29udGV4dCA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy5jb250ZXh0O1xuICAgIHRoaXMuaXNWYWx1ZSA9IHRoaXMua2V5WzBdID09PSBwcmVmaXhlcy52YWx1ZTtcbiAgICB0aGlzLmlzU2libGluZyA9ICF0aGlzLmlzQ29udGV4dCAmJiAhdGhpcy5pc1ZhbHVlO1xuICAgIGxldCBwcmVmaXggPSB0aGlzLmlzQ29udGV4dCA/IHByZWZpeGVzLmNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyBwcmVmaXhlcy52YWx1ZSA6ICcnO1xuICAgIHRoaXMucGF0aCA9IHRoaXMua2V5LnNsaWNlKHByZWZpeC5sZW5ndGgpO1xuICAgIHRoaXMuZ2V0dGVyID0gdGhpcy5wYXRoICYmIGdldHRlcih0aGlzLnBhdGgsIHRydWUpO1xuICAgIHRoaXMubWFwID0gb3B0aW9ucy5tYXA7XG4gIH1cbiAgZ2V0VmFsdWUodmFsdWUsIHBhcmVudCwgY29udGV4dCkge1xuICAgIGxldCByZXN1bHQgPSB0aGlzLmlzQ29udGV4dCA/IGNvbnRleHQgOiB0aGlzLmlzVmFsdWUgPyB2YWx1ZSA6IHBhcmVudDtcbiAgICBpZiAodGhpcy5nZXR0ZXIpIHJlc3VsdCA9IHRoaXMuZ2V0dGVyKHJlc3VsdCB8fCB7fSk7XG4gICAgaWYgKHRoaXMubWFwKSByZXN1bHQgPSB0aGlzLm1hcChyZXN1bHQpO1xuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cblxuICAvKipcbiAgICpcbiAgICogQHBhcmFtIHsqfSB2YWx1ZVxuICAgKiBAcGFyYW0ge09iamVjdH0gb3B0aW9uc1xuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMuY29udGV4dFxuICAgKiBAcGFyYW0ge09iamVjdD19IG9wdGlvbnMucGFyZW50XG4gICAqL1xuICBjYXN0KHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuZ2V0VmFsdWUodmFsdWUsIG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMucGFyZW50LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLmNvbnRleHQpO1xuICB9XG4gIHJlc29sdmUoKSB7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cbiAgZGVzY3JpYmUoKSB7XG4gICAgcmV0dXJuIHtcbiAgICAgIHR5cGU6ICdyZWYnLFxuICAgICAga2V5OiB0aGlzLmtleVxuICAgIH07XG4gIH1cbiAgdG9TdHJpbmcoKSB7XG4gICAgcmV0dXJuIGBSZWYoJHt0aGlzLmtleX0pYDtcbiAgfVxuICBzdGF0aWMgaXNSZWYodmFsdWUpIHtcbiAgICByZXR1cm4gdmFsdWUgJiYgdmFsdWUuX19pc1l1cFJlZjtcbiAgfVxufVxuXG4vLyBAdHMtaWdub3JlXG5SZWZlcmVuY2UucHJvdG90eXBlLl9faXNZdXBSZWYgPSB0cnVlO1xuXG5jb25zdCBpc0Fic2VudCA9IHZhbHVlID0+IHZhbHVlID09IG51bGw7XG5cbmZ1bmN0aW9uIGNyZWF0ZVZhbGlkYXRpb24oY29uZmlnKSB7XG4gIGZ1bmN0aW9uIHZhbGlkYXRlKHtcbiAgICB2YWx1ZSxcbiAgICBwYXRoID0gJycsXG4gICAgb3B0aW9ucyxcbiAgICBvcmlnaW5hbFZhbHVlLFxuICAgIHNjaGVtYVxuICB9LCBwYW5pYywgbmV4dCkge1xuICAgIGNvbnN0IHtcbiAgICAgIG5hbWUsXG4gICAgICB0ZXN0LFxuICAgICAgcGFyYW1zLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHNraXBBYnNlbnRcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB7XG4gICAgICBwYXJlbnQsXG4gICAgICBjb250ZXh0LFxuICAgICAgYWJvcnRFYXJseSA9IHNjaGVtYS5zcGVjLmFib3J0RWFybHksXG4gICAgICBkaXNhYmxlU3RhY2tUcmFjZSA9IHNjaGVtYS5zcGVjLmRpc2FibGVTdGFja1RyYWNlXG4gICAgfSA9IG9wdGlvbnM7XG4gICAgZnVuY3Rpb24gcmVzb2x2ZShpdGVtKSB7XG4gICAgICByZXR1cm4gUmVmZXJlbmNlLmlzUmVmKGl0ZW0pID8gaXRlbS5nZXRWYWx1ZSh2YWx1ZSwgcGFyZW50LCBjb250ZXh0KSA6IGl0ZW07XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNyZWF0ZUVycm9yKG92ZXJyaWRlcyA9IHt9KSB7XG4gICAgICBjb25zdCBuZXh0UGFyYW1zID0gT2JqZWN0LmFzc2lnbih7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgICBsYWJlbDogc2NoZW1hLnNwZWMubGFiZWwsXG4gICAgICAgIHBhdGg6IG92ZXJyaWRlcy5wYXRoIHx8IHBhdGgsXG4gICAgICAgIHNwZWM6IHNjaGVtYS5zcGVjLFxuICAgICAgICBkaXNhYmxlU3RhY2tUcmFjZTogb3ZlcnJpZGVzLmRpc2FibGVTdGFja1RyYWNlIHx8IGRpc2FibGVTdGFja1RyYWNlXG4gICAgICB9LCBwYXJhbXMsIG92ZXJyaWRlcy5wYXJhbXMpO1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMobmV4dFBhcmFtcykpIG5leHRQYXJhbXNba2V5XSA9IHJlc29sdmUobmV4dFBhcmFtc1trZXldKTtcbiAgICAgIGNvbnN0IGVycm9yID0gbmV3IFZhbGlkYXRpb25FcnJvcihWYWxpZGF0aW9uRXJyb3IuZm9ybWF0RXJyb3Iob3ZlcnJpZGVzLm1lc3NhZ2UgfHwgbWVzc2FnZSwgbmV4dFBhcmFtcyksIHZhbHVlLCBuZXh0UGFyYW1zLnBhdGgsIG92ZXJyaWRlcy50eXBlIHx8IG5hbWUsIG5leHRQYXJhbXMuZGlzYWJsZVN0YWNrVHJhY2UpO1xuICAgICAgZXJyb3IucGFyYW1zID0gbmV4dFBhcmFtcztcbiAgICAgIHJldHVybiBlcnJvcjtcbiAgICB9XG4gICAgY29uc3QgaW52YWxpZCA9IGFib3J0RWFybHkgPyBwYW5pYyA6IG5leHQ7XG4gICAgbGV0IGN0eCA9IHtcbiAgICAgIHBhdGgsXG4gICAgICBwYXJlbnQsXG4gICAgICB0eXBlOiBuYW1lLFxuICAgICAgZnJvbTogb3B0aW9ucy5mcm9tLFxuICAgICAgY3JlYXRlRXJyb3IsXG4gICAgICByZXNvbHZlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICBzY2hlbWFcbiAgICB9O1xuICAgIGNvbnN0IGhhbmRsZVJlc3VsdCA9IHZhbGlkT3JFcnJvciA9PiB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IodmFsaWRPckVycm9yKSkgaW52YWxpZCh2YWxpZE9yRXJyb3IpO2Vsc2UgaWYgKCF2YWxpZE9yRXJyb3IpIGludmFsaWQoY3JlYXRlRXJyb3IoKSk7ZWxzZSBuZXh0KG51bGwpO1xuICAgIH07XG4gICAgY29uc3QgaGFuZGxlRXJyb3IgPSBlcnIgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycikpIGludmFsaWQoZXJyKTtlbHNlIHBhbmljKGVycik7XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRTa2lwID0gc2tpcEFic2VudCAmJiBpc0Fic2VudCh2YWx1ZSk7XG4gICAgaWYgKHNob3VsZFNraXApIHtcbiAgICAgIHJldHVybiBoYW5kbGVSZXN1bHQodHJ1ZSk7XG4gICAgfVxuICAgIGxldCByZXN1bHQ7XG4gICAgdHJ5IHtcbiAgICAgIHZhciBfcmVzdWx0O1xuICAgICAgcmVzdWx0ID0gdGVzdC5jYWxsKGN0eCwgdmFsdWUsIGN0eCk7XG4gICAgICBpZiAodHlwZW9mICgoX3Jlc3VsdCA9IHJlc3VsdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZXN1bHQudGhlbikgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgaWYgKG9wdGlvbnMuc3luYykge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihgVmFsaWRhdGlvbiB0ZXN0IG9mIHR5cGU6IFwiJHtjdHgudHlwZX1cIiByZXR1cm5lZCBhIFByb21pc2UgZHVyaW5nIGEgc3luY2hyb25vdXMgdmFsaWRhdGUuIGAgKyBgVGhpcyB0ZXN0IHdpbGwgZmluaXNoIGFmdGVyIHRoZSB2YWxpZGF0ZSBjYWxsIGhhcyByZXR1cm5lZGApO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUocmVzdWx0KS50aGVuKGhhbmRsZVJlc3VsdCwgaGFuZGxlRXJyb3IpO1xuICAgICAgfVxuICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgaGFuZGxlRXJyb3IoZXJyKTtcbiAgICAgIHJldHVybjtcbiAgICB9XG4gICAgaGFuZGxlUmVzdWx0KHJlc3VsdCk7XG4gIH1cbiAgdmFsaWRhdGUuT1BUSU9OUyA9IGNvbmZpZztcbiAgcmV0dXJuIHZhbGlkYXRlO1xufVxuXG5mdW5jdGlvbiBnZXRJbihzY2hlbWEsIHBhdGgsIHZhbHVlLCBjb250ZXh0ID0gdmFsdWUpIHtcbiAgbGV0IHBhcmVudCwgbGFzdFBhcnQsIGxhc3RQYXJ0RGVidWc7XG5cbiAgLy8gcm9vdCBwYXRoOiAnJ1xuICBpZiAoIXBhdGgpIHJldHVybiB7XG4gICAgcGFyZW50LFxuICAgIHBhcmVudFBhdGg6IHBhdGgsXG4gICAgc2NoZW1hXG4gIH07XG4gIGZvckVhY2gocGF0aCwgKF9wYXJ0LCBpc0JyYWNrZXQsIGlzQXJyYXkpID0+IHtcbiAgICBsZXQgcGFydCA9IGlzQnJhY2tldCA/IF9wYXJ0LnNsaWNlKDEsIF9wYXJ0Lmxlbmd0aCAtIDEpIDogX3BhcnQ7XG4gICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUoe1xuICAgICAgY29udGV4dCxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlXG4gICAgfSk7XG4gICAgbGV0IGlzVHVwbGUgPSBzY2hlbWEudHlwZSA9PT0gJ3R1cGxlJztcbiAgICBsZXQgaWR4ID0gaXNBcnJheSA/IHBhcnNlSW50KHBhcnQsIDEwKSA6IDA7XG4gICAgaWYgKHNjaGVtYS5pbm5lclR5cGUgfHwgaXNUdXBsZSkge1xuICAgICAgaWYgKGlzVHVwbGUgJiYgIWlzQXJyYXkpIHRocm93IG5ldyBFcnJvcihgWXVwLnJlYWNoIGNhbm5vdCBpbXBsaWNpdGx5IGluZGV4IGludG8gYSB0dXBsZSB0eXBlLiB0aGUgcGF0aCBwYXJ0IFwiJHtsYXN0UGFydERlYnVnfVwiIG11c3QgY29udGFpbiBhbiBpbmRleCB0byB0aGUgdHVwbGUgZWxlbWVudCwgZS5nLiBcIiR7bGFzdFBhcnREZWJ1Z31bMF1cImApO1xuICAgICAgaWYgKHZhbHVlICYmIGlkeCA+PSB2YWx1ZS5sZW5ndGgpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBZdXAucmVhY2ggY2Fubm90IHJlc29sdmUgYW4gYXJyYXkgaXRlbSBhdCBpbmRleDogJHtfcGFydH0sIGluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYGJlY2F1c2UgdGhlcmUgaXMgbm8gdmFsdWUgYXQgdGhhdCBpbmRleC4gYCk7XG4gICAgICB9XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbaWR4XTtcbiAgICAgIHNjaGVtYSA9IGlzVHVwbGUgPyBzY2hlbWEuc3BlYy50eXBlc1tpZHhdIDogc2NoZW1hLmlubmVyVHlwZTtcbiAgICB9XG5cbiAgICAvLyBzb21ldGltZXMgdGhlIGFycmF5IGluZGV4IHBhcnQgb2YgYSBwYXRoIGRvZXNuJ3QgZXhpc3Q6IFwibmVzdGVkLmFyci5jaGlsZFwiXG4gICAgLy8gaW4gdGhlc2UgY2FzZXMgdGhlIGN1cnJlbnQgcGFydCBpcyB0aGUgbmV4dCBzY2hlbWEgYW5kIHNob3VsZCBiZSBwcm9jZXNzZWRcbiAgICAvLyBpbiB0aGlzIGl0ZXJhdGlvbi4gRm9yIGNhc2VzIHdoZXJlIHRoZSBpbmRleCBzaWduYXR1cmUgaXMgaW5jbHVkZWQgdGhpc1xuICAgIC8vIGNoZWNrIHdpbGwgZmFpbCBhbmQgd2UnbGwgaGFuZGxlIHRoZSBgY2hpbGRgIHBhcnQgb24gdGhlIG5leHQgaXRlcmF0aW9uIGxpa2Ugbm9ybWFsXG4gICAgaWYgKCFpc0FycmF5KSB7XG4gICAgICBpZiAoIXNjaGVtYS5maWVsZHMgfHwgIXNjaGVtYS5maWVsZHNbcGFydF0pIHRocm93IG5ldyBFcnJvcihgVGhlIHNjaGVtYSBkb2VzIG5vdCBjb250YWluIHRoZSBwYXRoOiAke3BhdGh9LiBgICsgYChmYWlsZWQgYXQ6ICR7bGFzdFBhcnREZWJ1Z30gd2hpY2ggaXMgYSB0eXBlOiBcIiR7c2NoZW1hLnR5cGV9XCIpYCk7XG4gICAgICBwYXJlbnQgPSB2YWx1ZTtcbiAgICAgIHZhbHVlID0gdmFsdWUgJiYgdmFsdWVbcGFydF07XG4gICAgICBzY2hlbWEgPSBzY2hlbWEuZmllbGRzW3BhcnRdO1xuICAgIH1cbiAgICBsYXN0UGFydCA9IHBhcnQ7XG4gICAgbGFzdFBhcnREZWJ1ZyA9IGlzQnJhY2tldCA/ICdbJyArIF9wYXJ0ICsgJ10nIDogJy4nICsgX3BhcnQ7XG4gIH0pO1xuICByZXR1cm4ge1xuICAgIHNjaGVtYSxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aDogbGFzdFBhcnRcbiAgfTtcbn1cbmZ1bmN0aW9uIHJlYWNoKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpIHtcbiAgcmV0dXJuIGdldEluKG9iaiwgcGF0aCwgdmFsdWUsIGNvbnRleHQpLnNjaGVtYTtcbn1cblxuY2xhc3MgUmVmZXJlbmNlU2V0IGV4dGVuZHMgU2V0IHtcbiAgZGVzY3JpYmUoKSB7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgZGVzY3JpcHRpb24ucHVzaChSZWZlcmVuY2UuaXNSZWYoaXRlbSkgPyBpdGVtLmRlc2NyaWJlKCkgOiBpdGVtKTtcbiAgICB9XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG4gIHJlc29sdmVBbGwocmVzb2x2ZSkge1xuICAgIGxldCByZXN1bHQgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGl0ZW0gb2YgdGhpcy52YWx1ZXMoKSkge1xuICAgICAgcmVzdWx0LnB1c2gocmVzb2x2ZShpdGVtKSk7XG4gICAgfVxuICAgIHJldHVybiByZXN1bHQ7XG4gIH1cbiAgY2xvbmUoKSB7XG4gICAgcmV0dXJuIG5ldyBSZWZlcmVuY2VTZXQodGhpcy52YWx1ZXMoKSk7XG4gIH1cbiAgbWVyZ2UobmV3SXRlbXMsIHJlbW92ZUl0ZW1zKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXdJdGVtcy5mb3JFYWNoKHZhbHVlID0+IG5leHQuYWRkKHZhbHVlKSk7XG4gICAgcmVtb3ZlSXRlbXMuZm9yRWFjaCh2YWx1ZSA9PiBuZXh0LmRlbGV0ZSh2YWx1ZSkpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbi8vIHR3ZWFrZWQgZnJvbSBodHRwczovL2dpdGh1Yi5jb20vS2VsaW4yMDI1L25hbm9jbG9uZS9ibG9iLzBhYmViNzYzNWJkYTliNjhlZjIyNzcwOTNmNzZkYmUzYmYzOTQ4ZTEvc3JjL2luZGV4LmpzXG5mdW5jdGlvbiBjbG9uZShzcmMsIHNlZW4gPSBuZXcgTWFwKCkpIHtcbiAgaWYgKGlzU2NoZW1hKHNyYykgfHwgIXNyYyB8fCB0eXBlb2Ygc3JjICE9PSAnb2JqZWN0JykgcmV0dXJuIHNyYztcbiAgaWYgKHNlZW4uaGFzKHNyYykpIHJldHVybiBzZWVuLmdldChzcmMpO1xuICBsZXQgY29weTtcbiAgaWYgKHNyYyBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAvLyBEYXRlXG4gICAgY29weSA9IG5ldyBEYXRlKHNyYy5nZXRUaW1lKCkpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgUmVnRXhwKSB7XG4gICAgLy8gUmVnRXhwXG4gICAgY29weSA9IG5ldyBSZWdFeHAoc3JjKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICB9IGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoc3JjKSkge1xuICAgIC8vIEFycmF5XG4gICAgY29weSA9IG5ldyBBcnJheShzcmMubGVuZ3RoKTtcbiAgICBzZWVuLnNldChzcmMsIGNvcHkpO1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgc3JjLmxlbmd0aDsgaSsrKSBjb3B5W2ldID0gY2xvbmUoc3JjW2ldLCBzZWVuKTtcbiAgfSBlbHNlIGlmIChzcmMgaW5zdGFuY2VvZiBNYXApIHtcbiAgICAvLyBNYXBcbiAgICBjb3B5ID0gbmV3IE1hcCgpO1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2Ygc3JjLmVudHJpZXMoKSkgY29weS5zZXQoaywgY2xvbmUodiwgc2VlbikpO1xuICB9IGVsc2UgaWYgKHNyYyBpbnN0YW5jZW9mIFNldCkge1xuICAgIC8vIFNldFxuICAgIGNvcHkgPSBuZXcgU2V0KCk7XG4gICAgc2Vlbi5zZXQoc3JjLCBjb3B5KTtcbiAgICBmb3IgKGNvbnN0IHYgb2Ygc3JjKSBjb3B5LmFkZChjbG9uZSh2LCBzZWVuKSk7XG4gIH0gZWxzZSBpZiAoc3JjIGluc3RhbmNlb2YgT2JqZWN0KSB7XG4gICAgLy8gT2JqZWN0XG4gICAgY29weSA9IHt9O1xuICAgIHNlZW4uc2V0KHNyYywgY29weSk7XG4gICAgZm9yIChjb25zdCBbaywgdl0gb2YgT2JqZWN0LmVudHJpZXMoc3JjKSkgY29weVtrXSA9IGNsb25lKHYsIHNlZW4pO1xuICB9IGVsc2Uge1xuICAgIHRocm93IEVycm9yKGBVbmFibGUgdG8gY2xvbmUgJHtzcmN9YCk7XG4gIH1cbiAgcmV0dXJuIGNvcHk7XG59XG5cbi8vIElmIGBDdXN0b21TY2hlbWFNZXRhYCBpc24ndCBleHRlbmRlZCB3aXRoIGFueSBrZXlzLCB3ZSdsbCBmYWxsIGJhY2sgdG8gYVxuLy8gbG9vc2UgUmVjb3JkIGRlZmluaXRpb24gYWxsb3dpbmcgZnJlZSBmb3JtIHVzYWdlLlxuY2xhc3MgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Iob3B0aW9ucykge1xuICAgIHRoaXMudHlwZSA9IHZvaWQgMDtcbiAgICB0aGlzLmRlcHMgPSBbXTtcbiAgICB0aGlzLnRlc3RzID0gdm9pZCAwO1xuICAgIHRoaXMudHJhbnNmb3JtcyA9IHZvaWQgMDtcbiAgICB0aGlzLmNvbmRpdGlvbnMgPSBbXTtcbiAgICB0aGlzLl9tdXRhdGUgPSB2b2lkIDA7XG4gICAgdGhpcy5pbnRlcm5hbFRlc3RzID0ge307XG4gICAgdGhpcy5fd2hpdGVsaXN0ID0gbmV3IFJlZmVyZW5jZVNldCgpO1xuICAgIHRoaXMuX2JsYWNrbGlzdCA9IG5ldyBSZWZlcmVuY2VTZXQoKTtcbiAgICB0aGlzLmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcbiAgICB0aGlzLl90eXBlQ2hlY2sgPSB2b2lkIDA7XG4gICAgdGhpcy5zcGVjID0gdm9pZCAwO1xuICAgIHRoaXMudGVzdHMgPSBbXTtcbiAgICB0aGlzLnRyYW5zZm9ybXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnR5cGVFcnJvcihtaXhlZC5ub3RUeXBlKTtcbiAgICB9KTtcbiAgICB0aGlzLnR5cGUgPSBvcHRpb25zLnR5cGU7XG4gICAgdGhpcy5fdHlwZUNoZWNrID0gb3B0aW9ucy5jaGVjaztcbiAgICB0aGlzLnNwZWMgPSBPYmplY3QuYXNzaWduKHtcbiAgICAgIHN0cmlwOiBmYWxzZSxcbiAgICAgIHN0cmljdDogZmFsc2UsXG4gICAgICBhYm9ydEVhcmx5OiB0cnVlLFxuICAgICAgcmVjdXJzaXZlOiB0cnVlLFxuICAgICAgZGlzYWJsZVN0YWNrVHJhY2U6IGZhbHNlLFxuICAgICAgbnVsbGFibGU6IGZhbHNlLFxuICAgICAgb3B0aW9uYWw6IHRydWUsXG4gICAgICBjb2VyY2U6IHRydWVcbiAgICB9LCBvcHRpb25zID09IG51bGwgPyB2b2lkIDAgOiBvcHRpb25zLnNwZWMpO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKHMgPT4ge1xuICAgICAgcy5ub25OdWxsYWJsZSgpO1xuICAgIH0pO1xuICB9XG5cbiAgLy8gVE9ETzogcmVtb3ZlXG4gIGdldCBfdHlwZSgpIHtcbiAgICByZXR1cm4gdGhpcy50eXBlO1xuICB9XG4gIGNsb25lKHNwZWMpIHtcbiAgICBpZiAodGhpcy5fbXV0YXRlKSB7XG4gICAgICBpZiAoc3BlYykgT2JqZWN0LmFzc2lnbih0aGlzLnNwZWMsIHNwZWMpO1xuICAgICAgcmV0dXJuIHRoaXM7XG4gICAgfVxuXG4gICAgLy8gaWYgdGhlIG5lc3RlZCB2YWx1ZSBpcyBhIHNjaGVtYSB3ZSBjYW4gc2tpcCBjbG9uaW5nLCBzaW5jZVxuICAgIC8vIHRoZXkgYXJlIGFscmVhZHkgaW1tdXRhYmxlXG4gICAgY29uc3QgbmV4dCA9IE9iamVjdC5jcmVhdGUoT2JqZWN0LmdldFByb3RvdHlwZU9mKHRoaXMpKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgdGhpcyBpcyByZWFkb25seVxuICAgIG5leHQudHlwZSA9IHRoaXMudHlwZTtcbiAgICBuZXh0Ll90eXBlQ2hlY2sgPSB0aGlzLl90eXBlQ2hlY2s7XG4gICAgbmV4dC5fd2hpdGVsaXN0ID0gdGhpcy5fd2hpdGVsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5fYmxhY2tsaXN0ID0gdGhpcy5fYmxhY2tsaXN0LmNsb25lKCk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5pbnRlcm5hbFRlc3RzKTtcbiAgICBuZXh0LmV4Y2x1c2l2ZVRlc3RzID0gT2JqZWN0LmFzc2lnbih7fSwgdGhpcy5leGNsdXNpdmVUZXN0cyk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHRoaXMgaXMgcmVhZG9ubHlcbiAgICBuZXh0LmRlcHMgPSBbLi4udGhpcy5kZXBzXTtcbiAgICBuZXh0LmNvbmRpdGlvbnMgPSBbLi4udGhpcy5jb25kaXRpb25zXTtcbiAgICBuZXh0LnRlc3RzID0gWy4uLnRoaXMudGVzdHNdO1xuICAgIG5leHQudHJhbnNmb3JtcyA9IFsuLi50aGlzLnRyYW5zZm9ybXNdO1xuICAgIG5leHQuc3BlYyA9IGNsb25lKE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYykpO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGxhYmVsKGxhYmVsKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLmxhYmVsID0gbGFiZWw7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbWV0YSguLi5hcmdzKSB7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAwKSByZXR1cm4gdGhpcy5zcGVjLm1ldGE7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLm1ldGEgPSBPYmplY3QuYXNzaWduKG5leHQuc3BlYy5tZXRhIHx8IHt9LCBhcmdzWzBdKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB3aXRoTXV0YXRpb24oZm4pIHtcbiAgICBsZXQgYmVmb3JlID0gdGhpcy5fbXV0YXRlO1xuICAgIHRoaXMuX211dGF0ZSA9IHRydWU7XG4gICAgbGV0IHJlc3VsdCA9IGZuKHRoaXMpO1xuICAgIHRoaXMuX211dGF0ZSA9IGJlZm9yZTtcbiAgICByZXR1cm4gcmVzdWx0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBpZiAoIXNjaGVtYSB8fCBzY2hlbWEgPT09IHRoaXMpIHJldHVybiB0aGlzO1xuICAgIGlmIChzY2hlbWEudHlwZSAhPT0gdGhpcy50eXBlICYmIHRoaXMudHlwZSAhPT0gJ21peGVkJykgdGhyb3cgbmV3IFR5cGVFcnJvcihgWW91IGNhbm5vdCBcXGBjb25jYXQoKVxcYCBzY2hlbWEncyBvZiBkaWZmZXJlbnQgdHlwZXM6ICR7dGhpcy50eXBlfSBhbmQgJHtzY2hlbWEudHlwZX1gKTtcbiAgICBsZXQgYmFzZSA9IHRoaXM7XG4gICAgbGV0IGNvbWJpbmVkID0gc2NoZW1hLmNsb25lKCk7XG4gICAgY29uc3QgbWVyZ2VkU3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2Uuc3BlYywgY29tYmluZWQuc3BlYyk7XG4gICAgY29tYmluZWQuc3BlYyA9IG1lcmdlZFNwZWM7XG4gICAgY29tYmluZWQuaW50ZXJuYWxUZXN0cyA9IE9iamVjdC5hc3NpZ24oe30sIGJhc2UuaW50ZXJuYWxUZXN0cywgY29tYmluZWQuaW50ZXJuYWxUZXN0cyk7XG5cbiAgICAvLyBtYW51YWxseSBtZXJnZSB0aGUgYmxhY2tsaXN0L3doaXRlbGlzdCAodGhlIG90aGVyIGBzY2hlbWFgIHRha2VzXG4gICAgLy8gcHJlY2VkZW5jZSBpbiBjYXNlIG9mIGNvbmZsaWN0cylcbiAgICBjb21iaW5lZC5fd2hpdGVsaXN0ID0gYmFzZS5fd2hpdGVsaXN0Lm1lcmdlKHNjaGVtYS5fd2hpdGVsaXN0LCBzY2hlbWEuX2JsYWNrbGlzdCk7XG4gICAgY29tYmluZWQuX2JsYWNrbGlzdCA9IGJhc2UuX2JsYWNrbGlzdC5tZXJnZShzY2hlbWEuX2JsYWNrbGlzdCwgc2NoZW1hLl93aGl0ZWxpc3QpO1xuXG4gICAgLy8gc3RhcnQgd2l0aCB0aGUgY3VycmVudCB0ZXN0c1xuICAgIGNvbWJpbmVkLnRlc3RzID0gYmFzZS50ZXN0cztcbiAgICBjb21iaW5lZC5leGNsdXNpdmVUZXN0cyA9IGJhc2UuZXhjbHVzaXZlVGVzdHM7XG5cbiAgICAvLyBtYW51YWxseSBhZGQgdGhlIG5ldyB0ZXN0cyB0byBlbnN1cmVcbiAgICAvLyB0aGUgZGVkdXBpbmcgbG9naWMgaXMgY29uc2lzdGVudFxuICAgIGNvbWJpbmVkLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIHNjaGVtYS50ZXN0cy5mb3JFYWNoKGZuID0+IHtcbiAgICAgICAgbmV4dC50ZXN0KGZuLk9QVElPTlMpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gICAgY29tYmluZWQudHJhbnNmb3JtcyA9IFsuLi5iYXNlLnRyYW5zZm9ybXMsIC4uLmNvbWJpbmVkLnRyYW5zZm9ybXNdO1xuICAgIHJldHVybiBjb21iaW5lZDtcbiAgfVxuICBpc1R5cGUodikge1xuICAgIGlmICh2ID09IG51bGwpIHtcbiAgICAgIGlmICh0aGlzLnNwZWMubnVsbGFibGUgJiYgdiA9PT0gbnVsbCkgcmV0dXJuIHRydWU7XG4gICAgICBpZiAodGhpcy5zcGVjLm9wdGlvbmFsICYmIHYgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRydWU7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIHJldHVybiB0aGlzLl90eXBlQ2hlY2sodik7XG4gIH1cbiAgcmVzb2x2ZShvcHRpb25zKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXM7XG4gICAgaWYgKHNjaGVtYS5jb25kaXRpb25zLmxlbmd0aCkge1xuICAgICAgbGV0IGNvbmRpdGlvbnMgPSBzY2hlbWEuY29uZGl0aW9ucztcbiAgICAgIHNjaGVtYSA9IHNjaGVtYS5jbG9uZSgpO1xuICAgICAgc2NoZW1hLmNvbmRpdGlvbnMgPSBbXTtcbiAgICAgIHNjaGVtYSA9IGNvbmRpdGlvbnMucmVkdWNlKChwcmV2U2NoZW1hLCBjb25kaXRpb24pID0+IGNvbmRpdGlvbi5yZXNvbHZlKHByZXZTY2hlbWEsIG9wdGlvbnMpLCBzY2hlbWEpO1xuICAgICAgc2NoZW1hID0gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWE7XG4gIH1cbiAgcmVzb2x2ZU9wdGlvbnMob3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRzdHJpY3QsIF9vcHRpb25zJGFib3J0RWFybHksIF9vcHRpb25zJHJlY3Vyc2l2ZSwgX29wdGlvbnMkZGlzYWJsZVN0YWNrO1xuICAgIHJldHVybiBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICBmcm9tOiBvcHRpb25zLmZyb20gfHwgW10sXG4gICAgICBzdHJpY3Q6IChfb3B0aW9ucyRzdHJpY3QgPSBvcHRpb25zLnN0cmljdCkgIT0gbnVsbCA/IF9vcHRpb25zJHN0cmljdCA6IHRoaXMuc3BlYy5zdHJpY3QsXG4gICAgICBhYm9ydEVhcmx5OiAoX29wdGlvbnMkYWJvcnRFYXJseSA9IG9wdGlvbnMuYWJvcnRFYXJseSkgIT0gbnVsbCA/IF9vcHRpb25zJGFib3J0RWFybHkgOiB0aGlzLnNwZWMuYWJvcnRFYXJseSxcbiAgICAgIHJlY3Vyc2l2ZTogKF9vcHRpb25zJHJlY3Vyc2l2ZSA9IG9wdGlvbnMucmVjdXJzaXZlKSAhPSBudWxsID8gX29wdGlvbnMkcmVjdXJzaXZlIDogdGhpcy5zcGVjLnJlY3Vyc2l2ZSxcbiAgICAgIGRpc2FibGVTdGFja1RyYWNlOiAoX29wdGlvbnMkZGlzYWJsZVN0YWNrID0gb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjayA6IHRoaXMuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZVxuICAgIH0pO1xuICB9XG5cbiAgLyoqXG4gICAqIFJ1biB0aGUgY29uZmlndXJlZCB0cmFuc2Zvcm0gcGlwZWxpbmUgb3ZlciBhbiBpbnB1dCB2YWx1ZS5cbiAgICovXG5cbiAgY2FzdCh2YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgbGV0IHJlc29sdmVkU2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe1xuICAgICAgdmFsdWVcbiAgICB9LCBvcHRpb25zKSk7XG4gICAgbGV0IGFsbG93T3B0aW9uYWxpdHkgPSBvcHRpb25zLmFzc2VydCA9PT0gJ2lnbm9yZS1vcHRpb25hbGl0eSc7XG4gICAgbGV0IHJlc3VsdCA9IHJlc29sdmVkU2NoZW1hLl9jYXN0KHZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAob3B0aW9ucy5hc3NlcnQgIT09IGZhbHNlICYmICFyZXNvbHZlZFNjaGVtYS5pc1R5cGUocmVzdWx0KSkge1xuICAgICAgaWYgKGFsbG93T3B0aW9uYWxpdHkgJiYgaXNBYnNlbnQocmVzdWx0KSkge1xuICAgICAgICByZXR1cm4gcmVzdWx0O1xuICAgICAgfVxuICAgICAgbGV0IGZvcm1hdHRlZFZhbHVlID0gcHJpbnRWYWx1ZSh2YWx1ZSk7XG4gICAgICBsZXQgZm9ybWF0dGVkUmVzdWx0ID0gcHJpbnRWYWx1ZShyZXN1bHQpO1xuICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihgVGhlIHZhbHVlIG9mICR7b3B0aW9ucy5wYXRoIHx8ICdmaWVsZCd9IGNvdWxkIG5vdCBiZSBjYXN0IHRvIGEgdmFsdWUgYCArIGB0aGF0IHNhdGlzZmllcyB0aGUgc2NoZW1hIHR5cGU6IFwiJHtyZXNvbHZlZFNjaGVtYS50eXBlfVwiLiBcXG5cXG5gICsgYGF0dGVtcHRlZCB2YWx1ZTogJHtmb3JtYXR0ZWRWYWx1ZX0gXFxuYCArIChmb3JtYXR0ZWRSZXN1bHQgIT09IGZvcm1hdHRlZFZhbHVlID8gYHJlc3VsdCBvZiBjYXN0OiAke2Zvcm1hdHRlZFJlc3VsdH1gIDogJycpKTtcbiAgICB9XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBfY2FzdChyYXdWYWx1ZSwgb3B0aW9ucykge1xuICAgIGxldCB2YWx1ZSA9IHJhd1ZhbHVlID09PSB1bmRlZmluZWQgPyByYXdWYWx1ZSA6IHRoaXMudHJhbnNmb3Jtcy5yZWR1Y2UoKHByZXZWYWx1ZSwgZm4pID0+IGZuLmNhbGwodGhpcywgcHJldlZhbHVlLCByYXdWYWx1ZSwgdGhpcyksIHJhd1ZhbHVlKTtcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xuICAgICAgdmFsdWUgPSB0aGlzLmdldERlZmF1bHQob3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IHtcbiAgICAgIHBhdGgsXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgc3RyaWN0ID0gdGhpcy5zcGVjLnN0cmljdFxuICAgIH0gPSBvcHRpb25zO1xuICAgIGxldCB2YWx1ZSA9IF92YWx1ZTtcbiAgICBpZiAoIXN0cmljdCkge1xuICAgICAgdmFsdWUgPSB0aGlzLl9jYXN0KHZhbHVlLCBPYmplY3QuYXNzaWduKHtcbiAgICAgICAgYXNzZXJ0OiBmYWxzZVxuICAgICAgfSwgb3B0aW9ucykpO1xuICAgIH1cbiAgICBsZXQgaW5pdGlhbFRlc3RzID0gW107XG4gICAgZm9yIChsZXQgdGVzdCBvZiBPYmplY3QudmFsdWVzKHRoaXMuaW50ZXJuYWxUZXN0cykpIHtcbiAgICAgIGlmICh0ZXN0KSBpbml0aWFsVGVzdHMucHVzaCh0ZXN0KTtcbiAgICB9XG4gICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICBwYXRoLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgb3B0aW9ucyxcbiAgICAgIHRlc3RzOiBpbml0aWFsVGVzdHNcbiAgICB9LCBwYW5pYywgaW5pdGlhbEVycm9ycyA9PiB7XG4gICAgICAvLyBldmVuIGlmIHdlIGFyZW4ndCBlbmRpbmcgZWFybHkgd2UgY2FuJ3QgcHJvY2VlZCBmdXJ0aGVyIGlmIHRoZSB0eXBlcyBhcmVuJ3QgY29ycmVjdFxuICAgICAgaWYgKGluaXRpYWxFcnJvcnMubGVuZ3RoKSB7XG4gICAgICAgIHJldHVybiBuZXh0KGluaXRpYWxFcnJvcnMsIHZhbHVlKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICBwYXRoLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZSxcbiAgICAgICAgb3B0aW9ucyxcbiAgICAgICAgdGVzdHM6IHRoaXMudGVzdHNcbiAgICAgIH0sIHBhbmljLCBuZXh0KTtcbiAgICB9KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBFeGVjdXRlcyBhIHNldCBvZiB2YWxpZGF0aW9ucywgZWl0aGVyIHNjaGVtYSwgcHJvZHVjZWQgVGVzdHMgb3IgYSBuZXN0ZWRcbiAgICogc2NoZW1hIHZhbGlkYXRlIHJlc3VsdC5cbiAgICovXG4gIHJ1blRlc3RzKHJ1bk9wdGlvbnMsIHBhbmljLCBuZXh0KSB7XG4gICAgbGV0IGZpcmVkID0gZmFsc2U7XG4gICAgbGV0IHtcbiAgICAgIHRlc3RzLFxuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gcnVuT3B0aW9ucztcbiAgICBsZXQgcGFuaWNPbmNlID0gYXJnID0+IHtcbiAgICAgIGlmIChmaXJlZCkgcmV0dXJuO1xuICAgICAgZmlyZWQgPSB0cnVlO1xuICAgICAgcGFuaWMoYXJnLCB2YWx1ZSk7XG4gICAgfTtcbiAgICBsZXQgbmV4dE9uY2UgPSBhcmcgPT4ge1xuICAgICAgaWYgKGZpcmVkKSByZXR1cm47XG4gICAgICBmaXJlZCA9IHRydWU7XG4gICAgICBuZXh0KGFyZywgdmFsdWUpO1xuICAgIH07XG4gICAgbGV0IGNvdW50ID0gdGVzdHMubGVuZ3RoO1xuICAgIGxldCBuZXN0ZWRFcnJvcnMgPSBbXTtcbiAgICBpZiAoIWNvdW50KSByZXR1cm4gbmV4dE9uY2UoW10pO1xuICAgIGxldCBhcmdzID0ge1xuICAgICAgdmFsdWUsXG4gICAgICBvcmlnaW5hbFZhbHVlLFxuICAgICAgcGF0aCxcbiAgICAgIG9wdGlvbnMsXG4gICAgICBzY2hlbWE6IHRoaXNcbiAgICB9O1xuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgdGVzdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IHRlc3QgPSB0ZXN0c1tpXTtcbiAgICAgIHRlc3QoYXJncywgcGFuaWNPbmNlLCBmdW5jdGlvbiBmaW5pc2hUZXN0UnVuKGVycikge1xuICAgICAgICBpZiAoZXJyKSB7XG4gICAgICAgICAgQXJyYXkuaXNBcnJheShlcnIpID8gbmVzdGVkRXJyb3JzLnB1c2goLi4uZXJyKSA6IG5lc3RlZEVycm9ycy5wdXNoKGVycik7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKC0tY291bnQgPD0gMCkge1xuICAgICAgICAgIG5leHRPbmNlKG5lc3RlZEVycm9ycyk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuICBhc05lc3RlZFRlc3Qoe1xuICAgIGtleSxcbiAgICBpbmRleCxcbiAgICBwYXJlbnQsXG4gICAgcGFyZW50UGF0aCxcbiAgICBvcmlnaW5hbFBhcmVudCxcbiAgICBvcHRpb25zXG4gIH0pIHtcbiAgICBjb25zdCBrID0ga2V5ICE9IG51bGwgPyBrZXkgOiBpbmRleDtcbiAgICBpZiAoayA9PSBudWxsKSB7XG4gICAgICB0aHJvdyBUeXBlRXJyb3IoJ011c3QgaW5jbHVkZSBga2V5YCBvciBgaW5kZXhgIGZvciBuZXN0ZWQgdmFsaWRhdGlvbnMnKTtcbiAgICB9XG4gICAgY29uc3QgaXNJbmRleCA9IHR5cGVvZiBrID09PSAnbnVtYmVyJztcbiAgICBsZXQgdmFsdWUgPSBwYXJlbnRba107XG4gICAgY29uc3QgdGVzdE9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAvLyBOZXN0ZWQgdmFsaWRhdGlvbnMgZmllbGRzIGFyZSBhbHdheXMgc3RyaWN0OlxuICAgICAgLy8gICAgMS4gcGFyZW50IGlzbid0IHN0cmljdCBzbyB0aGUgY2FzdGluZyB3aWxsIGFsc28gaGF2ZSBjYXN0IGlubmVyIHZhbHVlc1xuICAgICAgLy8gICAgMi4gcGFyZW50IGlzIHN0cmljdCBpbiB3aGljaCBjYXNlIHRoZSBuZXN0ZWQgdmFsdWVzIHdlcmVuJ3QgY2FzdCBlaXRoZXJcbiAgICAgIHN0cmljdDogdHJ1ZSxcbiAgICAgIHBhcmVudCxcbiAgICAgIHZhbHVlLFxuICAgICAgb3JpZ2luYWxWYWx1ZTogb3JpZ2luYWxQYXJlbnRba10sXG4gICAgICAvLyBGSVhNRTogdGVzdHMgZGVwZW5kIG9uIGBpbmRleGAgYmVpbmcgcGFzc2VkIGFyb3VuZCBkZWVwbHksXG4gICAgICAvLyAgIHdlIHNob3VsZCBub3QgbGV0IHRoZSBvcHRpb25zLmtleS9pbmRleCBibGVlZCB0aHJvdWdoXG4gICAgICBrZXk6IHVuZGVmaW5lZCxcbiAgICAgIC8vIGluZGV4OiB1bmRlZmluZWQsXG4gICAgICBbaXNJbmRleCA/ICdpbmRleCcgOiAna2V5J106IGssXG4gICAgICBwYXRoOiBpc0luZGV4IHx8IGsuaW5jbHVkZXMoJy4nKSA/IGAke3BhcmVudFBhdGggfHwgJyd9WyR7aXNJbmRleCA/IGsgOiBgXCIke2t9XCJgfV1gIDogKHBhcmVudFBhdGggPyBgJHtwYXJlbnRQYXRofS5gIDogJycpICsga2V5XG4gICAgfSk7XG4gICAgcmV0dXJuIChfLCBwYW5pYywgbmV4dCkgPT4gdGhpcy5yZXNvbHZlKHRlc3RPcHRpb25zKS5fdmFsaWRhdGUodmFsdWUsIHRlc3RPcHRpb25zLCBwYW5pYywgbmV4dCk7XG4gIH1cbiAgdmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpIHtcbiAgICB2YXIgX29wdGlvbnMkZGlzYWJsZVN0YWNrMjtcbiAgICBsZXQgc2NoZW1hID0gdGhpcy5yZXNvbHZlKE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHZhbHVlXG4gICAgfSkpO1xuICAgIGxldCBkaXNhYmxlU3RhY2tUcmFjZSA9IChfb3B0aW9ucyRkaXNhYmxlU3RhY2syID0gb3B0aW9ucyA9PSBudWxsID8gdm9pZCAwIDogb3B0aW9ucy5kaXNhYmxlU3RhY2tUcmFjZSkgIT0gbnVsbCA/IF9vcHRpb25zJGRpc2FibGVTdGFjazIgOiBzY2hlbWEuc3BlYy5kaXNhYmxlU3RhY2tUcmFjZTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4gc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucywgKGVycm9yLCBwYXJzZWQpID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnJvcikpIGVycm9yLnZhbHVlID0gcGFyc2VkO1xuICAgICAgcmVqZWN0KGVycm9yKTtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSByZWplY3QobmV3IFZhbGlkYXRpb25FcnJvcihlcnJvcnMsIHZhbGlkYXRlZCwgdW5kZWZpbmVkLCB1bmRlZmluZWQsIGRpc2FibGVTdGFja1RyYWNlKSk7ZWxzZSByZXNvbHZlKHZhbGlkYXRlZCk7XG4gICAgfSkpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHZhciBfb3B0aW9ucyRkaXNhYmxlU3RhY2szO1xuICAgIGxldCBzY2hlbWEgPSB0aGlzLnJlc29sdmUoT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgdmFsdWVcbiAgICB9KSk7XG4gICAgbGV0IHJlc3VsdDtcbiAgICBsZXQgZGlzYWJsZVN0YWNrVHJhY2UgPSAoX29wdGlvbnMkZGlzYWJsZVN0YWNrMyA9IG9wdGlvbnMgPT0gbnVsbCA/IHZvaWQgMCA6IG9wdGlvbnMuZGlzYWJsZVN0YWNrVHJhY2UpICE9IG51bGwgPyBfb3B0aW9ucyRkaXNhYmxlU3RhY2szIDogc2NoZW1hLnNwZWMuZGlzYWJsZVN0YWNrVHJhY2U7XG4gICAgc2NoZW1hLl92YWxpZGF0ZSh2YWx1ZSwgT2JqZWN0LmFzc2lnbih7fSwgb3B0aW9ucywge1xuICAgICAgc3luYzogdHJ1ZVxuICAgIH0pLCAoZXJyb3IsIHBhcnNlZCkgPT4ge1xuICAgICAgaWYgKFZhbGlkYXRpb25FcnJvci5pc0Vycm9yKGVycm9yKSkgZXJyb3IudmFsdWUgPSBwYXJzZWQ7XG4gICAgICB0aHJvdyBlcnJvcjtcbiAgICB9LCAoZXJyb3JzLCB2YWxpZGF0ZWQpID0+IHtcbiAgICAgIGlmIChlcnJvcnMubGVuZ3RoKSB0aHJvdyBuZXcgVmFsaWRhdGlvbkVycm9yKGVycm9ycywgdmFsdWUsIHVuZGVmaW5lZCwgdW5kZWZpbmVkLCBkaXNhYmxlU3RhY2tUcmFjZSk7XG4gICAgICByZXN1bHQgPSB2YWxpZGF0ZWQ7XG4gICAgfSk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxuICBpc1ZhbGlkKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMudmFsaWRhdGUodmFsdWUsIG9wdGlvbnMpLnRoZW4oKCkgPT4gdHJ1ZSwgZXJyID0+IHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gZmFsc2U7XG4gICAgICB0aHJvdyBlcnI7XG4gICAgfSk7XG4gIH1cbiAgaXNWYWxpZFN5bmModmFsdWUsIG9wdGlvbnMpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICBpZiAoVmFsaWRhdGlvbkVycm9yLmlzRXJyb3IoZXJyKSkgcmV0dXJuIGZhbHNlO1xuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBfZ2V0RGVmYXVsdChvcHRpb25zKSB7XG4gICAgbGV0IGRlZmF1bHRWYWx1ZSA9IHRoaXMuc3BlYy5kZWZhdWx0O1xuICAgIGlmIChkZWZhdWx0VmFsdWUgPT0gbnVsbCkge1xuICAgICAgcmV0dXJuIGRlZmF1bHRWYWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09ICdmdW5jdGlvbicgPyBkZWZhdWx0VmFsdWUuY2FsbCh0aGlzLCBvcHRpb25zKSA6IGNsb25lKGRlZmF1bHRWYWx1ZSk7XG4gIH1cbiAgZ2V0RGVmYXVsdChvcHRpb25zXG4gIC8vIElmIHNjaGVtYSBpcyBkZWZhdWx0ZWQgd2Uga25vdyBpdCdzIGF0IGxlYXN0IG5vdCB1bmRlZmluZWRcbiAgKSB7XG4gICAgbGV0IHNjaGVtYSA9IHRoaXMucmVzb2x2ZShvcHRpb25zIHx8IHt9KTtcbiAgICByZXR1cm4gc2NoZW1hLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICB9XG4gIGRlZmF1bHQoZGVmKSB7XG4gICAgaWYgKGFyZ3VtZW50cy5sZW5ndGggPT09IDApIHtcbiAgICAgIHJldHVybiB0aGlzLl9nZXREZWZhdWx0KCk7XG4gICAgfVxuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBkZWZhdWx0OiBkZWZcbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzdHJpY3QoaXNTdHJpY3QgPSB0cnVlKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoe1xuICAgICAgc3RyaWN0OiBpc1N0cmljdFxuICAgIH0pO1xuICB9XG4gIG51bGxhYmlsaXR5KG51bGxhYmxlLCBtZXNzYWdlKSB7XG4gICAgY29uc3QgbmV4dCA9IHRoaXMuY2xvbmUoe1xuICAgICAgbnVsbGFibGVcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMubnVsbGFibGUgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbnVsbGFibGUnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPT09IG51bGwgPyB0aGlzLnNjaGVtYS5zcGVjLm51bGxhYmxlIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbGl0eShvcHRpb25hbCwgbWVzc2FnZSkge1xuICAgIGNvbnN0IG5leHQgPSB0aGlzLmNsb25lKHtcbiAgICAgIG9wdGlvbmFsXG4gICAgfSk7XG4gICAgbmV4dC5pbnRlcm5hbFRlc3RzLm9wdGlvbmFsaXR5ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29wdGlvbmFsaXR5JyxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIHZhbHVlID09PSB1bmRlZmluZWQgPyB0aGlzLnNjaGVtYS5zcGVjLm9wdGlvbmFsIDogdHJ1ZTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gdGhpcy5vcHRpb25hbGl0eSh0cnVlKTtcbiAgfVxuICBkZWZpbmVkKG1lc3NhZ2UgPSBtaXhlZC5kZWZpbmVkKSB7XG4gICAgcmV0dXJuIHRoaXMub3B0aW9uYWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIG51bGxhYmxlKCkge1xuICAgIHJldHVybiB0aGlzLm51bGxhYmlsaXR5KHRydWUpO1xuICB9XG4gIG5vbk51bGxhYmxlKG1lc3NhZ2UgPSBtaXhlZC5ub3ROdWxsKSB7XG4gICAgcmV0dXJuIHRoaXMubnVsbGFiaWxpdHkoZmFsc2UsIG1lc3NhZ2UpO1xuICB9XG4gIHJlcXVpcmVkKG1lc3NhZ2UgPSBtaXhlZC5yZXF1aXJlZCkge1xuICAgIHJldHVybiB0aGlzLmNsb25lKCkud2l0aE11dGF0aW9uKG5leHQgPT4gbmV4dC5ub25OdWxsYWJsZShtZXNzYWdlKS5kZWZpbmVkKG1lc3NhZ2UpKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IG5leHQubnVsbGFibGUoKS5vcHRpb25hbCgpKTtcbiAgfVxuICB0cmFuc2Zvcm0oZm4pIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnRyYW5zZm9ybXMucHVzaChmbik7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogQWRkcyBhIHRlc3QgZnVuY3Rpb24gdG8gdGhlIHNjaGVtYSdzIHF1ZXVlIG9mIHRlc3RzLlxuICAgKiB0ZXN0cyBjYW4gYmUgZXhjbHVzaXZlIG9yIG5vbi1leGNsdXNpdmUuXG4gICAqXG4gICAqIC0gZXhjbHVzaXZlIHRlc3RzLCB3aWxsIHJlcGxhY2UgYW55IGV4aXN0aW5nIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUuXG4gICAqIC0gbm9uLWV4Y2x1c2l2ZTogY2FuIGJlIHN0YWNrZWRcbiAgICpcbiAgICogSWYgYSBub24tZXhjbHVzaXZlIHRlc3QgaXMgYWRkZWQgdG8gYSBzY2hlbWEgd2l0aCBhbiBleGNsdXNpdmUgdGVzdCBvZiB0aGUgc2FtZSBuYW1lXG4gICAqIHRoZSBleGNsdXNpdmUgdGVzdCBpcyByZW1vdmVkIGFuZCBmdXJ0aGVyIHRlc3RzIG9mIHRoZSBzYW1lIG5hbWUgd2lsbCBiZSBzdGFja2VkLlxuICAgKlxuICAgKiBJZiBhbiBleGNsdXNpdmUgdGVzdCBpcyBhZGRlZCB0byBhIHNjaGVtYSB3aXRoIG5vbi1leGNsdXNpdmUgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZVxuICAgKiB0aGUgcHJldmlvdXMgdGVzdHMgYXJlIHJlbW92ZWQgYW5kIGZ1cnRoZXIgdGVzdHMgb2YgdGhlIHNhbWUgbmFtZSB3aWxsIHJlcGxhY2UgZWFjaCBvdGhlci5cbiAgICovXG5cbiAgdGVzdCguLi5hcmdzKSB7XG4gICAgbGV0IG9wdHM7XG4gICAgaWYgKGFyZ3MubGVuZ3RoID09PSAxKSB7XG4gICAgICBpZiAodHlwZW9mIGFyZ3NbMF0gPT09ICdmdW5jdGlvbicpIHtcbiAgICAgICAgb3B0cyA9IHtcbiAgICAgICAgICB0ZXN0OiBhcmdzWzBdXG4gICAgICAgIH07XG4gICAgICB9IGVsc2Uge1xuICAgICAgICBvcHRzID0gYXJnc1swXTtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKGFyZ3MubGVuZ3RoID09PSAyKSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICB0ZXN0OiBhcmdzWzFdXG4gICAgICB9O1xuICAgIH0gZWxzZSB7XG4gICAgICBvcHRzID0ge1xuICAgICAgICBuYW1lOiBhcmdzWzBdLFxuICAgICAgICBtZXNzYWdlOiBhcmdzWzFdLFxuICAgICAgICB0ZXN0OiBhcmdzWzJdXG4gICAgICB9O1xuICAgIH1cbiAgICBpZiAob3B0cy5tZXNzYWdlID09PSB1bmRlZmluZWQpIG9wdHMubWVzc2FnZSA9IG1peGVkLmRlZmF1bHQ7XG4gICAgaWYgKHR5cGVvZiBvcHRzLnRlc3QgIT09ICdmdW5jdGlvbicpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2B0ZXN0YCBpcyBhIHJlcXVpcmVkIHBhcmFtZXRlcnMnKTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgdmFsaWRhdGUgPSBjcmVhdGVWYWxpZGF0aW9uKG9wdHMpO1xuICAgIGxldCBpc0V4Y2x1c2l2ZSA9IG9wdHMuZXhjbHVzaXZlIHx8IG9wdHMubmFtZSAmJiBuZXh0LmV4Y2x1c2l2ZVRlc3RzW29wdHMubmFtZV0gPT09IHRydWU7XG4gICAgaWYgKG9wdHMuZXhjbHVzaXZlKSB7XG4gICAgICBpZiAoIW9wdHMubmFtZSkgdGhyb3cgbmV3IFR5cGVFcnJvcignRXhjbHVzaXZlIHRlc3RzIG11c3QgcHJvdmlkZSBhIHVuaXF1ZSBgbmFtZWAgaWRlbnRpZnlpbmcgdGhlIHRlc3QnKTtcbiAgICB9XG4gICAgaWYgKG9wdHMubmFtZSkgbmV4dC5leGNsdXNpdmVUZXN0c1tvcHRzLm5hbWVdID0gISFvcHRzLmV4Y2x1c2l2ZTtcbiAgICBuZXh0LnRlc3RzID0gbmV4dC50ZXN0cy5maWx0ZXIoZm4gPT4ge1xuICAgICAgaWYgKGZuLk9QVElPTlMubmFtZSA9PT0gb3B0cy5uYW1lKSB7XG4gICAgICAgIGlmIChpc0V4Y2x1c2l2ZSkgcmV0dXJuIGZhbHNlO1xuICAgICAgICBpZiAoZm4uT1BUSU9OUy50ZXN0ID09PSB2YWxpZGF0ZS5PUFRJT05TLnRlc3QpIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuICAgIG5leHQudGVzdHMucHVzaCh2YWxpZGF0ZSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgd2hlbihrZXlzLCBvcHRpb25zKSB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGtleXMpICYmIHR5cGVvZiBrZXlzICE9PSAnc3RyaW5nJykge1xuICAgICAgb3B0aW9ucyA9IGtleXM7XG4gICAgICBrZXlzID0gJy4nO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBsZXQgZGVwcyA9IHRvQXJyYXkoa2V5cykubWFwKGtleSA9PiBuZXcgUmVmZXJlbmNlKGtleSkpO1xuICAgIGRlcHMuZm9yRWFjaChkZXAgPT4ge1xuICAgICAgLy8gQHRzLWlnbm9yZSByZWFkb25seSBhcnJheVxuICAgICAgaWYgKGRlcC5pc1NpYmxpbmcpIG5leHQuZGVwcy5wdXNoKGRlcC5rZXkpO1xuICAgIH0pO1xuICAgIG5leHQuY29uZGl0aW9ucy5wdXNoKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nID8gbmV3IENvbmRpdGlvbihkZXBzLCBvcHRpb25zKSA6IENvbmRpdGlvbi5mcm9tT3B0aW9ucyhkZXBzLCBvcHRpb25zKSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgdHlwZUVycm9yKG1lc3NhZ2UpIHtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMudHlwZUVycm9yID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3R5cGVFcnJvcicsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBpZiAoIXRoaXMuc2NoZW1hLl90eXBlQ2hlY2sodmFsdWUpKSByZXR1cm4gdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB0eXBlOiB0aGlzLnNjaGVtYS50eXBlXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb25lT2YoZW51bXMsIG1lc3NhZ2UgPSBtaXhlZC5vbmVPZikge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIGVudW1zLmZvckVhY2godmFsID0+IHtcbiAgICAgIG5leHQuX3doaXRlbGlzdC5hZGQodmFsKTtcbiAgICAgIG5leHQuX2JsYWNrbGlzdC5kZWxldGUodmFsKTtcbiAgICB9KTtcbiAgICBuZXh0LmludGVybmFsVGVzdHMud2hpdGVMaXN0ID0gY3JlYXRlVmFsaWRhdGlvbih7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ29uZU9mJyxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGxldCB2YWxpZHMgPSB0aGlzLnNjaGVtYS5fd2hpdGVsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSB2YWxpZHMucmVzb2x2ZUFsbCh0aGlzLnJlc29sdmUpO1xuICAgICAgICByZXR1cm4gcmVzb2x2ZWQuaW5jbHVkZXModmFsdWUpID8gdHJ1ZSA6IHRoaXMuY3JlYXRlRXJyb3Ioe1xuICAgICAgICAgIHBhcmFtczoge1xuICAgICAgICAgICAgdmFsdWVzOiBBcnJheS5mcm9tKHZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBub3RPbmVPZihlbnVtcywgbWVzc2FnZSA9IG1peGVkLm5vdE9uZU9mKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgZW51bXMuZm9yRWFjaCh2YWwgPT4ge1xuICAgICAgbmV4dC5fYmxhY2tsaXN0LmFkZCh2YWwpO1xuICAgICAgbmV4dC5fd2hpdGVsaXN0LmRlbGV0ZSh2YWwpO1xuICAgIH0pO1xuICAgIG5leHQuaW50ZXJuYWxUZXN0cy5ibGFja2xpc3QgPSBjcmVhdGVWYWxpZGF0aW9uKHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbm90T25lT2YnLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICBsZXQgaW52YWxpZHMgPSB0aGlzLnNjaGVtYS5fYmxhY2tsaXN0O1xuICAgICAgICBsZXQgcmVzb2x2ZWQgPSBpbnZhbGlkcy5yZXNvbHZlQWxsKHRoaXMucmVzb2x2ZSk7XG4gICAgICAgIGlmIChyZXNvbHZlZC5pbmNsdWRlcyh2YWx1ZSkpIHJldHVybiB0aGlzLmNyZWF0ZUVycm9yKHtcbiAgICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAgIHZhbHVlczogQXJyYXkuZnJvbShpbnZhbGlkcykuam9pbignLCAnKSxcbiAgICAgICAgICAgIHJlc29sdmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgc3RyaXAoc3RyaXAgPSB0cnVlKSB7XG4gICAgbGV0IG5leHQgPSB0aGlzLmNsb25lKCk7XG4gICAgbmV4dC5zcGVjLnN0cmlwID0gc3RyaXA7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cblxuICAvKipcbiAgICogUmV0dXJuIGEgc2VyaWFsaXplZCBkZXNjcmlwdGlvbiBvZiB0aGUgc2NoZW1hIGluY2x1ZGluZyB2YWxpZGF0aW9ucywgZmxhZ3MsIHR5cGVzIGV0Yy5cbiAgICpcbiAgICogQHBhcmFtIG9wdGlvbnMgUHJvdmlkZSBhbnkgbmVlZGVkIGNvbnRleHQgZm9yIHJlc29sdmluZyBydW50aW1lIHNjaGVtYSBhbHRlcmF0aW9ucyAobGF6eSwgd2hlbiBjb25kaXRpb25zLCBldGMpLlxuICAgKi9cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3Qge1xuICAgICAgbGFiZWwsXG4gICAgICBtZXRhLFxuICAgICAgb3B0aW9uYWwsXG4gICAgICBudWxsYWJsZVxuICAgIH0gPSBuZXh0LnNwZWM7XG4gICAgY29uc3QgZGVzY3JpcHRpb24gPSB7XG4gICAgICBtZXRhLFxuICAgICAgbGFiZWwsXG4gICAgICBvcHRpb25hbCxcbiAgICAgIG51bGxhYmxlLFxuICAgICAgZGVmYXVsdDogbmV4dC5nZXREZWZhdWx0KG9wdGlvbnMpLFxuICAgICAgdHlwZTogbmV4dC50eXBlLFxuICAgICAgb25lT2Y6IG5leHQuX3doaXRlbGlzdC5kZXNjcmliZSgpLFxuICAgICAgbm90T25lT2Y6IG5leHQuX2JsYWNrbGlzdC5kZXNjcmliZSgpLFxuICAgICAgdGVzdHM6IG5leHQudGVzdHMubWFwKGZuID0+ICh7XG4gICAgICAgIG5hbWU6IGZuLk9QVElPTlMubmFtZSxcbiAgICAgICAgcGFyYW1zOiBmbi5PUFRJT05TLnBhcmFtc1xuICAgICAgfSkpLmZpbHRlcigobiwgaWR4LCBsaXN0KSA9PiBsaXN0LmZpbmRJbmRleChjID0+IGMubmFtZSA9PT0gbi5uYW1lKSA9PT0gaWR4KVxuICAgIH07XG4gICAgcmV0dXJuIGRlc2NyaXB0aW9uO1xuICB9XG59XG4vLyBAdHMtZXhwZWN0LWVycm9yXG5TY2hlbWEucHJvdG90eXBlLl9faXNZdXBTY2hlbWFfXyA9IHRydWU7XG5mb3IgKGNvbnN0IG1ldGhvZCBvZiBbJ3ZhbGlkYXRlJywgJ3ZhbGlkYXRlU3luYyddKSBTY2hlbWEucHJvdG90eXBlW2Ake21ldGhvZH1BdGBdID0gZnVuY3Rpb24gKHBhdGgsIHZhbHVlLCBvcHRpb25zID0ge30pIHtcbiAgY29uc3Qge1xuICAgIHBhcmVudCxcbiAgICBwYXJlbnRQYXRoLFxuICAgIHNjaGVtYVxuICB9ID0gZ2V0SW4odGhpcywgcGF0aCwgdmFsdWUsIG9wdGlvbnMuY29udGV4dCk7XG4gIHJldHVybiBzY2hlbWFbbWV0aG9kXShwYXJlbnQgJiYgcGFyZW50W3BhcmVudFBhdGhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgcGFyZW50LFxuICAgIHBhdGhcbiAgfSkpO1xufTtcbmZvciAoY29uc3QgYWxpYXMgb2YgWydlcXVhbHMnLCAnaXMnXSkgU2NoZW1hLnByb3RvdHlwZVthbGlhc10gPSBTY2hlbWEucHJvdG90eXBlLm9uZU9mO1xuZm9yIChjb25zdCBhbGlhcyBvZiBbJ25vdCcsICdub3BlJ10pIFNjaGVtYS5wcm90b3R5cGVbYWxpYXNdID0gU2NoZW1hLnByb3RvdHlwZS5ub3RPbmVPZjtcblxuY29uc3QgcmV0dXJuc1RydWUgPSAoKSA9PiB0cnVlO1xuZnVuY3Rpb24gY3JlYXRlJDgoc3BlYykge1xuICByZXR1cm4gbmV3IE1peGVkU2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgTWl4ZWRTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzcGVjKSB7XG4gICAgc3VwZXIodHlwZW9mIHNwZWMgPT09ICdmdW5jdGlvbicgPyB7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHNwZWNcbiAgICB9IDogT2JqZWN0LmFzc2lnbih7XG4gICAgICB0eXBlOiAnbWl4ZWQnLFxuICAgICAgY2hlY2s6IHJldHVybnNUcnVlXG4gICAgfSwgc3BlYykpO1xuICB9XG59XG5jcmVhdGUkOC5wcm90b3R5cGUgPSBNaXhlZFNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZSQ3KCkge1xuICByZXR1cm4gbmV3IEJvb2xlYW5TY2hlbWEoKTtcbn1cbmNsYXNzIEJvb2xlYW5TY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnYm9vbGVhbicsXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIGlmICh2IGluc3RhbmNlb2YgQm9vbGVhbikgdiA9IHYudmFsdWVPZigpO1xuICAgICAgICByZXR1cm4gdHlwZW9mIHYgPT09ICdib29sZWFuJztcbiAgICAgIH1cbiAgICB9KTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICB0aGlzLnRyYW5zZm9ybSgodmFsdWUsIF9yYXcsIGN0eCkgPT4ge1xuICAgICAgICBpZiAoY3R4LnNwZWMuY29lcmNlICYmICFjdHguaXNUeXBlKHZhbHVlKSkge1xuICAgICAgICAgIGlmICgvXih0cnVlfDEpJC9pLnRlc3QoU3RyaW5nKHZhbHVlKSkpIHJldHVybiB0cnVlO1xuICAgICAgICAgIGlmICgvXihmYWxzZXwwKSQvaS50ZXN0KFN0cmluZyh2YWx1ZSkpKSByZXR1cm4gZmFsc2U7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgaXNUcnVlKG1lc3NhZ2UgPSBib29sZWFuLmlzVmFsdWUpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnaXMtdmFsdWUnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHZhbHVlOiAndHJ1ZSdcbiAgICAgIH0sXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHRydWU7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgaXNGYWxzZShtZXNzYWdlID0gYm9vbGVhbi5pc1ZhbHVlKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ2lzLXZhbHVlJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICB2YWx1ZTogJ2ZhbHNlJ1xuICAgICAgfSxcbiAgICAgIHRlc3QodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzQWJzZW50KHZhbHVlKSB8fCB2YWx1ZSA9PT0gZmFsc2U7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgZGVmYXVsdChkZWYpIHtcbiAgICByZXR1cm4gc3VwZXIuZGVmYXVsdChkZWYpO1xuICB9XG4gIGRlZmluZWQobXNnKSB7XG4gICAgcmV0dXJuIHN1cGVyLmRlZmluZWQobXNnKTtcbiAgfVxuICBvcHRpb25hbCgpIHtcbiAgICByZXR1cm4gc3VwZXIub3B0aW9uYWwoKTtcbiAgfVxuICByZXF1aXJlZChtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIucmVxdWlyZWQobXNnKTtcbiAgfVxuICBub3RSZXF1aXJlZCgpIHtcbiAgICByZXR1cm4gc3VwZXIubm90UmVxdWlyZWQoKTtcbiAgfVxuICBudWxsYWJsZSgpIHtcbiAgICByZXR1cm4gc3VwZXIubnVsbGFibGUoKTtcbiAgfVxuICBub25OdWxsYWJsZShtc2cpIHtcbiAgICByZXR1cm4gc3VwZXIubm9uTnVsbGFibGUobXNnKTtcbiAgfVxuICBzdHJpcCh2KSB7XG4gICAgcmV0dXJuIHN1cGVyLnN0cmlwKHYpO1xuICB9XG59XG5jcmVhdGUkNy5wcm90b3R5cGUgPSBCb29sZWFuU2NoZW1hLnByb3RvdHlwZTtcblxuLyoqXG4gKiBUaGlzIGZpbGUgaXMgYSBtb2RpZmllZCB2ZXJzaW9uIG9mIHRoZSBmaWxlIGZyb20gdGhlIGZvbGxvd2luZyByZXBvc2l0b3J5OlxuICogRGF0ZS5wYXJzZSB3aXRoIHByb2dyZXNzaXZlIGVuaGFuY2VtZW50IGZvciBJU08gODYwMSA8aHR0cHM6Ly9naXRodWIuY29tL2Nzbm92ZXIvanMtaXNvODYwMT5cbiAqIE5PTi1DT05GT1JNQU5UIEVESVRJT04uXG4gKiDCqSAyMDExIENvbGluIFNub3ZlciA8aHR0cDovL3pldGFmbGVldC5jb20+XG4gKiBSZWxlYXNlZCB1bmRlciBNSVQgbGljZW5zZS5cbiAqL1xuXG4vLyBwcmV0dGllci1pZ25vcmVcbi8vICAgICAgICAgICAgICAgIDEgWVlZWSAgICAgICAgICAgICAgICAyIE1NICAgICAgICAzIEREICAgICAgICAgICAgICA0IEhIICAgICA1IG1tICAgICAgICA2IHNzICAgICAgICAgICA3IG1zZWMgICAgICAgICA4IFogOSDCsSAgIDEwIHR6SEggICAgMTEgdHptbVxuY29uc3QgaXNvUmVnID0gL14oXFxkezR9fFsrLV1cXGR7Nn0pKD86LT8oXFxkezJ9KSg/Oi0/KFxcZHsyfSkpPyk/KD86WyBUXT8oXFxkezJ9KTo/KFxcZHsyfSkoPzo6PyhcXGR7Mn0pKD86WywuXShcXGR7MSx9KSk/KT8oPzooWil8KFsrLV0pKFxcZHsyfSkoPzo6PyhcXGR7Mn0pKT8pPyk/JC87XG5mdW5jdGlvbiBwYXJzZUlzb0RhdGUoZGF0ZSkge1xuICBjb25zdCBzdHJ1Y3QgPSBwYXJzZURhdGVTdHJ1Y3QoZGF0ZSk7XG4gIGlmICghc3RydWN0KSByZXR1cm4gRGF0ZS5wYXJzZSA/IERhdGUucGFyc2UoZGF0ZSkgOiBOdW1iZXIuTmFOO1xuXG4gIC8vIHRpbWVzdGFtcHMgd2l0aG91dCB0aW1lem9uZSBpZGVudGlmaWVycyBzaG91bGQgYmUgY29uc2lkZXJlZCBsb2NhbCB0aW1lXG4gIGlmIChzdHJ1Y3QueiA9PT0gdW5kZWZpbmVkICYmIHN0cnVjdC5wbHVzTWludXMgPT09IHVuZGVmaW5lZCkge1xuICAgIHJldHVybiBuZXcgRGF0ZShzdHJ1Y3QueWVhciwgc3RydWN0Lm1vbnRoLCBzdHJ1Y3QuZGF5LCBzdHJ1Y3QuaG91ciwgc3RydWN0Lm1pbnV0ZSwgc3RydWN0LnNlY29uZCwgc3RydWN0Lm1pbGxpc2Vjb25kKS52YWx1ZU9mKCk7XG4gIH1cbiAgbGV0IHRvdGFsTWludXRlc09mZnNldCA9IDA7XG4gIGlmIChzdHJ1Y3QueiAhPT0gJ1onICYmIHN0cnVjdC5wbHVzTWludXMgIT09IHVuZGVmaW5lZCkge1xuICAgIHRvdGFsTWludXRlc09mZnNldCA9IHN0cnVjdC5ob3VyT2Zmc2V0ICogNjAgKyBzdHJ1Y3QubWludXRlT2Zmc2V0O1xuICAgIGlmIChzdHJ1Y3QucGx1c01pbnVzID09PSAnKycpIHRvdGFsTWludXRlc09mZnNldCA9IDAgLSB0b3RhbE1pbnV0ZXNPZmZzZXQ7XG4gIH1cbiAgcmV0dXJuIERhdGUuVVRDKHN0cnVjdC55ZWFyLCBzdHJ1Y3QubW9udGgsIHN0cnVjdC5kYXksIHN0cnVjdC5ob3VyLCBzdHJ1Y3QubWludXRlICsgdG90YWxNaW51dGVzT2Zmc2V0LCBzdHJ1Y3Quc2Vjb25kLCBzdHJ1Y3QubWlsbGlzZWNvbmQpO1xufVxuZnVuY3Rpb24gcGFyc2VEYXRlU3RydWN0KGRhdGUpIHtcbiAgdmFyIF9yZWdleFJlc3VsdCQ3JGxlbmd0aCwgX3JlZ2V4UmVzdWx0JDtcbiAgY29uc3QgcmVnZXhSZXN1bHQgPSBpc29SZWcuZXhlYyhkYXRlKTtcbiAgaWYgKCFyZWdleFJlc3VsdCkgcmV0dXJuIG51bGw7XG5cbiAgLy8gdXNlIG9mIHRvTnVtYmVyKCkgYXZvaWRzIE5hTiB0aW1lc3RhbXBzIGNhdXNlZCBieSDigJx1bmRlZmluZWTigJ1cbiAgLy8gdmFsdWVzIGJlaW5nIHBhc3NlZCB0byBEYXRlIGNvbnN0cnVjdG9yXG4gIHJldHVybiB7XG4gICAgeWVhcjogdG9OdW1iZXIocmVnZXhSZXN1bHRbMV0pLFxuICAgIG1vbnRoOiB0b051bWJlcihyZWdleFJlc3VsdFsyXSwgMSkgLSAxLFxuICAgIGRheTogdG9OdW1iZXIocmVnZXhSZXN1bHRbM10sIDEpLFxuICAgIGhvdXI6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzRdKSxcbiAgICBtaW51dGU6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzVdKSxcbiAgICBzZWNvbmQ6IHRvTnVtYmVyKHJlZ2V4UmVzdWx0WzZdKSxcbiAgICBtaWxsaXNlY29uZDogcmVnZXhSZXN1bHRbN10gP1xuICAgIC8vIGFsbG93IGFyYml0cmFyeSBzdWItc2Vjb25kIHByZWNpc2lvbiBiZXlvbmQgbWlsbGlzZWNvbmRzXG4gICAgdG9OdW1iZXIocmVnZXhSZXN1bHRbN10uc3Vic3RyaW5nKDAsIDMpKSA6IDAsXG4gICAgcHJlY2lzaW9uOiAoX3JlZ2V4UmVzdWx0JDckbGVuZ3RoID0gKF9yZWdleFJlc3VsdCQgPSByZWdleFJlc3VsdFs3XSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9yZWdleFJlc3VsdCQubGVuZ3RoKSAhPSBudWxsID8gX3JlZ2V4UmVzdWx0JDckbGVuZ3RoIDogdW5kZWZpbmVkLFxuICAgIHo6IHJlZ2V4UmVzdWx0WzhdIHx8IHVuZGVmaW5lZCxcbiAgICBwbHVzTWludXM6IHJlZ2V4UmVzdWx0WzldIHx8IHVuZGVmaW5lZCxcbiAgICBob3VyT2Zmc2V0OiB0b051bWJlcihyZWdleFJlc3VsdFsxMF0pLFxuICAgIG1pbnV0ZU9mZnNldDogdG9OdW1iZXIocmVnZXhSZXN1bHRbMTFdKVxuICB9O1xufVxuZnVuY3Rpb24gdG9OdW1iZXIoc3RyLCBkZWZhdWx0VmFsdWUgPSAwKSB7XG4gIHJldHVybiBOdW1iZXIoc3RyKSB8fCBkZWZhdWx0VmFsdWU7XG59XG5cbi8vIFRha2VuIGZyb20gSFRNTCBzcGVjOiBodHRwczovL2h0bWwuc3BlYy53aGF0d2cub3JnL211bHRpcGFnZS9pbnB1dC5odG1sI3ZhbGlkLWUtbWFpbC1hZGRyZXNzXG5sZXQgckVtYWlsID1cbi8vIGVzbGludC1kaXNhYmxlLW5leHQtbGluZVxuL15bYS16QS1aMC05LiEjJCUmJyorXFwvPT9eX2B7fH1+LV0rQFthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPyg/OlxcLlthLXpBLVowLTldKD86W2EtekEtWjAtOS1dezAsNjF9W2EtekEtWjAtOV0pPykqJC87XG5sZXQgclVybCA9XG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbi9eKChodHRwcz98ZnRwKTopP1xcL1xcLygoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6KSpAKT8oKChcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSlcXC4oXFxkfFsxLTldXFxkfDFcXGRcXGR8MlswLTRdXFxkfDI1WzAtNV0pXFwuKFxcZHxbMS05XVxcZHwxXFxkXFxkfDJbMC00XVxcZHwyNVswLTVdKVxcLihcXGR8WzEtOV1cXGR8MVxcZFxcZHwyWzAtNF1cXGR8MjVbMC01XSkpfCgoKFthLXpdfFxcZHxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KChbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxcXGR8W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKSlcXC4pKygoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCgoW2Etel18W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pKihbYS16XXxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSkpKVxcLj8pKDpcXGQqKT8pKFxcLygoKFthLXpdfFxcZHwtfFxcLnxffH58W1xcdTAwQTAtXFx1RDdGRlxcdUY5MDAtXFx1RkRDRlxcdUZERjAtXFx1RkZFRl0pfCglW1xcZGEtZl17Mn0pfFshXFwkJidcXChcXClcXCpcXCssOz1dfDp8QCkrKFxcLygoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKSopKik/KT8oXFw/KCgoW2Etel18XFxkfC18XFwufF98fnxbXFx1MDBBMC1cXHVEN0ZGXFx1RjkwMC1cXHVGRENGXFx1RkRGMC1cXHVGRkVGXSl8KCVbXFxkYS1mXXsyfSl8WyFcXCQmJ1xcKFxcKVxcKlxcKyw7PV18OnxAKXxbXFx1RTAwMC1cXHVGOEZGXXxcXC98XFw/KSopPyhcXCMoKChbYS16XXxcXGR8LXxcXC58X3x+fFtcXHUwMEEwLVxcdUQ3RkZcXHVGOTAwLVxcdUZEQ0ZcXHVGREYwLVxcdUZGRUZdKXwoJVtcXGRhLWZdezJ9KXxbIVxcJCYnXFwoXFwpXFwqXFwrLDs9XXw6fEApfFxcL3xcXD8pKik/JC9pO1xuXG4vLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmVcbmxldCByVVVJRCA9IC9eKD86WzAtOWEtZl17OH0tWzAtOWEtZl17NH0tWzEtNV1bMC05YS1mXXszfS1bODlhYl1bMC05YS1mXXszfS1bMC05YS1mXXsxMn18MDAwMDAwMDAtMDAwMC0wMDAwLTAwMDAtMDAwMDAwMDAwMDAwKSQvaTtcbmxldCB5ZWFyTW9udGhEYXkgPSAnXlxcXFxkezR9LVxcXFxkezJ9LVxcXFxkezJ9JztcbmxldCBob3VyTWludXRlU2Vjb25kID0gJ1xcXFxkezJ9OlxcXFxkezJ9OlxcXFxkezJ9JztcbmxldCB6T3JPZmZzZXQgPSAnKChbKy1dXFxcXGR7Mn0oOj9cXFxcZHsyfSk/KXxaKSc7XG5sZXQgcklzb0RhdGVUaW1lID0gbmV3IFJlZ0V4cChgJHt5ZWFyTW9udGhEYXl9VCR7aG91ck1pbnV0ZVNlY29uZH0oXFxcXC5cXFxcZCspPyR7ek9yT2Zmc2V0fSRgKTtcbmxldCBpc1RyaW1tZWQgPSB2YWx1ZSA9PiBpc0Fic2VudCh2YWx1ZSkgfHwgdmFsdWUgPT09IHZhbHVlLnRyaW0oKTtcbmxldCBvYmpTdHJpbmdUYWcgPSB7fS50b1N0cmluZygpO1xuZnVuY3Rpb24gY3JlYXRlJDYoKSB7XG4gIHJldHVybiBuZXcgU3RyaW5nU2NoZW1hKCk7XG59XG5jbGFzcyBTdHJpbmdTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcigpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnc3RyaW5nJyxcbiAgICAgIGNoZWNrKHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSBpbnN0YW5jZW9mIFN0cmluZykgdmFsdWUgPSB2YWx1ZS52YWx1ZU9mKCk7XG4gICAgICAgIHJldHVybiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlIHx8IGN0eC5pc1R5cGUodmFsdWUpKSByZXR1cm4gdmFsdWU7XG5cbiAgICAgICAgLy8gZG9uJ3QgZXZlciBjb252ZXJ0IGFycmF5c1xuICAgICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgY29uc3Qgc3RyVmFsdWUgPSB2YWx1ZSAhPSBudWxsICYmIHZhbHVlLnRvU3RyaW5nID8gdmFsdWUudG9TdHJpbmcoKSA6IHZhbHVlO1xuXG4gICAgICAgIC8vIG5vIG9uZSB3YW50cyBwbGFpbiBvYmplY3RzIGNvbnZlcnRlZCB0byBbT2JqZWN0IG9iamVjdF1cbiAgICAgICAgaWYgKHN0clZhbHVlID09PSBvYmpTdHJpbmdUYWcpIHJldHVybiB2YWx1ZTtcbiAgICAgICAgcmV0dXJuIHN0clZhbHVlO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgcmVxdWlyZWQobWVzc2FnZSkge1xuICAgIHJldHVybiBzdXBlci5yZXF1aXJlZChtZXNzYWdlKS53aXRoTXV0YXRpb24oc2NoZW1hID0+IHNjaGVtYS50ZXN0KHtcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UgfHwgbWl4ZWQucmVxdWlyZWQsXG4gICAgICBuYW1lOiAncmVxdWlyZWQnLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+ICEhdmFsdWUubGVuZ3RoXG4gICAgfSkpO1xuICB9XG4gIG5vdFJlcXVpcmVkKCkge1xuICAgIHJldHVybiBzdXBlci5ub3RSZXF1aXJlZCgpLndpdGhNdXRhdGlvbihzY2hlbWEgPT4ge1xuICAgICAgc2NoZW1hLnRlc3RzID0gc2NoZW1hLnRlc3RzLmZpbHRlcih0ID0+IHQuT1BUSU9OUy5uYW1lICE9PSAncmVxdWlyZWQnKTtcbiAgICAgIHJldHVybiBzY2hlbWE7XG4gICAgfSk7XG4gIH1cbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IHN0cmluZy5sZW5ndGgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbGVuZ3RoJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBsZW5ndGhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoID09PSB0aGlzLnJlc29sdmUobGVuZ3RoKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBtaW4obWluLCBtZXNzYWdlID0gc3RyaW5nLm1pbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IHN0cmluZy5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1hdGNoZXMocmVnZXgsIG9wdGlvbnMpIHtcbiAgICBsZXQgZXhjbHVkZUVtcHR5U3RyaW5nID0gZmFsc2U7XG4gICAgbGV0IG1lc3NhZ2U7XG4gICAgbGV0IG5hbWU7XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBleGNsdWRlRW1wdHlTdHJpbmcgPSBmYWxzZSxcbiAgICAgICAgICBtZXNzYWdlLFxuICAgICAgICAgIG5hbWVcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbmFtZTogbmFtZSB8fCAnbWF0Y2hlcycsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5tYXRjaGVzLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIHJlZ2V4XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHZhbHVlID09PSAnJyAmJiBleGNsdWRlRW1wdHlTdHJpbmcgfHwgdmFsdWUuc2VhcmNoKHJlZ2V4KSAhPT0gLTFcbiAgICB9KTtcbiAgfVxuICBlbWFpbChtZXNzYWdlID0gc3RyaW5nLmVtYWlsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyRW1haWwsIHtcbiAgICAgIG5hbWU6ICdlbWFpbCcsXG4gICAgICBtZXNzYWdlLFxuICAgICAgZXhjbHVkZUVtcHR5U3RyaW5nOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgdXJsKG1lc3NhZ2UgPSBzdHJpbmcudXJsKSB7XG4gICAgcmV0dXJuIHRoaXMubWF0Y2hlcyhyVXJsLCB7XG4gICAgICBuYW1lOiAndXJsJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KTtcbiAgfVxuICB1dWlkKG1lc3NhZ2UgPSBzdHJpbmcudXVpZCkge1xuICAgIHJldHVybiB0aGlzLm1hdGNoZXMoclVVSUQsIHtcbiAgICAgIG5hbWU6ICd1dWlkJyxcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IGZhbHNlXG4gICAgfSk7XG4gIH1cbiAgZGF0ZXRpbWUob3B0aW9ucykge1xuICAgIGxldCBtZXNzYWdlID0gJyc7XG4gICAgbGV0IGFsbG93T2Zmc2V0O1xuICAgIGxldCBwcmVjaXNpb247XG4gICAgaWYgKG9wdGlvbnMpIHtcbiAgICAgIGlmICh0eXBlb2Ygb3B0aW9ucyA9PT0gJ29iamVjdCcpIHtcbiAgICAgICAgKHtcbiAgICAgICAgICBtZXNzYWdlID0gJycsXG4gICAgICAgICAgYWxsb3dPZmZzZXQgPSBmYWxzZSxcbiAgICAgICAgICBwcmVjaXNpb24gPSB1bmRlZmluZWRcbiAgICAgICAgfSA9IG9wdGlvbnMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgbWVzc2FnZSA9IG9wdGlvbnM7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiB0aGlzLm1hdGNoZXMocklzb0RhdGVUaW1lLCB7XG4gICAgICBuYW1lOiAnZGF0ZXRpbWUnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWUsXG4gICAgICBleGNsdWRlRW1wdHlTdHJpbmc6IHRydWVcbiAgICB9KS50ZXN0KHtcbiAgICAgIG5hbWU6ICdkYXRldGltZV9vZmZzZXQnLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBzdHJpbmcuZGF0ZXRpbWVfb2Zmc2V0LFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGFsbG93T2Zmc2V0XG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBhbGxvd09mZnNldCkgcmV0dXJuIHRydWU7XG4gICAgICAgIGNvbnN0IHN0cnVjdCA9IHBhcnNlRGF0ZVN0cnVjdCh2YWx1ZSk7XG4gICAgICAgIGlmICghc3RydWN0KSByZXR1cm4gZmFsc2U7XG4gICAgICAgIHJldHVybiAhIXN0cnVjdC56O1xuICAgICAgfVxuICAgIH0pLnRlc3Qoe1xuICAgICAgbmFtZTogJ2RhdGV0aW1lX3ByZWNpc2lvbicsXG4gICAgICBtZXNzYWdlOiBtZXNzYWdlIHx8IHN0cmluZy5kYXRldGltZV9wcmVjaXNpb24sXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgcHJlY2lzaW9uXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbHVlID0+IHtcbiAgICAgICAgaWYgKCF2YWx1ZSB8fCBwcmVjaXNpb24gPT0gdW5kZWZpbmVkKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3Qgc3RydWN0ID0gcGFyc2VEYXRlU3RydWN0KHZhbHVlKTtcbiAgICAgICAgaWYgKCFzdHJ1Y3QpIHJldHVybiBmYWxzZTtcbiAgICAgICAgcmV0dXJuIHN0cnVjdC5wcmVjaXNpb24gPT09IHByZWNpc2lvbjtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuXG4gIC8vLS0gdHJhbnNmb3JtcyAtLVxuICBlbnN1cmUoKSB7XG4gICAgcmV0dXJuIHRoaXMuZGVmYXVsdCgnJykudHJhbnNmb3JtKHZhbCA9PiB2YWwgPT09IG51bGwgPyAnJyA6IHZhbCk7XG4gIH1cbiAgdHJpbShtZXNzYWdlID0gc3RyaW5nLnRyaW0pIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsID0+IHZhbCAhPSBudWxsID8gdmFsLnRyaW0oKSA6IHZhbCkudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ3RyaW0nLFxuICAgICAgdGVzdDogaXNUcmltbWVkXG4gICAgfSk7XG4gIH1cbiAgbG93ZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcubG93ZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b0xvd2VyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b0xvd2VyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbiAgdXBwZXJjYXNlKG1lc3NhZ2UgPSBzdHJpbmcudXBwZXJjYXNlKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKHZhbHVlID0+ICFpc0Fic2VudCh2YWx1ZSkgPyB2YWx1ZS50b1VwcGVyQ2FzZSgpIDogdmFsdWUpLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdzdHJpbmdfY2FzZScsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdDogdmFsdWUgPT4gaXNBYnNlbnQodmFsdWUpIHx8IHZhbHVlID09PSB2YWx1ZS50b1VwcGVyQ2FzZSgpXG4gICAgfSk7XG4gIH1cbn1cbmNyZWF0ZSQ2LnByb3RvdHlwZSA9IFN0cmluZ1NjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBTdHJpbmcgSW50ZXJmYWNlc1xuLy9cblxubGV0IGlzTmFOJDEgPSB2YWx1ZSA9PiB2YWx1ZSAhPSArdmFsdWU7XG5mdW5jdGlvbiBjcmVhdGUkNSgpIHtcbiAgcmV0dXJuIG5ldyBOdW1iZXJTY2hlbWEoKTtcbn1cbmNsYXNzIE51bWJlclNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdudW1iZXInLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgaWYgKHZhbHVlIGluc3RhbmNlb2YgTnVtYmVyKSB2YWx1ZSA9IHZhbHVlLnZhbHVlT2YoKTtcbiAgICAgICAgcmV0dXJuIHR5cGVvZiB2YWx1ZSA9PT0gJ251bWJlcicgJiYgIWlzTmFOJDEodmFsdWUpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIGlmICghY3R4LnNwZWMuY29lcmNlKSByZXR1cm4gdmFsdWU7XG4gICAgICAgIGxldCBwYXJzZWQgPSB2YWx1ZTtcbiAgICAgICAgaWYgKHR5cGVvZiBwYXJzZWQgPT09ICdzdHJpbmcnKSB7XG4gICAgICAgICAgcGFyc2VkID0gcGFyc2VkLnJlcGxhY2UoL1xccy9nLCAnJyk7XG4gICAgICAgICAgaWYgKHBhcnNlZCA9PT0gJycpIHJldHVybiBOYU47XG4gICAgICAgICAgLy8gZG9uJ3QgdXNlIHBhcnNlRmxvYXQgdG8gYXZvaWQgcG9zaXRpdmVzIG9uIGFscGhhLW51bWVyaWMgc3RyaW5nc1xuICAgICAgICAgIHBhcnNlZCA9ICtwYXJzZWQ7XG4gICAgICAgIH1cblxuICAgICAgICAvLyBudWxsIC0+IE5hTiBpc24ndCB1c2VmdWw7IHRyZWF0IGFsbCBudWxscyBhcyBudWxsIGFuZCBsZXQgaXQgZmFpbCBvblxuICAgICAgICAvLyBudWxsYWJpbGl0eSBjaGVjayB2cyBUeXBlRXJyb3JzXG4gICAgICAgIGlmIChjdHguaXNUeXBlKHBhcnNlZCkgfHwgcGFyc2VkID09PSBudWxsKSByZXR1cm4gcGFyc2VkO1xuICAgICAgICByZXR1cm4gcGFyc2VGbG9hdChwYXJzZWQpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgbWluKG1pbiwgbWVzc2FnZSA9IG51bWJlci5taW4pIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWluJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtaW5cbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSA9IG51bWJlci5tYXgpIHtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPD0gdGhpcy5yZXNvbHZlKG1heCk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbGVzc1RoYW4obGVzcywgbWVzc2FnZSA9IG51bWJlci5sZXNzVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlc3NcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPCB0aGlzLnJlc29sdmUobGVzcyk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbW9yZVRoYW4obW9yZSwgbWVzc2FnZSA9IG51bWJlci5tb3JlVGhhbikge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1vcmVcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUgPiB0aGlzLnJlc29sdmUobW9yZSk7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgcG9zaXRpdmUobXNnID0gbnVtYmVyLnBvc2l0aXZlKSB7XG4gICAgcmV0dXJuIHRoaXMubW9yZVRoYW4oMCwgbXNnKTtcbiAgfVxuICBuZWdhdGl2ZShtc2cgPSBudW1iZXIubmVnYXRpdmUpIHtcbiAgICByZXR1cm4gdGhpcy5sZXNzVGhhbigwLCBtc2cpO1xuICB9XG4gIGludGVnZXIobWVzc2FnZSA9IG51bWJlci5pbnRlZ2VyKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnaW50ZWdlcicsXG4gICAgICBtZXNzYWdlLFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIHRlc3Q6IHZhbCA9PiBOdW1iZXIuaXNJbnRlZ2VyKHZhbClcbiAgICB9KTtcbiAgfVxuICB0cnVuY2F0ZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IHZhbHVlIHwgMCA6IHZhbHVlKTtcbiAgfVxuICByb3VuZChtZXRob2QpIHtcbiAgICB2YXIgX21ldGhvZDtcbiAgICBsZXQgYXZhaWwgPSBbJ2NlaWwnLCAnZmxvb3InLCAncm91bmQnLCAndHJ1bmMnXTtcbiAgICBtZXRob2QgPSAoKF9tZXRob2QgPSBtZXRob2QpID09IG51bGwgPyB2b2lkIDAgOiBfbWV0aG9kLnRvTG93ZXJDYXNlKCkpIHx8ICdyb3VuZCc7XG5cbiAgICAvLyB0aGlzIGV4aXN0cyBmb3Igc3ltZW10cnkgd2l0aCB0aGUgbmV3IE1hdGgudHJ1bmNcbiAgICBpZiAobWV0aG9kID09PSAndHJ1bmMnKSByZXR1cm4gdGhpcy50cnVuY2F0ZSgpO1xuICAgIGlmIChhdmFpbC5pbmRleE9mKG1ldGhvZC50b0xvd2VyQ2FzZSgpKSA9PT0gLTEpIHRocm93IG5ldyBUeXBlRXJyb3IoJ09ubHkgdmFsaWQgb3B0aW9ucyBmb3Igcm91bmQoKSBhcmU6ICcgKyBhdmFpbC5qb2luKCcsICcpKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWUgPT4gIWlzQWJzZW50KHZhbHVlKSA/IE1hdGhbbWV0aG9kXSh2YWx1ZSkgOiB2YWx1ZSk7XG4gIH1cbn1cbmNyZWF0ZSQ1LnByb3RvdHlwZSA9IE51bWJlclNjaGVtYS5wcm90b3R5cGU7XG5cbi8vXG4vLyBOdW1iZXIgSW50ZXJmYWNlc1xuLy9cblxubGV0IGludmFsaWREYXRlID0gbmV3IERhdGUoJycpO1xubGV0IGlzRGF0ZSA9IG9iaiA9PiBPYmplY3QucHJvdG90eXBlLnRvU3RyaW5nLmNhbGwob2JqKSA9PT0gJ1tvYmplY3QgRGF0ZV0nO1xuZnVuY3Rpb24gY3JlYXRlJDQoKSB7XG4gIHJldHVybiBuZXcgRGF0ZVNjaGVtYSgpO1xufVxuY2xhc3MgRGF0ZVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKCkge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdkYXRlJyxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgcmV0dXJuIGlzRGF0ZSh2KSAmJiAhaXNOYU4odi5nZXRUaW1lKCkpO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHJhbnNmb3JtKCh2YWx1ZSwgX3JhdywgY3R4KSA9PiB7XG4gICAgICAgIC8vIG51bGwgLT4gSW52YWxpZERhdGUgaXNuJ3QgdXNlZnVsOyB0cmVhdCBhbGwgbnVsbHMgYXMgbnVsbCBhbmQgbGV0IGl0IGZhaWwgb25cbiAgICAgICAgLy8gbnVsbGFiaWxpdHkgY2hlY2sgdnMgVHlwZUVycm9yc1xuICAgICAgICBpZiAoIWN0eC5zcGVjLmNvZXJjZSB8fCBjdHguaXNUeXBlKHZhbHVlKSB8fCB2YWx1ZSA9PT0gbnVsbCkgcmV0dXJuIHZhbHVlO1xuICAgICAgICB2YWx1ZSA9IHBhcnNlSXNvRGF0ZSh2YWx1ZSk7XG5cbiAgICAgICAgLy8gMCBpcyBhIHZhbGlkIHRpbWVzdGFtcCBlcXVpdmFsZW50IHRvIDE5NzAtMDEtMDFUMDA6MDA6MDBaKHVuaXggZXBvY2gpIG9yIGJlZm9yZS5cbiAgICAgICAgcmV0dXJuICFpc05hTih2YWx1ZSkgPyBuZXcgRGF0ZSh2YWx1ZSkgOiBEYXRlU2NoZW1hLklOVkFMSURfREFURTtcbiAgICAgIH0pO1xuICAgIH0pO1xuICB9XG4gIHByZXBhcmVQYXJhbShyZWYsIG5hbWUpIHtcbiAgICBsZXQgcGFyYW07XG4gICAgaWYgKCFSZWZlcmVuY2UuaXNSZWYocmVmKSkge1xuICAgICAgbGV0IGNhc3QgPSB0aGlzLmNhc3QocmVmKTtcbiAgICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKGNhc3QpKSB0aHJvdyBuZXcgVHlwZUVycm9yKGBcXGAke25hbWV9XFxgIG11c3QgYmUgYSBEYXRlIG9yIGEgdmFsdWUgdGhhdCBjYW4gYmUgXFxgY2FzdCgpXFxgIHRvIGEgRGF0ZWApO1xuICAgICAgcGFyYW0gPSBjYXN0O1xuICAgIH0gZWxzZSB7XG4gICAgICBwYXJhbSA9IHJlZjtcbiAgICB9XG4gICAgcmV0dXJuIHBhcmFtO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UgPSBkYXRlLm1pbikge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1pbiwgJ21pbicpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtaW4nLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1pblxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA+PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1heChtYXgsIG1lc3NhZ2UgPSBkYXRlLm1heCkge1xuICAgIGxldCBsaW1pdCA9IHRoaXMucHJlcGFyZVBhcmFtKG1heCwgJ21heCcpO1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdtYXgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIG1heFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZSA8PSB0aGlzLnJlc29sdmUobGltaXQpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG59XG5EYXRlU2NoZW1hLklOVkFMSURfREFURSA9IGludmFsaWREYXRlO1xuY3JlYXRlJDQucHJvdG90eXBlID0gRGF0ZVNjaGVtYS5wcm90b3R5cGU7XG5jcmVhdGUkNC5JTlZBTElEX0RBVEUgPSBpbnZhbGlkRGF0ZTtcblxuLy8gQHRzLWV4cGVjdC1lcnJvclxuZnVuY3Rpb24gc29ydEZpZWxkcyhmaWVsZHMsIGV4Y2x1ZGVkRWRnZXMgPSBbXSkge1xuICBsZXQgZWRnZXMgPSBbXTtcbiAgbGV0IG5vZGVzID0gbmV3IFNldCgpO1xuICBsZXQgZXhjbHVkZXMgPSBuZXcgU2V0KGV4Y2x1ZGVkRWRnZXMubWFwKChbYSwgYl0pID0+IGAke2F9LSR7Yn1gKSk7XG4gIGZ1bmN0aW9uIGFkZE5vZGUoZGVwUGF0aCwga2V5KSB7XG4gICAgbGV0IG5vZGUgPSBzcGxpdChkZXBQYXRoKVswXTtcbiAgICBub2Rlcy5hZGQobm9kZSk7XG4gICAgaWYgKCFleGNsdWRlcy5oYXMoYCR7a2V5fS0ke25vZGV9YCkpIGVkZ2VzLnB1c2goW2tleSwgbm9kZV0pO1xuICB9XG4gIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICBsZXQgdmFsdWUgPSBmaWVsZHNba2V5XTtcbiAgICBub2Rlcy5hZGQoa2V5KTtcbiAgICBpZiAoUmVmZXJlbmNlLmlzUmVmKHZhbHVlKSAmJiB2YWx1ZS5pc1NpYmxpbmcpIGFkZE5vZGUodmFsdWUucGF0aCwga2V5KTtlbHNlIGlmIChpc1NjaGVtYSh2YWx1ZSkgJiYgJ2RlcHMnIGluIHZhbHVlKSB2YWx1ZS5kZXBzLmZvckVhY2gocGF0aCA9PiBhZGROb2RlKHBhdGgsIGtleSkpO1xuICB9XG4gIHJldHVybiB0b3Bvc29ydC5hcnJheShBcnJheS5mcm9tKG5vZGVzKSwgZWRnZXMpLnJldmVyc2UoKTtcbn1cblxuZnVuY3Rpb24gZmluZEluZGV4KGFyciwgZXJyKSB7XG4gIGxldCBpZHggPSBJbmZpbml0eTtcbiAgYXJyLnNvbWUoKGtleSwgaWkpID0+IHtcbiAgICB2YXIgX2VyciRwYXRoO1xuICAgIGlmICgoX2VyciRwYXRoID0gZXJyLnBhdGgpICE9IG51bGwgJiYgX2VyciRwYXRoLmluY2x1ZGVzKGtleSkpIHtcbiAgICAgIGlkeCA9IGlpO1xuICAgICAgcmV0dXJuIHRydWU7XG4gICAgfVxuICB9KTtcbiAgcmV0dXJuIGlkeDtcbn1cbmZ1bmN0aW9uIHNvcnRCeUtleU9yZGVyKGtleXMpIHtcbiAgcmV0dXJuIChhLCBiKSA9PiB7XG4gICAgcmV0dXJuIGZpbmRJbmRleChrZXlzLCBhKSAtIGZpbmRJbmRleChrZXlzLCBiKTtcbiAgfTtcbn1cblxuY29uc3QgcGFyc2VKc29uID0gKHZhbHVlLCBfLCBjdHgpID0+IHtcbiAgaWYgKHR5cGVvZiB2YWx1ZSAhPT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gdmFsdWU7XG4gIH1cbiAgbGV0IHBhcnNlZCA9IHZhbHVlO1xuICB0cnkge1xuICAgIHBhcnNlZCA9IEpTT04ucGFyc2UodmFsdWUpO1xuICB9IGNhdGNoIChlcnIpIHtcbiAgICAvKiAqL1xuICB9XG4gIHJldHVybiBjdHguaXNUeXBlKHBhcnNlZCkgPyBwYXJzZWQgOiB2YWx1ZTtcbn07XG5cbi8vIEB0cy1pZ25vcmVcbmZ1bmN0aW9uIGRlZXBQYXJ0aWFsKHNjaGVtYSkge1xuICBpZiAoJ2ZpZWxkcycgaW4gc2NoZW1hKSB7XG4gICAgY29uc3QgcGFydGlhbCA9IHt9O1xuICAgIGZvciAoY29uc3QgW2tleSwgZmllbGRTY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHNjaGVtYS5maWVsZHMpKSB7XG4gICAgICBwYXJ0aWFsW2tleV0gPSBkZWVwUGFydGlhbChmaWVsZFNjaGVtYSk7XG4gICAgfVxuICAgIHJldHVybiBzY2hlbWEuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGlmIChzY2hlbWEudHlwZSA9PT0gJ2FycmF5Jykge1xuICAgIGNvbnN0IG5leHRBcnJheSA9IHNjaGVtYS5vcHRpb25hbCgpO1xuICAgIGlmIChuZXh0QXJyYXkuaW5uZXJUeXBlKSBuZXh0QXJyYXkuaW5uZXJUeXBlID0gZGVlcFBhcnRpYWwobmV4dEFycmF5LmlubmVyVHlwZSk7XG4gICAgcmV0dXJuIG5leHRBcnJheTtcbiAgfVxuICBpZiAoc2NoZW1hLnR5cGUgPT09ICd0dXBsZScpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCkuY2xvbmUoe1xuICAgICAgdHlwZXM6IHNjaGVtYS5zcGVjLnR5cGVzLm1hcChkZWVwUGFydGlhbClcbiAgICB9KTtcbiAgfVxuICBpZiAoJ29wdGlvbmFsJyBpbiBzY2hlbWEpIHtcbiAgICByZXR1cm4gc2NoZW1hLm9wdGlvbmFsKCk7XG4gIH1cbiAgcmV0dXJuIHNjaGVtYTtcbn1cbmNvbnN0IGRlZXBIYXMgPSAob2JqLCBwKSA9PiB7XG4gIGNvbnN0IHBhdGggPSBbLi4ubm9ybWFsaXplUGF0aChwKV07XG4gIGlmIChwYXRoLmxlbmd0aCA9PT0gMSkgcmV0dXJuIHBhdGhbMF0gaW4gb2JqO1xuICBsZXQgbGFzdCA9IHBhdGgucG9wKCk7XG4gIGxldCBwYXJlbnQgPSBnZXR0ZXIoam9pbihwYXRoKSwgdHJ1ZSkob2JqKTtcbiAgcmV0dXJuICEhKHBhcmVudCAmJiBsYXN0IGluIHBhcmVudCk7XG59O1xubGV0IGlzT2JqZWN0ID0gb2JqID0+IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvYmopID09PSAnW29iamVjdCBPYmplY3RdJztcbmZ1bmN0aW9uIHVua25vd24oY3R4LCB2YWx1ZSkge1xuICBsZXQga25vd24gPSBPYmplY3Qua2V5cyhjdHguZmllbGRzKTtcbiAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIoa2V5ID0+IGtub3duLmluZGV4T2Yoa2V5KSA9PT0gLTEpO1xufVxuY29uc3QgZGVmYXVsdFNvcnQgPSBzb3J0QnlLZXlPcmRlcihbXSk7XG5mdW5jdGlvbiBjcmVhdGUkMyhzcGVjKSB7XG4gIHJldHVybiBuZXcgT2JqZWN0U2NoZW1hKHNwZWMpO1xufVxuY2xhc3MgT2JqZWN0U2NoZW1hIGV4dGVuZHMgU2NoZW1hIHtcbiAgY29uc3RydWN0b3Ioc3BlYykge1xuICAgIHN1cGVyKHtcbiAgICAgIHR5cGU6ICdvYmplY3QnLFxuICAgICAgY2hlY2sodmFsdWUpIHtcbiAgICAgICAgcmV0dXJuIGlzT2JqZWN0KHZhbHVlKSB8fCB0eXBlb2YgdmFsdWUgPT09ICdmdW5jdGlvbic7XG4gICAgICB9XG4gICAgfSk7XG4gICAgdGhpcy5maWVsZHMgPSBPYmplY3QuY3JlYXRlKG51bGwpO1xuICAgIHRoaXMuX3NvcnRFcnJvcnMgPSBkZWZhdWx0U29ydDtcbiAgICB0aGlzLl9ub2RlcyA9IFtdO1xuICAgIHRoaXMuX2V4Y2x1ZGVkRWRnZXMgPSBbXTtcbiAgICB0aGlzLndpdGhNdXRhdGlvbigoKSA9PiB7XG4gICAgICBpZiAoc3BlYykge1xuICAgICAgICB0aGlzLnNoYXBlKHNwZWMpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIF9jYXN0KF92YWx1ZSwgb3B0aW9ucyA9IHt9KSB7XG4gICAgdmFyIF9vcHRpb25zJHN0cmlwVW5rbm93bjtcbiAgICBsZXQgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIG9wdGlvbnMpO1xuXG4gICAgLy9zaG91bGQgaWdub3JlIG51bGxzIGhlcmVcbiAgICBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkgcmV0dXJuIHRoaXMuZ2V0RGVmYXVsdChvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHJldHVybiB2YWx1ZTtcbiAgICBsZXQgZmllbGRzID0gdGhpcy5maWVsZHM7XG4gICAgbGV0IHN0cmlwID0gKF9vcHRpb25zJHN0cmlwVW5rbm93biA9IG9wdGlvbnMuc3RyaXBVbmtub3duKSAhPSBudWxsID8gX29wdGlvbnMkc3RyaXBVbmtub3duIDogdGhpcy5zcGVjLm5vVW5rbm93bjtcbiAgICBsZXQgcHJvcHMgPSBbXS5jb25jYXQodGhpcy5fbm9kZXMsIE9iamVjdC5rZXlzKHZhbHVlKS5maWx0ZXIodiA9PiAhdGhpcy5fbm9kZXMuaW5jbHVkZXModikpKTtcbiAgICBsZXQgaW50ZXJtZWRpYXRlVmFsdWUgPSB7fTsgLy8gaXMgZmlsbGVkIGR1cmluZyB0aGUgdHJhbnNmb3JtIGJlbG93XG4gICAgbGV0IGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIG9wdGlvbnMsIHtcbiAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWUsXG4gICAgICBfX3ZhbGlkYXRpbmc6IG9wdGlvbnMuX192YWxpZGF0aW5nIHx8IGZhbHNlXG4gICAgfSk7XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGZvciAoY29uc3QgcHJvcCBvZiBwcm9wcykge1xuICAgICAgbGV0IGZpZWxkID0gZmllbGRzW3Byb3BdO1xuICAgICAgbGV0IGV4aXN0cyA9IChwcm9wIGluIHZhbHVlKTtcbiAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICBsZXQgZmllbGRWYWx1ZTtcbiAgICAgICAgbGV0IGlucHV0VmFsdWUgPSB2YWx1ZVtwcm9wXTtcblxuICAgICAgICAvLyBzYWZlIHRvIG11dGF0ZSBzaW5jZSB0aGlzIGlzIGZpcmVkIGluIHNlcXVlbmNlXG4gICAgICAgIGlubmVyT3B0aW9ucy5wYXRoID0gKG9wdGlvbnMucGF0aCA/IGAke29wdGlvbnMucGF0aH0uYCA6ICcnKSArIHByb3A7XG4gICAgICAgIGZpZWxkID0gZmllbGQucmVzb2x2ZSh7XG4gICAgICAgICAgdmFsdWU6IGlucHV0VmFsdWUsXG4gICAgICAgICAgY29udGV4dDogb3B0aW9ucy5jb250ZXh0LFxuICAgICAgICAgIHBhcmVudDogaW50ZXJtZWRpYXRlVmFsdWVcbiAgICAgICAgfSk7XG4gICAgICAgIGxldCBmaWVsZFNwZWMgPSBmaWVsZCBpbnN0YW5jZW9mIFNjaGVtYSA/IGZpZWxkLnNwZWMgOiB1bmRlZmluZWQ7XG4gICAgICAgIGxldCBzdHJpY3QgPSBmaWVsZFNwZWMgPT0gbnVsbCA/IHZvaWQgMCA6IGZpZWxkU3BlYy5zdHJpY3Q7XG4gICAgICAgIGlmIChmaWVsZFNwZWMgIT0gbnVsbCAmJiBmaWVsZFNwZWMuc3RyaXApIHtcbiAgICAgICAgICBpc0NoYW5nZWQgPSBpc0NoYW5nZWQgfHwgcHJvcCBpbiB2YWx1ZTtcbiAgICAgICAgICBjb250aW51ZTtcbiAgICAgICAgfVxuICAgICAgICBmaWVsZFZhbHVlID0gIW9wdGlvbnMuX192YWxpZGF0aW5nIHx8ICFzdHJpY3QgP1xuICAgICAgICAvLyBUT0RPOiB1c2UgX2Nhc3QsIHRoaXMgaXMgZG91YmxlIHJlc29sdmluZ1xuICAgICAgICBmaWVsZC5jYXN0KHZhbHVlW3Byb3BdLCBpbm5lck9wdGlvbnMpIDogdmFsdWVbcHJvcF07XG4gICAgICAgIGlmIChmaWVsZFZhbHVlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IGZpZWxkVmFsdWU7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSBpZiAoZXhpc3RzICYmICFzdHJpcCkge1xuICAgICAgICBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSA9IHZhbHVlW3Byb3BdO1xuICAgICAgfVxuICAgICAgaWYgKGV4aXN0cyAhPT0gcHJvcCBpbiBpbnRlcm1lZGlhdGVWYWx1ZSB8fCBpbnRlcm1lZGlhdGVWYWx1ZVtwcm9wXSAhPT0gdmFsdWVbcHJvcF0pIHtcbiAgICAgICAgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGlzQ2hhbmdlZCA/IGludGVybWVkaWF0ZVZhbHVlIDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCB7XG4gICAgICBmcm9tID0gW10sXG4gICAgICBvcmlnaW5hbFZhbHVlID0gX3ZhbHVlLFxuICAgICAgcmVjdXJzaXZlID0gdGhpcy5zcGVjLnJlY3Vyc2l2ZVxuICAgIH0gPSBvcHRpb25zO1xuICAgIG9wdGlvbnMuZnJvbSA9IFt7XG4gICAgICBzY2hlbWE6IHRoaXMsXG4gICAgICB2YWx1ZTogb3JpZ2luYWxWYWx1ZVxuICAgIH0sIC4uLmZyb21dO1xuICAgIC8vIHRoaXMgZmxhZyBpcyBuZWVkZWQgZm9yIGhhbmRsaW5nIGBzdHJpY3RgIGNvcnJlY3RseSBpbiB0aGUgY29udGV4dCBvZlxuICAgIC8vIHZhbGlkYXRpb24gdnMganVzdCBjYXN0aW5nLiBlLmcgc3RyaWN0KCkgb24gYSBmaWVsZCBpcyBvbmx5IHVzZWQgd2hlbiB2YWxpZGF0aW5nXG4gICAgb3B0aW9ucy5fX3ZhbGlkYXRpbmcgPSB0cnVlO1xuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSA9IG9yaWdpbmFsVmFsdWU7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsIChvYmplY3RFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICBpZiAoIXJlY3Vyc2l2ZSB8fCAhaXNPYmplY3QodmFsdWUpKSB7XG4gICAgICAgIG5leHQob2JqZWN0RXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIG9yaWdpbmFsVmFsdWUgPSBvcmlnaW5hbFZhbHVlIHx8IHZhbHVlO1xuICAgICAgbGV0IHRlc3RzID0gW107XG4gICAgICBmb3IgKGxldCBrZXkgb2YgdGhpcy5fbm9kZXMpIHtcbiAgICAgICAgbGV0IGZpZWxkID0gdGhpcy5maWVsZHNba2V5XTtcbiAgICAgICAgaWYgKCFmaWVsZCB8fCBSZWZlcmVuY2UuaXNSZWYoZmllbGQpKSB7XG4gICAgICAgICAgY29udGludWU7XG4gICAgICAgIH1cbiAgICAgICAgdGVzdHMucHVzaChmaWVsZC5hc05lc3RlZFRlc3Qoe1xuICAgICAgICAgIG9wdGlvbnMsXG4gICAgICAgICAga2V5LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiBvcmlnaW5hbFZhbHVlXG4gICAgICAgIH0pKTtcbiAgICAgIH1cbiAgICAgIHRoaXMucnVuVGVzdHMoe1xuICAgICAgICB0ZXN0cyxcbiAgICAgICAgdmFsdWUsXG4gICAgICAgIG9yaWdpbmFsVmFsdWUsXG4gICAgICAgIG9wdGlvbnNcbiAgICAgIH0sIHBhbmljLCBmaWVsZEVycm9ycyA9PiB7XG4gICAgICAgIG5leHQoZmllbGRFcnJvcnMuc29ydCh0aGlzLl9zb3J0RXJyb3JzKS5jb25jYXQob2JqZWN0RXJyb3JzKSwgdmFsdWUpO1xuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcbiAgICBuZXh0LmZpZWxkcyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuZmllbGRzKTtcbiAgICBuZXh0Ll9ub2RlcyA9IHRoaXMuX25vZGVzO1xuICAgIG5leHQuX2V4Y2x1ZGVkRWRnZXMgPSB0aGlzLl9leGNsdWRlZEVkZ2VzO1xuICAgIG5leHQuX3NvcnRFcnJvcnMgPSB0aGlzLl9zb3J0RXJyb3JzO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIGNvbmNhdChzY2hlbWEpIHtcbiAgICBsZXQgbmV4dCA9IHN1cGVyLmNvbmNhdChzY2hlbWEpO1xuICAgIGxldCBuZXh0RmllbGRzID0gbmV4dC5maWVsZHM7XG4gICAgZm9yIChsZXQgW2ZpZWxkLCBzY2hlbWFPclJlZl0gb2YgT2JqZWN0LmVudHJpZXModGhpcy5maWVsZHMpKSB7XG4gICAgICBjb25zdCB0YXJnZXQgPSBuZXh0RmllbGRzW2ZpZWxkXTtcbiAgICAgIG5leHRGaWVsZHNbZmllbGRdID0gdGFyZ2V0ID09PSB1bmRlZmluZWQgPyBzY2hlbWFPclJlZiA6IHRhcmdldDtcbiAgICB9XG4gICAgcmV0dXJuIG5leHQud2l0aE11dGF0aW9uKHMgPT5cbiAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICBzLnNldEZpZWxkcyhuZXh0RmllbGRzLCBbLi4udGhpcy5fZXhjbHVkZWRFZGdlcywgLi4uc2NoZW1hLl9leGNsdWRlZEVkZ2VzXSkpO1xuICB9XG4gIF9nZXREZWZhdWx0KG9wdGlvbnMpIHtcbiAgICBpZiAoJ2RlZmF1bHQnIGluIHRoaXMuc3BlYykge1xuICAgICAgcmV0dXJuIHN1cGVyLl9nZXREZWZhdWx0KG9wdGlvbnMpO1xuICAgIH1cblxuICAgIC8vIGlmIHRoZXJlIGlzIG5vIGRlZmF1bHQgc2V0IGludmVudCBvbmVcbiAgICBpZiAoIXRoaXMuX25vZGVzLmxlbmd0aCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgbGV0IGRmdCA9IHt9O1xuICAgIHRoaXMuX25vZGVzLmZvckVhY2goa2V5ID0+IHtcbiAgICAgIHZhciBfaW5uZXJPcHRpb25zO1xuICAgICAgY29uc3QgZmllbGQgPSB0aGlzLmZpZWxkc1trZXldO1xuICAgICAgbGV0IGlubmVyT3B0aW9ucyA9IG9wdGlvbnM7XG4gICAgICBpZiAoKF9pbm5lck9wdGlvbnMgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9ucy52YWx1ZSkge1xuICAgICAgICBpbm5lck9wdGlvbnMgPSBPYmplY3QuYXNzaWduKHt9LCBpbm5lck9wdGlvbnMsIHtcbiAgICAgICAgICBwYXJlbnQ6IGlubmVyT3B0aW9ucy52YWx1ZSxcbiAgICAgICAgICB2YWx1ZTogaW5uZXJPcHRpb25zLnZhbHVlW2tleV1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBkZnRba2V5XSA9IGZpZWxkICYmICdnZXREZWZhdWx0JyBpbiBmaWVsZCA/IGZpZWxkLmdldERlZmF1bHQoaW5uZXJPcHRpb25zKSA6IHVuZGVmaW5lZDtcbiAgICB9KTtcbiAgICByZXR1cm4gZGZ0O1xuICB9XG4gIHNldEZpZWxkcyhzaGFwZSwgZXhjbHVkZWRFZGdlcykge1xuICAgIGxldCBuZXh0ID0gdGhpcy5jbG9uZSgpO1xuICAgIG5leHQuZmllbGRzID0gc2hhcGU7XG4gICAgbmV4dC5fbm9kZXMgPSBzb3J0RmllbGRzKHNoYXBlLCBleGNsdWRlZEVkZ2VzKTtcbiAgICBuZXh0Ll9zb3J0RXJyb3JzID0gc29ydEJ5S2V5T3JkZXIoT2JqZWN0LmtleXMoc2hhcGUpKTtcbiAgICAvLyBYWFg6IHRoaXMgY2FycmllcyBvdmVyIGVkZ2VzIHdoaWNoIG1heSBub3QgYmUgd2hhdCB5b3Ugd2FudFxuICAgIGlmIChleGNsdWRlZEVkZ2VzKSBuZXh0Ll9leGNsdWRlZEVkZ2VzID0gZXhjbHVkZWRFZGdlcztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBzaGFwZShhZGRpdGlvbnMsIGV4Y2x1ZGVzID0gW10pIHtcbiAgICByZXR1cm4gdGhpcy5jbG9uZSgpLndpdGhNdXRhdGlvbihuZXh0ID0+IHtcbiAgICAgIGxldCBlZGdlcyA9IG5leHQuX2V4Y2x1ZGVkRWRnZXM7XG4gICAgICBpZiAoZXhjbHVkZXMubGVuZ3RoKSB7XG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShleGNsdWRlc1swXSkpIGV4Y2x1ZGVzID0gW2V4Y2x1ZGVzXTtcbiAgICAgICAgZWRnZXMgPSBbLi4ubmV4dC5fZXhjbHVkZWRFZGdlcywgLi4uZXhjbHVkZXNdO1xuICAgICAgfVxuXG4gICAgICAvLyBYWFg6IGV4Y2x1ZGVzIGhlcmUgaXMgd3JvbmdcbiAgICAgIHJldHVybiBuZXh0LnNldEZpZWxkcyhPYmplY3QuYXNzaWduKG5leHQuZmllbGRzLCBhZGRpdGlvbnMpLCBlZGdlcyk7XG4gICAgfSk7XG4gIH1cbiAgcGFydGlhbCgpIHtcbiAgICBjb25zdCBwYXJ0aWFsID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCBzY2hlbWFdIG9mIE9iamVjdC5lbnRyaWVzKHRoaXMuZmllbGRzKSkge1xuICAgICAgcGFydGlhbFtrZXldID0gJ29wdGlvbmFsJyBpbiBzY2hlbWEgJiYgc2NoZW1hLm9wdGlvbmFsIGluc3RhbmNlb2YgRnVuY3Rpb24gPyBzY2hlbWEub3B0aW9uYWwoKSA6IHNjaGVtYTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMuc2V0RmllbGRzKHBhcnRpYWwpO1xuICB9XG4gIGRlZXBQYXJ0aWFsKCkge1xuICAgIGNvbnN0IG5leHQgPSBkZWVwUGFydGlhbCh0aGlzKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBwaWNrKGtleXMpIHtcbiAgICBjb25zdCBwaWNrZWQgPSB7fTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBrZXlzKSB7XG4gICAgICBpZiAodGhpcy5maWVsZHNba2V5XSkgcGlja2VkW2tleV0gPSB0aGlzLmZpZWxkc1trZXldO1xuICAgIH1cbiAgICByZXR1cm4gdGhpcy5zZXRGaWVsZHMocGlja2VkLCB0aGlzLl9leGNsdWRlZEVkZ2VzLmZpbHRlcigoW2EsIGJdKSA9PiBrZXlzLmluY2x1ZGVzKGEpICYmIGtleXMuaW5jbHVkZXMoYikpKTtcbiAgfVxuICBvbWl0KGtleXMpIHtcbiAgICBjb25zdCByZW1haW5pbmcgPSBbXTtcbiAgICBmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyh0aGlzLmZpZWxkcykpIHtcbiAgICAgIGlmIChrZXlzLmluY2x1ZGVzKGtleSkpIGNvbnRpbnVlO1xuICAgICAgcmVtYWluaW5nLnB1c2goa2V5KTtcbiAgICB9XG4gICAgcmV0dXJuIHRoaXMucGljayhyZW1haW5pbmcpO1xuICB9XG4gIGZyb20oZnJvbSwgdG8sIGFsaWFzKSB7XG4gICAgbGV0IGZyb21HZXR0ZXIgPSBnZXR0ZXIoZnJvbSwgdHJ1ZSk7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGxldCBuZXdPYmogPSBvYmo7XG4gICAgICBpZiAoZGVlcEhhcyhvYmosIGZyb20pKSB7XG4gICAgICAgIG5ld09iaiA9IE9iamVjdC5hc3NpZ24oe30sIG9iaik7XG4gICAgICAgIGlmICghYWxpYXMpIGRlbGV0ZSBuZXdPYmpbZnJvbV07XG4gICAgICAgIG5ld09ialt0b10gPSBmcm9tR2V0dGVyKG9iaik7XG4gICAgICB9XG4gICAgICByZXR1cm4gbmV3T2JqO1xuICAgIH0pO1xuICB9XG5cbiAgLyoqIFBhcnNlIGFuIGlucHV0IEpTT04gc3RyaW5nIHRvIGFuIG9iamVjdCAqL1xuICBqc29uKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybShwYXJzZUpzb24pO1xuICB9XG5cbiAgLyoqXG4gICAqIFNpbWlsYXIgdG8gYG5vVW5rbm93bmAgYnV0IG9ubHkgdmFsaWRhdGVzIHRoYXQgYW4gb2JqZWN0IGlzIHRoZSByaWdodCBzaGFwZSB3aXRob3V0IHN0cmlwcGluZyB0aGUgdW5rbm93biBrZXlzXG4gICAqL1xuICBleGFjdChtZXNzYWdlKSB7XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnZXhhY3QnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgbWVzc2FnZTogbWVzc2FnZSB8fCBvYmplY3QuZXhhY3QsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB1bmtub3duKHRoaXMuc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiB1bmtub3duS2V5cy5sZW5ndGggPT09IDAgfHwgdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICBwcm9wZXJ0aWVzOiB1bmtub3duS2V5cy5qb2luKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxuICBzdHJpcFVua25vd24oKSB7XG4gICAgcmV0dXJuIHRoaXMuY2xvbmUoe1xuICAgICAgbm9Vbmtub3duOiB0cnVlXG4gICAgfSk7XG4gIH1cbiAgbm9Vbmtub3duKG5vQWxsb3cgPSB0cnVlLCBtZXNzYWdlID0gb2JqZWN0Lm5vVW5rbm93bikge1xuICAgIGlmICh0eXBlb2Ygbm9BbGxvdyAhPT0gJ2Jvb2xlYW4nKSB7XG4gICAgICBtZXNzYWdlID0gbm9BbGxvdztcbiAgICAgIG5vQWxsb3cgPSB0cnVlO1xuICAgIH1cbiAgICBsZXQgbmV4dCA9IHRoaXMudGVzdCh7XG4gICAgICBuYW1lOiAnbm9Vbmtub3duJyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIG1lc3NhZ2U6IG1lc3NhZ2UsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIGlmICh2YWx1ZSA9PSBudWxsKSByZXR1cm4gdHJ1ZTtcbiAgICAgICAgY29uc3QgdW5rbm93bktleXMgPSB1bmtub3duKHRoaXMuc2NoZW1hLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybiAhbm9BbGxvdyB8fCB1bmtub3duS2V5cy5sZW5ndGggPT09IDAgfHwgdGhpcy5jcmVhdGVFcnJvcih7XG4gICAgICAgICAgcGFyYW1zOiB7XG4gICAgICAgICAgICB1bmtub3duOiB1bmtub3duS2V5cy5qb2luKCcsICcpXG4gICAgICAgICAgfVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICBuZXh0LnNwZWMubm9Vbmtub3duID0gbm9BbGxvdztcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICB1bmtub3duKGFsbG93ID0gdHJ1ZSwgbWVzc2FnZSA9IG9iamVjdC5ub1Vua25vd24pIHtcbiAgICByZXR1cm4gdGhpcy5ub1Vua25vd24oIWFsbG93LCBtZXNzYWdlKTtcbiAgfVxuICB0cmFuc2Zvcm1LZXlzKGZuKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtKG9iaiA9PiB7XG4gICAgICBpZiAoIW9iaikgcmV0dXJuIG9iajtcbiAgICAgIGNvbnN0IHJlc3VsdCA9IHt9O1xuICAgICAgZm9yIChjb25zdCBrZXkgb2YgT2JqZWN0LmtleXMob2JqKSkgcmVzdWx0W2ZuKGtleSldID0gb2JqW2tleV07XG4gICAgICByZXR1cm4gcmVzdWx0O1xuICAgIH0pO1xuICB9XG4gIGNhbWVsQ2FzZSgpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm1LZXlzKGNhbWVsQ2FzZSk7XG4gIH1cbiAgc25ha2VDYXNlKCkge1xuICAgIHJldHVybiB0aGlzLnRyYW5zZm9ybUtleXMoc25ha2VDYXNlKTtcbiAgfVxuICBjb25zdGFudENhc2UoKSB7XG4gICAgcmV0dXJuIHRoaXMudHJhbnNmb3JtS2V5cyhrZXkgPT4gc25ha2VDYXNlKGtleSkudG9VcHBlckNhc2UoKSk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGJhc2UuZmllbGRzID0ge307XG4gICAgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgT2JqZWN0LmVudHJpZXMobmV4dC5maWVsZHMpKSB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9uczI7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9uczIgPSBpbm5lck9wdGlvbnMpICE9IG51bGwgJiYgX2lubmVyT3B0aW9uczIudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVtrZXldXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgYmFzZS5maWVsZHNba2V5XSA9IHZhbHVlLmRlc2NyaWJlKGlubmVyT3B0aW9ucyk7XG4gICAgfVxuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMy5wcm90b3R5cGUgPSBPYmplY3RTY2hlbWEucHJvdG90eXBlO1xuXG5mdW5jdGlvbiBjcmVhdGUkMih0eXBlKSB7XG4gIHJldHVybiBuZXcgQXJyYXlTY2hlbWEodHlwZSk7XG59XG5jbGFzcyBBcnJheVNjaGVtYSBleHRlbmRzIFNjaGVtYSB7XG4gIGNvbnN0cnVjdG9yKHR5cGUpIHtcbiAgICBzdXBlcih7XG4gICAgICB0eXBlOiAnYXJyYXknLFxuICAgICAgc3BlYzoge1xuICAgICAgICB0eXBlczogdHlwZVxuICAgICAgfSxcbiAgICAgIGNoZWNrKHYpIHtcbiAgICAgICAgcmV0dXJuIEFycmF5LmlzQXJyYXkodik7XG4gICAgICB9XG4gICAgfSk7XG5cbiAgICAvLyBgdW5kZWZpbmVkYCBzcGVjaWZpY2FsbHkgbWVhbnMgdW5pbml0aWFsaXplZCwgYXMgb3Bwb3NlZCB0byBcIm5vIHN1YnR5cGVcIlxuICAgIHRoaXMuaW5uZXJUeXBlID0gdm9pZCAwO1xuICAgIHRoaXMuaW5uZXJUeXBlID0gdHlwZTtcbiAgfVxuICBfY2FzdChfdmFsdWUsIF9vcHRzKSB7XG4gICAgY29uc3QgdmFsdWUgPSBzdXBlci5fY2FzdChfdmFsdWUsIF9vcHRzKTtcblxuICAgIC8vIHNob3VsZCBpZ25vcmUgbnVsbHMgaGVyZVxuICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSB8fCAhdGhpcy5pbm5lclR5cGUpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhc3RBcnJheSA9IHZhbHVlLm1hcCgodiwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBjYXN0RWxlbWVudCA9IHRoaXMuaW5uZXJUeXBlLmNhc3QodiwgT2JqZWN0LmFzc2lnbih7fSwgX29wdHMsIHtcbiAgICAgICAgcGF0aDogYCR7X29wdHMucGF0aCB8fCAnJ31bJHtpZHh9XWBcbiAgICAgIH0pKTtcbiAgICAgIGlmIChjYXN0RWxlbWVudCAhPT0gdikge1xuICAgICAgICBpc0NoYW5nZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgcmV0dXJuIGNhc3RFbGVtZW50O1xuICAgIH0pO1xuICAgIHJldHVybiBpc0NoYW5nZWQgPyBjYXN0QXJyYXkgOiB2YWx1ZTtcbiAgfVxuICBfdmFsaWRhdGUoX3ZhbHVlLCBvcHRpb25zID0ge30sIHBhbmljLCBuZXh0KSB7XG4gICAgdmFyIF9vcHRpb25zJHJlY3Vyc2l2ZTtcbiAgICAvLyBsZXQgc3luYyA9IG9wdGlvbnMuc3luYztcbiAgICAvLyBsZXQgcGF0aCA9IG9wdGlvbnMucGF0aDtcbiAgICBsZXQgaW5uZXJUeXBlID0gdGhpcy5pbm5lclR5cGU7XG4gICAgLy8gbGV0IGVuZEVhcmx5ID0gb3B0aW9ucy5hYm9ydEVhcmx5ID8/IHRoaXMuc3BlYy5hYm9ydEVhcmx5O1xuICAgIGxldCByZWN1cnNpdmUgPSAoX29wdGlvbnMkcmVjdXJzaXZlID0gb3B0aW9ucy5yZWN1cnNpdmUpICE9IG51bGwgPyBfb3B0aW9ucyRyZWN1cnNpdmUgOiB0aGlzLnNwZWMucmVjdXJzaXZlO1xuICAgIG9wdGlvbnMub3JpZ2luYWxWYWx1ZSAhPSBudWxsID8gb3B0aW9ucy5vcmlnaW5hbFZhbHVlIDogX3ZhbHVlO1xuICAgIHN1cGVyLl92YWxpZGF0ZShfdmFsdWUsIG9wdGlvbnMsIHBhbmljLCAoYXJyYXlFcnJvcnMsIHZhbHVlKSA9PiB7XG4gICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1MjtcbiAgICAgIGlmICghcmVjdXJzaXZlIHx8ICFpbm5lclR5cGUgfHwgIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgICAgbmV4dChhcnJheUVycm9ycywgdmFsdWUpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG5cbiAgICAgIC8vICM5NTAgRW5zdXJlIHRoYXQgc3BhcnNlIGFycmF5IGVtcHR5IHNsb3RzIGFyZSB2YWxpZGF0ZWRcbiAgICAgIGxldCB0ZXN0cyA9IG5ldyBBcnJheSh2YWx1ZS5sZW5ndGgpO1xuICAgICAgZm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IHZhbHVlLmxlbmd0aDsgaW5kZXgrKykge1xuICAgICAgICB2YXIgX29wdGlvbnMkb3JpZ2luYWxWYWx1O1xuICAgICAgICB0ZXN0c1tpbmRleF0gPSBpbm5lclR5cGUuYXNOZXN0ZWRUZXN0KHtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1ID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1IDogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXN0cyxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogKF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIDogX3ZhbHVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBwYW5pYywgaW5uZXJUeXBlRXJyb3JzID0+IG5leHQoaW5uZXJUeXBlRXJyb3JzLmNvbmNhdChhcnJheUVycm9ycyksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBzdXBlci5jbG9uZShzcGVjKTtcbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSB0aGlzLmlubmVyVHlwZTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIC8qKiBQYXJzZSBhbiBpbnB1dCBKU09OIHN0cmluZyB0byBhbiBvYmplY3QgKi9cbiAganNvbigpIHtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0ocGFyc2VKc29uKTtcbiAgfVxuICBjb25jYXQoc2NoZW1hKSB7XG4gICAgbGV0IG5leHQgPSBzdXBlci5jb25jYXQoc2NoZW1hKTtcblxuICAgIC8vIEB0cy1leHBlY3QtZXJyb3IgcmVhZG9ubHlcbiAgICBuZXh0LmlubmVyVHlwZSA9IHRoaXMuaW5uZXJUeXBlO1xuICAgIGlmIChzY2hlbWEuaW5uZXJUeXBlKVxuICAgICAgLy8gQHRzLWV4cGVjdC1lcnJvciByZWFkb25seVxuICAgICAgbmV4dC5pbm5lclR5cGUgPSBuZXh0LmlubmVyVHlwZSA/XG4gICAgICAvLyBAdHMtZXhwZWN0LWVycm9yIExhenkgZG9lc24ndCBoYXZlIGNvbmNhdCBhbmQgd2lsbCBicmVha1xuICAgICAgbmV4dC5pbm5lclR5cGUuY29uY2F0KHNjaGVtYS5pbm5lclR5cGUpIDogc2NoZW1hLmlubmVyVHlwZTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuICBvZihzY2hlbWEpIHtcbiAgICAvLyBGSVhNRTogdGhpcyBzaG91bGQgcmV0dXJuIGEgbmV3IGluc3RhbmNlIG9mIGFycmF5IHdpdGhvdXQgdGhlIGRlZmF1bHQgdG8gYmVcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBpZiAoIWlzU2NoZW1hKHNjaGVtYSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ2BhcnJheS5vZigpYCBzdWItc2NoZW1hIG11c3QgYmUgYSB2YWxpZCB5dXAgc2NoZW1hIG5vdDogJyArIHByaW50VmFsdWUoc2NoZW1hKSk7XG5cbiAgICAvLyBAdHMtZXhwZWN0LWVycm9yIHJlYWRvbmx5XG4gICAgbmV4dC5pbm5lclR5cGUgPSBzY2hlbWE7XG4gICAgbmV4dC5zcGVjID0gT2JqZWN0LmFzc2lnbih7fSwgbmV4dC5zcGVjLCB7XG4gICAgICB0eXBlczogc2NoZW1hXG4gICAgfSk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgbGVuZ3RoKGxlbmd0aCwgbWVzc2FnZSA9IGFycmF5Lmxlbmd0aCkge1xuICAgIHJldHVybiB0aGlzLnRlc3Qoe1xuICAgICAgbWVzc2FnZSxcbiAgICAgIG5hbWU6ICdsZW5ndGgnLFxuICAgICAgZXhjbHVzaXZlOiB0cnVlLFxuICAgICAgcGFyYW1zOiB7XG4gICAgICAgIGxlbmd0aFxuICAgICAgfSxcbiAgICAgIHNraXBBYnNlbnQ6IHRydWUsXG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPT09IHRoaXMucmVzb2x2ZShsZW5ndGgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIG1pbihtaW4sIG1lc3NhZ2UpIHtcbiAgICBtZXNzYWdlID0gbWVzc2FnZSB8fCBhcnJheS5taW47XG4gICAgcmV0dXJuIHRoaXMudGVzdCh7XG4gICAgICBtZXNzYWdlLFxuICAgICAgbmFtZTogJ21pbicsXG4gICAgICBleGNsdXNpdmU6IHRydWUsXG4gICAgICBwYXJhbXM6IHtcbiAgICAgICAgbWluXG4gICAgICB9LFxuICAgICAgc2tpcEFic2VudDogdHJ1ZSxcbiAgICAgIC8vIEZJWE1FKHRzKTogQXJyYXk8dHlwZW9mIFQ+XG4gICAgICB0ZXN0KHZhbHVlKSB7XG4gICAgICAgIHJldHVybiB2YWx1ZS5sZW5ndGggPj0gdGhpcy5yZXNvbHZlKG1pbik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cbiAgbWF4KG1heCwgbWVzc2FnZSkge1xuICAgIG1lc3NhZ2UgPSBtZXNzYWdlIHx8IGFycmF5Lm1heDtcbiAgICByZXR1cm4gdGhpcy50ZXN0KHtcbiAgICAgIG1lc3NhZ2UsXG4gICAgICBuYW1lOiAnbWF4JyxcbiAgICAgIGV4Y2x1c2l2ZTogdHJ1ZSxcbiAgICAgIHBhcmFtczoge1xuICAgICAgICBtYXhcbiAgICAgIH0sXG4gICAgICBza2lwQWJzZW50OiB0cnVlLFxuICAgICAgdGVzdCh2YWx1ZSkge1xuICAgICAgICByZXR1cm4gdmFsdWUubGVuZ3RoIDw9IHRoaXMucmVzb2x2ZShtYXgpO1xuICAgICAgfVxuICAgIH0pO1xuICB9XG4gIGVuc3VyZSgpIHtcbiAgICByZXR1cm4gdGhpcy5kZWZhdWx0KCgpID0+IFtdKS50cmFuc2Zvcm0oKHZhbCwgb3JpZ2luYWwpID0+IHtcbiAgICAgIC8vIFdlIGRvbid0IHdhbnQgdG8gcmV0dXJuIGBudWxsYCBmb3IgbnVsbGFibGUgc2NoZW1hXG4gICAgICBpZiAodGhpcy5fdHlwZUNoZWNrKHZhbCkpIHJldHVybiB2YWw7XG4gICAgICByZXR1cm4gb3JpZ2luYWwgPT0gbnVsbCA/IFtdIDogW10uY29uY2F0KG9yaWdpbmFsKTtcbiAgICB9KTtcbiAgfVxuICBjb21wYWN0KHJlamVjdG9yKSB7XG4gICAgbGV0IHJlamVjdCA9ICFyZWplY3RvciA/IHYgPT4gISF2IDogKHYsIGksIGEpID0+ICFyZWplY3Rvcih2LCBpLCBhKTtcbiAgICByZXR1cm4gdGhpcy50cmFuc2Zvcm0odmFsdWVzID0+IHZhbHVlcyAhPSBudWxsID8gdmFsdWVzLmZpbHRlcihyZWplY3QpIDogdmFsdWVzKTtcbiAgfVxuICBkZXNjcmliZShvcHRpb25zKSB7XG4gICAgY29uc3QgbmV4dCA9IChvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpIDogdGhpcykuY2xvbmUoKTtcbiAgICBjb25zdCBiYXNlID0gc3VwZXIuZGVzY3JpYmUob3B0aW9ucyk7XG4gICAgaWYgKG5leHQuaW5uZXJUeXBlKSB7XG4gICAgICB2YXIgX2lubmVyT3B0aW9ucztcbiAgICAgIGxldCBpbm5lck9wdGlvbnMgPSBvcHRpb25zO1xuICAgICAgaWYgKChfaW5uZXJPcHRpb25zID0gaW5uZXJPcHRpb25zKSAhPSBudWxsICYmIF9pbm5lck9wdGlvbnMudmFsdWUpIHtcbiAgICAgICAgaW5uZXJPcHRpb25zID0gT2JqZWN0LmFzc2lnbih7fSwgaW5uZXJPcHRpb25zLCB7XG4gICAgICAgICAgcGFyZW50OiBpbm5lck9wdGlvbnMudmFsdWUsXG4gICAgICAgICAgdmFsdWU6IGlubmVyT3B0aW9ucy52YWx1ZVswXVxuICAgICAgICB9KTtcbiAgICAgIH1cbiAgICAgIGJhc2UuaW5uZXJUeXBlID0gbmV4dC5pbm5lclR5cGUuZGVzY3JpYmUoaW5uZXJPcHRpb25zKTtcbiAgICB9XG4gICAgcmV0dXJuIGJhc2U7XG4gIH1cbn1cbmNyZWF0ZSQyLnByb3RvdHlwZSA9IEFycmF5U2NoZW1hLnByb3RvdHlwZTtcblxuLy8gQHRzLWlnbm9yZVxuZnVuY3Rpb24gY3JlYXRlJDEoc2NoZW1hcykge1xuICByZXR1cm4gbmV3IFR1cGxlU2NoZW1hKHNjaGVtYXMpO1xufVxuY2xhc3MgVHVwbGVTY2hlbWEgZXh0ZW5kcyBTY2hlbWEge1xuICBjb25zdHJ1Y3RvcihzY2hlbWFzKSB7XG4gICAgc3VwZXIoe1xuICAgICAgdHlwZTogJ3R1cGxlJyxcbiAgICAgIHNwZWM6IHtcbiAgICAgICAgdHlwZXM6IHNjaGVtYXNcbiAgICAgIH0sXG4gICAgICBjaGVjayh2KSB7XG4gICAgICAgIGNvbnN0IHR5cGVzID0gdGhpcy5zcGVjLnR5cGVzO1xuICAgICAgICByZXR1cm4gQXJyYXkuaXNBcnJheSh2KSAmJiB2Lmxlbmd0aCA9PT0gdHlwZXMubGVuZ3RoO1xuICAgICAgfVxuICAgIH0pO1xuICAgIHRoaXMud2l0aE11dGF0aW9uKCgpID0+IHtcbiAgICAgIHRoaXMudHlwZUVycm9yKHR1cGxlLm5vdFR5cGUpO1xuICAgIH0pO1xuICB9XG4gIF9jYXN0KGlucHV0VmFsdWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCB7XG4gICAgICB0eXBlc1xuICAgIH0gPSB0aGlzLnNwZWM7XG4gICAgY29uc3QgdmFsdWUgPSBzdXBlci5fY2FzdChpbnB1dFZhbHVlLCBvcHRpb25zKTtcbiAgICBpZiAoIXRoaXMuX3R5cGVDaGVjayh2YWx1ZSkpIHtcbiAgICAgIHJldHVybiB2YWx1ZTtcbiAgICB9XG4gICAgbGV0IGlzQ2hhbmdlZCA9IGZhbHNlO1xuICAgIGNvbnN0IGNhc3RBcnJheSA9IHR5cGVzLm1hcCgodHlwZSwgaWR4KSA9PiB7XG4gICAgICBjb25zdCBjYXN0RWxlbWVudCA9IHR5cGUuY2FzdCh2YWx1ZVtpZHhdLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICAgIHBhdGg6IGAke29wdGlvbnMucGF0aCB8fCAnJ31bJHtpZHh9XWBcbiAgICAgIH0pKTtcbiAgICAgIGlmIChjYXN0RWxlbWVudCAhPT0gdmFsdWVbaWR4XSkgaXNDaGFuZ2VkID0gdHJ1ZTtcbiAgICAgIHJldHVybiBjYXN0RWxlbWVudDtcbiAgICB9KTtcbiAgICByZXR1cm4gaXNDaGFuZ2VkID8gY2FzdEFycmF5IDogdmFsdWU7XG4gIH1cbiAgX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucyA9IHt9LCBwYW5pYywgbmV4dCkge1xuICAgIGxldCBpdGVtVHlwZXMgPSB0aGlzLnNwZWMudHlwZXM7XG4gICAgc3VwZXIuX3ZhbGlkYXRlKF92YWx1ZSwgb3B0aW9ucywgcGFuaWMsICh0dXBsZUVycm9ycywgdmFsdWUpID0+IHtcbiAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyO1xuICAgICAgLy8gaW50ZW50aW9uYWxseSBub3QgcmVzcGVjdGluZyByZWN1cnNpdmVcbiAgICAgIGlmICghdGhpcy5fdHlwZUNoZWNrKHZhbHVlKSkge1xuICAgICAgICBuZXh0KHR1cGxlRXJyb3JzLCB2YWx1ZSk7XG4gICAgICAgIHJldHVybjtcbiAgICAgIH1cbiAgICAgIGxldCB0ZXN0cyA9IFtdO1xuICAgICAgZm9yIChsZXQgW2luZGV4LCBpdGVtU2NoZW1hXSBvZiBpdGVtVHlwZXMuZW50cmllcygpKSB7XG4gICAgICAgIHZhciBfb3B0aW9ucyRvcmlnaW5hbFZhbHU7XG4gICAgICAgIHRlc3RzW2luZGV4XSA9IGl0ZW1TY2hlbWEuYXNOZXN0ZWRUZXN0KHtcbiAgICAgICAgICBvcHRpb25zLFxuICAgICAgICAgIGluZGV4LFxuICAgICAgICAgIHBhcmVudDogdmFsdWUsXG4gICAgICAgICAgcGFyZW50UGF0aDogb3B0aW9ucy5wYXRoLFxuICAgICAgICAgIG9yaWdpbmFsUGFyZW50OiAoX29wdGlvbnMkb3JpZ2luYWxWYWx1ID0gb3B0aW9ucy5vcmlnaW5hbFZhbHVlKSAhPSBudWxsID8gX29wdGlvbnMkb3JpZ2luYWxWYWx1IDogX3ZhbHVlXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgdGhpcy5ydW5UZXN0cyh7XG4gICAgICAgIHZhbHVlLFxuICAgICAgICB0ZXN0cyxcbiAgICAgICAgb3JpZ2luYWxWYWx1ZTogKF9vcHRpb25zJG9yaWdpbmFsVmFsdTIgPSBvcHRpb25zLm9yaWdpbmFsVmFsdWUpICE9IG51bGwgPyBfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIDogX3ZhbHVlLFxuICAgICAgICBvcHRpb25zXG4gICAgICB9LCBwYW5pYywgaW5uZXJUeXBlRXJyb3JzID0+IG5leHQoaW5uZXJUeXBlRXJyb3JzLmNvbmNhdCh0dXBsZUVycm9ycyksIHZhbHVlKSk7XG4gICAgfSk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIGNvbnN0IG5leHQgPSAob3B0aW9ucyA/IHRoaXMucmVzb2x2ZShvcHRpb25zKSA6IHRoaXMpLmNsb25lKCk7XG4gICAgY29uc3QgYmFzZSA9IHN1cGVyLmRlc2NyaWJlKG9wdGlvbnMpO1xuICAgIGJhc2UuaW5uZXJUeXBlID0gbmV4dC5zcGVjLnR5cGVzLm1hcCgoc2NoZW1hLCBpbmRleCkgPT4ge1xuICAgICAgdmFyIF9pbm5lck9wdGlvbnM7XG4gICAgICBsZXQgaW5uZXJPcHRpb25zID0gb3B0aW9ucztcbiAgICAgIGlmICgoX2lubmVyT3B0aW9ucyA9IGlubmVyT3B0aW9ucykgIT0gbnVsbCAmJiBfaW5uZXJPcHRpb25zLnZhbHVlKSB7XG4gICAgICAgIGlubmVyT3B0aW9ucyA9IE9iamVjdC5hc3NpZ24oe30sIGlubmVyT3B0aW9ucywge1xuICAgICAgICAgIHBhcmVudDogaW5uZXJPcHRpb25zLnZhbHVlLFxuICAgICAgICAgIHZhbHVlOiBpbm5lck9wdGlvbnMudmFsdWVbaW5kZXhdXG4gICAgICAgIH0pO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHNjaGVtYS5kZXNjcmliZShpbm5lck9wdGlvbnMpO1xuICAgIH0pO1xuICAgIHJldHVybiBiYXNlO1xuICB9XG59XG5jcmVhdGUkMS5wcm90b3R5cGUgPSBUdXBsZVNjaGVtYS5wcm90b3R5cGU7XG5cbmZ1bmN0aW9uIGNyZWF0ZShidWlsZGVyKSB7XG4gIHJldHVybiBuZXcgTGF6eShidWlsZGVyKTtcbn1cbmZ1bmN0aW9uIGNhdGNoVmFsaWRhdGlvbkVycm9yKGZuKSB7XG4gIHRyeSB7XG4gICAgcmV0dXJuIGZuKCk7XG4gIH0gY2F0Y2ggKGVycikge1xuICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSByZXR1cm4gUHJvbWlzZS5yZWplY3QoZXJyKTtcbiAgICB0aHJvdyBlcnI7XG4gIH1cbn1cbmNsYXNzIExhenkge1xuICBjb25zdHJ1Y3RvcihidWlsZGVyKSB7XG4gICAgdGhpcy50eXBlID0gJ2xhenknO1xuICAgIHRoaXMuX19pc1l1cFNjaGVtYV9fID0gdHJ1ZTtcbiAgICB0aGlzLnNwZWMgPSB2b2lkIDA7XG4gICAgdGhpcy5fcmVzb2x2ZSA9ICh2YWx1ZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICBsZXQgc2NoZW1hID0gdGhpcy5idWlsZGVyKHZhbHVlLCBvcHRpb25zKTtcbiAgICAgIGlmICghaXNTY2hlbWEoc2NoZW1hKSkgdGhyb3cgbmV3IFR5cGVFcnJvcignbGF6eSgpIGZ1bmN0aW9ucyBtdXN0IHJldHVybiBhIHZhbGlkIHNjaGVtYScpO1xuICAgICAgaWYgKHRoaXMuc3BlYy5vcHRpb25hbCkgc2NoZW1hID0gc2NoZW1hLm9wdGlvbmFsKCk7XG4gICAgICByZXR1cm4gc2NoZW1hLnJlc29sdmUob3B0aW9ucyk7XG4gICAgfTtcbiAgICB0aGlzLmJ1aWxkZXIgPSBidWlsZGVyO1xuICAgIHRoaXMuc3BlYyA9IHtcbiAgICAgIG1ldGE6IHVuZGVmaW5lZCxcbiAgICAgIG9wdGlvbmFsOiBmYWxzZVxuICAgIH07XG4gIH1cbiAgY2xvbmUoc3BlYykge1xuICAgIGNvbnN0IG5leHQgPSBuZXcgTGF6eSh0aGlzLmJ1aWxkZXIpO1xuICAgIG5leHQuc3BlYyA9IE9iamVjdC5hc3NpZ24oe30sIHRoaXMuc3BlYywgc3BlYyk7XG4gICAgcmV0dXJuIG5leHQ7XG4gIH1cbiAgb3B0aW9uYWxpdHkob3B0aW9uYWwpIHtcbiAgICBjb25zdCBuZXh0ID0gdGhpcy5jbG9uZSh7XG4gICAgICBvcHRpb25hbFxuICAgIH0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG4gIG9wdGlvbmFsKCkge1xuICAgIHJldHVybiB0aGlzLm9wdGlvbmFsaXR5KHRydWUpO1xuICB9XG4gIHJlc29sdmUob3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKG9wdGlvbnMudmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIGNhc3QodmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykuY2FzdCh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgYXNOZXN0ZWRUZXN0KGNvbmZpZykge1xuICAgIGxldCB7XG4gICAgICBrZXksXG4gICAgICBpbmRleCxcbiAgICAgIHBhcmVudCxcbiAgICAgIG9wdGlvbnNcbiAgICB9ID0gY29uZmlnO1xuICAgIGxldCB2YWx1ZSA9IHBhcmVudFtpbmRleCAhPSBudWxsID8gaW5kZXggOiBrZXldO1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBPYmplY3QuYXNzaWduKHt9LCBvcHRpb25zLCB7XG4gICAgICB2YWx1ZSxcbiAgICAgIHBhcmVudFxuICAgIH0pKS5hc05lc3RlZFRlc3QoY29uZmlnKTtcbiAgfVxuICB2YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiBjYXRjaFZhbGlkYXRpb25FcnJvcigoKSA9PiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZSh2YWx1ZSwgb3B0aW9ucykpO1xuICB9XG4gIHZhbGlkYXRlU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS52YWxpZGF0ZVN5bmModmFsdWUsIG9wdGlvbnMpO1xuICB9XG4gIHZhbGlkYXRlQXQocGF0aCwgdmFsdWUsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gY2F0Y2hWYWxpZGF0aW9uRXJyb3IoKCkgPT4gdGhpcy5fcmVzb2x2ZSh2YWx1ZSwgb3B0aW9ucykudmFsaWRhdGVBdChwYXRoLCB2YWx1ZSwgb3B0aW9ucykpO1xuICB9XG4gIHZhbGlkYXRlU3luY0F0KHBhdGgsIHZhbHVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMuX3Jlc29sdmUodmFsdWUsIG9wdGlvbnMpLnZhbGlkYXRlU3luY0F0KHBhdGgsIHZhbHVlLCBvcHRpb25zKTtcbiAgfVxuICBpc1ZhbGlkKHZhbHVlLCBvcHRpb25zKSB7XG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkKHZhbHVlLCBvcHRpb25zKTtcbiAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgIGlmIChWYWxpZGF0aW9uRXJyb3IuaXNFcnJvcihlcnIpKSB7XG4gICAgICAgIHJldHVybiBQcm9taXNlLnJlc29sdmUoZmFsc2UpO1xuICAgICAgfVxuICAgICAgdGhyb3cgZXJyO1xuICAgIH1cbiAgfVxuICBpc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLl9yZXNvbHZlKHZhbHVlLCBvcHRpb25zKS5pc1ZhbGlkU3luYyh2YWx1ZSwgb3B0aW9ucyk7XG4gIH1cbiAgZGVzY3JpYmUob3B0aW9ucykge1xuICAgIHJldHVybiBvcHRpb25zID8gdGhpcy5yZXNvbHZlKG9wdGlvbnMpLmRlc2NyaWJlKG9wdGlvbnMpIDoge1xuICAgICAgdHlwZTogJ2xhenknLFxuICAgICAgbWV0YTogdGhpcy5zcGVjLm1ldGEsXG4gICAgICBsYWJlbDogdW5kZWZpbmVkXG4gICAgfTtcbiAgfVxuICBtZXRhKC4uLmFyZ3MpIHtcbiAgICBpZiAoYXJncy5sZW5ndGggPT09IDApIHJldHVybiB0aGlzLnNwZWMubWV0YTtcbiAgICBsZXQgbmV4dCA9IHRoaXMuY2xvbmUoKTtcbiAgICBuZXh0LnNwZWMubWV0YSA9IE9iamVjdC5hc3NpZ24obmV4dC5zcGVjLm1ldGEgfHwge30sIGFyZ3NbMF0pO1xuICAgIHJldHVybiBuZXh0O1xuICB9XG59XG5cbmZ1bmN0aW9uIHNldExvY2FsZShjdXN0b20pIHtcbiAgT2JqZWN0LmtleXMoY3VzdG9tKS5mb3JFYWNoKHR5cGUgPT4ge1xuICAgIC8vIEB0cy1pZ25vcmVcbiAgICBPYmplY3Qua2V5cyhjdXN0b21bdHlwZV0pLmZvckVhY2gobWV0aG9kID0+IHtcbiAgICAgIC8vIEB0cy1pZ25vcmVcbiAgICAgIGxvY2FsZVt0eXBlXVttZXRob2RdID0gY3VzdG9tW3R5cGVdW21ldGhvZF07XG4gICAgfSk7XG4gIH0pO1xufVxuXG5mdW5jdGlvbiBhZGRNZXRob2Qoc2NoZW1hVHlwZSwgbmFtZSwgZm4pIHtcbiAgaWYgKCFzY2hlbWFUeXBlIHx8ICFpc1NjaGVtYShzY2hlbWFUeXBlLnByb3RvdHlwZSkpIHRocm93IG5ldyBUeXBlRXJyb3IoJ1lvdSBtdXN0IHByb3ZpZGUgYSB5dXAgc2NoZW1hIGNvbnN0cnVjdG9yIGZ1bmN0aW9uJyk7XG4gIGlmICh0eXBlb2YgbmFtZSAhPT0gJ3N0cmluZycpIHRocm93IG5ldyBUeXBlRXJyb3IoJ0EgTWV0aG9kIG5hbWUgbXVzdCBiZSBwcm92aWRlZCcpO1xuICBpZiAodHlwZW9mIGZuICE9PSAnZnVuY3Rpb24nKSB0aHJvdyBuZXcgVHlwZUVycm9yKCdNZXRob2QgZnVuY3Rpb24gbXVzdCBiZSBwcm92aWRlZCcpO1xuICBzY2hlbWFUeXBlLnByb3RvdHlwZVtuYW1lXSA9IGZuO1xufVxuXG5leHBvcnQgeyBBcnJheVNjaGVtYSwgQm9vbGVhblNjaGVtYSwgRGF0ZVNjaGVtYSwgTGF6eSBhcyBMYXp5U2NoZW1hLCBNaXhlZFNjaGVtYSwgTnVtYmVyU2NoZW1hLCBPYmplY3RTY2hlbWEsIFNjaGVtYSwgU3RyaW5nU2NoZW1hLCBUdXBsZVNjaGVtYSwgVmFsaWRhdGlvbkVycm9yLCBhZGRNZXRob2QsIGNyZWF0ZSQyIGFzIGFycmF5LCBjcmVhdGUkNyBhcyBib29sLCBjcmVhdGUkNyBhcyBib29sZWFuLCBjcmVhdGUkNCBhcyBkYXRlLCBsb2NhbGUgYXMgZGVmYXVsdExvY2FsZSwgZ2V0SW4sIGlzU2NoZW1hLCBjcmVhdGUgYXMgbGF6eSwgY3JlYXRlJDggYXMgbWl4ZWQsIGNyZWF0ZSQ1IGFzIG51bWJlciwgY3JlYXRlJDMgYXMgb2JqZWN0LCBwcmludFZhbHVlLCByZWFjaCwgY3JlYXRlJDkgYXMgcmVmLCBzZXRMb2NhbGUsIGNyZWF0ZSQ2IGFzIHN0cmluZywgY3JlYXRlJDEgYXMgdHVwbGUgfTtcbiJdLCJuYW1lcyI6WyJnZXR0ZXIiLCJmb3JFYWNoIiwic3BsaXQiLCJub3JtYWxpemVQYXRoIiwiam9pbiIsImNhbWVsQ2FzZSIsInNuYWtlQ2FzZSIsInRvcG9zb3J0IiwidG9TdHJpbmciLCJPYmplY3QiLCJwcm90b3R5cGUiLCJlcnJvclRvU3RyaW5nIiwiRXJyb3IiLCJyZWdFeHBUb1N0cmluZyIsIlJlZ0V4cCIsInN5bWJvbFRvU3RyaW5nIiwiU3ltYm9sIiwiU1lNQk9MX1JFR0VYUCIsInByaW50TnVtYmVyIiwidmFsIiwiaXNOZWdhdGl2ZVplcm8iLCJwcmludFNpbXBsZVZhbHVlIiwicXVvdGVTdHJpbmdzIiwidHlwZU9mIiwibmFtZSIsImNhbGwiLCJyZXBsYWNlIiwidGFnIiwic2xpY2UiLCJpc05hTiIsImdldFRpbWUiLCJ0b0lTT1N0cmluZyIsInByaW50VmFsdWUiLCJ2YWx1ZSIsInJlc3VsdCIsIkpTT04iLCJzdHJpbmdpZnkiLCJrZXkiLCJ0b0FycmF5IiwiY29uY2F0IiwiX1N5bWJvbCR0b1N0cmluZ1RhZyIsIl9TeW1ib2wkaGFzSW5zdGFuY2UiLCJfU3ltYm9sJHRvU3RyaW5nVGFnMiIsInN0clJlZyIsInRvU3RyaW5nVGFnIiwiVmFsaWRhdGlvbkVycm9yTm9TdGFjayIsImNvbnN0cnVjdG9yIiwiZXJyb3JPckVycm9ycyIsImZpZWxkIiwidHlwZSIsIm1lc3NhZ2UiLCJwYXRoIiwicGFyYW1zIiwiZXJyb3JzIiwiaW5uZXIiLCJlcnIiLCJWYWxpZGF0aW9uRXJyb3IiLCJpc0Vycm9yIiwicHVzaCIsImlubmVyRXJyb3JzIiwibGVuZ3RoIiwiaGFzSW5zdGFuY2UiLCJmb3JtYXRFcnJvciIsImxhYmVsIiwiYXNzaWduIiwib3JpZ2luYWxQYXRoIiwiXyIsImluc3QiLCJkaXNhYmxlU3RhY2siLCJlcnJvck5vU3RhY2siLCJjYXB0dXJlU3RhY2tUcmFjZSIsIm1peGVkIiwiZGVmYXVsdCIsInJlcXVpcmVkIiwiZGVmaW5lZCIsIm5vdE51bGwiLCJvbmVPZiIsIm5vdE9uZU9mIiwibm90VHlwZSIsIm9yaWdpbmFsVmFsdWUiLCJjYXN0TXNnIiwic3RyaW5nIiwibWluIiwibWF4IiwibWF0Y2hlcyIsImVtYWlsIiwidXJsIiwidXVpZCIsImRhdGV0aW1lIiwiZGF0ZXRpbWVfcHJlY2lzaW9uIiwiZGF0ZXRpbWVfb2Zmc2V0IiwidHJpbSIsImxvd2VyY2FzZSIsInVwcGVyY2FzZSIsIm51bWJlciIsImxlc3NUaGFuIiwibW9yZVRoYW4iLCJwb3NpdGl2ZSIsIm5lZ2F0aXZlIiwiaW50ZWdlciIsImRhdGUiLCJib29sZWFuIiwiaXNWYWx1ZSIsIm9iamVjdCIsIm5vVW5rbm93biIsImV4YWN0IiwiYXJyYXkiLCJ0dXBsZSIsInNwZWMiLCJ0eXBlTGVuIiwidHlwZXMiLCJBcnJheSIsImlzQXJyYXkiLCJsb2NhbGUiLCJjcmVhdGUiLCJpc1NjaGVtYSIsIm9iaiIsIl9faXNZdXBTY2hlbWFfXyIsIkNvbmRpdGlvbiIsImZyb21PcHRpb25zIiwicmVmcyIsImNvbmZpZyIsInRoZW4iLCJvdGhlcndpc2UiLCJUeXBlRXJyb3IiLCJpcyIsImNoZWNrIiwidmFsdWVzIiwiZXZlcnkiLCJzY2hlbWEiLCJfYnJhbmNoIiwiYnJhbmNoIiwicmVzb2x2ZSIsImJhc2UiLCJvcHRpb25zIiwibWFwIiwicmVmIiwiZ2V0VmFsdWUiLCJwYXJlbnQiLCJjb250ZXh0IiwiZm4iLCJ1bmRlZmluZWQiLCJidWlsZGVyIiwicHJlZml4ZXMiLCJjcmVhdGUkOSIsIlJlZmVyZW5jZSIsImlzQ29udGV4dCIsImNhc3QiLCJkZXNjcmliZSIsImlzUmVmIiwiX19pc1l1cFJlZiIsImlzU2libGluZyIsInByZWZpeCIsImlzQWJzZW50IiwiY3JlYXRlVmFsaWRhdGlvbiIsInZhbGlkYXRlIiwicGFuaWMiLCJuZXh0IiwidGVzdCIsInNraXBBYnNlbnQiLCJhYm9ydEVhcmx5IiwiZGlzYWJsZVN0YWNrVHJhY2UiLCJpdGVtIiwiY3JlYXRlRXJyb3IiLCJvdmVycmlkZXMiLCJuZXh0UGFyYW1zIiwia2V5cyIsImVycm9yIiwiaW52YWxpZCIsImN0eCIsImZyb20iLCJoYW5kbGVSZXN1bHQiLCJ2YWxpZE9yRXJyb3IiLCJoYW5kbGVFcnJvciIsInNob3VsZFNraXAiLCJfcmVzdWx0Iiwic3luYyIsIlByb21pc2UiLCJPUFRJT05TIiwiZ2V0SW4iLCJsYXN0UGFydCIsImxhc3RQYXJ0RGVidWciLCJwYXJlbnRQYXRoIiwiX3BhcnQiLCJpc0JyYWNrZXQiLCJwYXJ0IiwiaXNUdXBsZSIsImlkeCIsInBhcnNlSW50IiwiaW5uZXJUeXBlIiwiZmllbGRzIiwicmVhY2giLCJSZWZlcmVuY2VTZXQiLCJTZXQiLCJkZXNjcmlwdGlvbiIsInJlc29sdmVBbGwiLCJjbG9uZSIsIm1lcmdlIiwibmV3SXRlbXMiLCJyZW1vdmVJdGVtcyIsImFkZCIsImRlbGV0ZSIsInNyYyIsInNlZW4iLCJNYXAiLCJoYXMiLCJnZXQiLCJjb3B5IiwiRGF0ZSIsInNldCIsImkiLCJrIiwidiIsImVudHJpZXMiLCJTY2hlbWEiLCJfdHlwZSIsIl9tdXRhdGUiLCJnZXRQcm90b3R5cGVPZiIsIl90eXBlQ2hlY2siLCJfd2hpdGVsaXN0IiwiX2JsYWNrbGlzdCIsImludGVybmFsVGVzdHMiLCJleGNsdXNpdmVUZXN0cyIsImRlcHMiLCJjb25kaXRpb25zIiwidGVzdHMiLCJ0cmFuc2Zvcm1zIiwibWV0YSIsImFyZ3MiLCJ3aXRoTXV0YXRpb24iLCJiZWZvcmUiLCJjb21iaW5lZCIsIm1lcmdlZFNwZWMiLCJpc1R5cGUiLCJudWxsYWJsZSIsIm9wdGlvbmFsIiwicmVkdWNlIiwicHJldlNjaGVtYSIsImNvbmRpdGlvbiIsInJlc29sdmVPcHRpb25zIiwiX29wdGlvbnMkc3RyaWN0IiwiX29wdGlvbnMkYWJvcnRFYXJseSIsIl9vcHRpb25zJHJlY3Vyc2l2ZSIsIl9vcHRpb25zJGRpc2FibGVTdGFjayIsInN0cmljdCIsInJlY3Vyc2l2ZSIsInJlc29sdmVkU2NoZW1hIiwiYWxsb3dPcHRpb25hbGl0eSIsImFzc2VydCIsIl9jYXN0IiwiZm9ybWF0dGVkVmFsdWUiLCJmb3JtYXR0ZWRSZXN1bHQiLCJyYXdWYWx1ZSIsInByZXZWYWx1ZSIsImdldERlZmF1bHQiLCJfdmFsaWRhdGUiLCJfdmFsdWUiLCJpbml0aWFsVGVzdHMiLCJydW5UZXN0cyIsImluaXRpYWxFcnJvcnMiLCJydW5PcHRpb25zIiwiZmlyZWQiLCJwYW5pY09uY2UiLCJhcmciLCJuZXh0T25jZSIsImNvdW50IiwibmVzdGVkRXJyb3JzIiwiZmluaXNoVGVzdFJ1biIsImFzTmVzdGVkVGVzdCIsImluZGV4Iiwib3JpZ2luYWxQYXJlbnQiLCJpc0luZGV4IiwidGVzdE9wdGlvbnMiLCJpbmNsdWRlcyIsIl9vcHRpb25zJGRpc2FibGVTdGFjazIiLCJyZWplY3QiLCJwYXJzZWQiLCJ2YWxpZGF0ZWQiLCJ2YWxpZGF0ZVN5bmMiLCJfb3B0aW9ucyRkaXNhYmxlU3RhY2szIiwiaXNWYWxpZCIsImlzVmFsaWRTeW5jIiwiX2dldERlZmF1bHQiLCJkZWZhdWx0VmFsdWUiLCJkZWYiLCJhcmd1bWVudHMiLCJpc1N0cmljdCIsIm51bGxhYmlsaXR5Iiwib3B0aW9uYWxpdHkiLCJub25OdWxsYWJsZSIsIm5vdFJlcXVpcmVkIiwidHJhbnNmb3JtIiwib3B0cyIsImlzRXhjbHVzaXZlIiwiZXhjbHVzaXZlIiwiZmlsdGVyIiwid2hlbiIsImRlcCIsInR5cGVFcnJvciIsImVudW1zIiwid2hpdGVMaXN0IiwidmFsaWRzIiwicmVzb2x2ZWQiLCJibGFja2xpc3QiLCJpbnZhbGlkcyIsInN0cmlwIiwibiIsImxpc3QiLCJmaW5kSW5kZXgiLCJjIiwiY29lcmNlIiwicyIsIm1ldGhvZCIsImFsaWFzIiwicmV0dXJuc1RydWUiLCJjcmVhdGUkOCIsIk1peGVkU2NoZW1hIiwiY3JlYXRlJDciLCJCb29sZWFuU2NoZW1hIiwiaXNUcnVlIiwiaXNGYWxzZSIsIm1zZyIsIkJvb2xlYW4iLCJ2YWx1ZU9mIiwiX3JhdyIsIlN0cmluZyIsImlzb1JlZyIsInBhcnNlSXNvRGF0ZSIsInN0cnVjdCIsInBhcnNlRGF0ZVN0cnVjdCIsInBhcnNlIiwiTnVtYmVyIiwiTmFOIiwieiIsInBsdXNNaW51cyIsInllYXIiLCJtb250aCIsImRheSIsImhvdXIiLCJtaW51dGUiLCJzZWNvbmQiLCJtaWxsaXNlY29uZCIsInRvdGFsTWludXRlc09mZnNldCIsImhvdXJPZmZzZXQiLCJtaW51dGVPZmZzZXQiLCJVVEMiLCJfcmVnZXhSZXN1bHQkNyRsZW5ndGgiLCJfcmVnZXhSZXN1bHQkIiwicmVnZXhSZXN1bHQiLCJleGVjIiwidG9OdW1iZXIiLCJzdWJzdHJpbmciLCJwcmVjaXNpb24iLCJzdHIiLCJyRW1haWwiLCJyVXJsIiwiclVVSUQiLCJ5ZWFyTW9udGhEYXkiLCJob3VyTWludXRlU2Vjb25kIiwiek9yT2Zmc2V0Iiwicklzb0RhdGVUaW1lIiwiaXNUcmltbWVkIiwib2JqU3RyaW5nVGFnIiwiY3JlYXRlJDYiLCJTdHJpbmdTY2hlbWEiLCJ0IiwicmVnZXgiLCJleGNsdWRlRW1wdHlTdHJpbmciLCJzZWFyY2giLCJhbGxvd09mZnNldCIsImVuc3VyZSIsInRvTG93ZXJDYXNlIiwidG9VcHBlckNhc2UiLCJzdHJWYWx1ZSIsImlzTmFOJDEiLCJjcmVhdGUkNSIsIk51bWJlclNjaGVtYSIsImxlc3MiLCJtb3JlIiwiaXNJbnRlZ2VyIiwidHJ1bmNhdGUiLCJyb3VuZCIsIl9tZXRob2QiLCJhdmFpbCIsImluZGV4T2YiLCJNYXRoIiwicGFyc2VGbG9hdCIsImludmFsaWREYXRlIiwiaXNEYXRlIiwiY3JlYXRlJDQiLCJEYXRlU2NoZW1hIiwicHJlcGFyZVBhcmFtIiwicGFyYW0iLCJsaW1pdCIsIklOVkFMSURfREFURSIsInNvcnRGaWVsZHMiLCJleGNsdWRlZEVkZ2VzIiwiZWRnZXMiLCJub2RlcyIsImV4Y2x1ZGVzIiwiYSIsImIiLCJhZGROb2RlIiwiZGVwUGF0aCIsIm5vZGUiLCJyZXZlcnNlIiwiYXJyIiwiSW5maW5pdHkiLCJzb21lIiwiaWkiLCJfZXJyJHBhdGgiLCJzb3J0QnlLZXlPcmRlciIsInBhcnNlSnNvbiIsImRlZXBQYXJ0aWFsIiwicGFydGlhbCIsImZpZWxkU2NoZW1hIiwic2V0RmllbGRzIiwibmV4dEFycmF5IiwiZGVlcEhhcyIsInAiLCJsYXN0IiwicG9wIiwiaXNPYmplY3QiLCJ1bmtub3duIiwia25vd24iLCJkZWZhdWx0U29ydCIsImNyZWF0ZSQzIiwiT2JqZWN0U2NoZW1hIiwiX29wdGlvbnMkc3RyaXBVbmtub3duIiwic3RyaXBVbmtub3duIiwicHJvcHMiLCJfbm9kZXMiLCJpbnRlcm1lZGlhdGVWYWx1ZSIsImlubmVyT3B0aW9ucyIsIl9fdmFsaWRhdGluZyIsImlzQ2hhbmdlZCIsInByb3AiLCJleGlzdHMiLCJmaWVsZFZhbHVlIiwiaW5wdXRWYWx1ZSIsImZpZWxkU3BlYyIsIm9iamVjdEVycm9ycyIsImZpZWxkRXJyb3JzIiwic29ydCIsIl9zb3J0RXJyb3JzIiwiX2V4Y2x1ZGVkRWRnZXMiLCJuZXh0RmllbGRzIiwic2NoZW1hT3JSZWYiLCJ0YXJnZXQiLCJkZnQiLCJfaW5uZXJPcHRpb25zIiwic2hhcGUiLCJhZGRpdGlvbnMiLCJGdW5jdGlvbiIsInBpY2siLCJwaWNrZWQiLCJvbWl0IiwicmVtYWluaW5nIiwidG8iLCJmcm9tR2V0dGVyIiwibmV3T2JqIiwianNvbiIsInVua25vd25LZXlzIiwicHJvcGVydGllcyIsIm5vQWxsb3ciLCJhbGxvdyIsInRyYW5zZm9ybUtleXMiLCJjb25zdGFudENhc2UiLCJfaW5uZXJPcHRpb25zMiIsImNyZWF0ZSQyIiwiQXJyYXlTY2hlbWEiLCJfb3B0cyIsImNhc3RBcnJheSIsImNhc3RFbGVtZW50IiwiYXJyYXlFcnJvcnMiLCJfb3B0aW9ucyRvcmlnaW5hbFZhbHUyIiwiX29wdGlvbnMkb3JpZ2luYWxWYWx1IiwiaW5uZXJUeXBlRXJyb3JzIiwib2YiLCJvcmlnaW5hbCIsImNvbXBhY3QiLCJyZWplY3RvciIsImNyZWF0ZSQxIiwic2NoZW1hcyIsIlR1cGxlU2NoZW1hIiwiaXRlbVR5cGVzIiwidHVwbGVFcnJvcnMiLCJpdGVtU2NoZW1hIiwiTGF6eSIsImNhdGNoVmFsaWRhdGlvbkVycm9yIiwiX3Jlc29sdmUiLCJ2YWxpZGF0ZUF0IiwidmFsaWRhdGVTeW5jQXQiLCJzZXRMb2NhbGUiLCJjdXN0b20iLCJhZGRNZXRob2QiLCJzY2hlbWFUeXBlIiwiTGF6eVNjaGVtYSIsImJvb2wiLCJkZWZhdWx0TG9jYWxlIiwibGF6eSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/yup/index.esm.js\n"));

/***/ }),

/***/ "(app-pages-browser)/./app/onboard/page.tsx":
/*!******************************!*\
  !*** ./app/onboard/page.tsx ***!
  \******************************/
/***/ (function(module, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": function() { return /* binding */ OnboardPage; }\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-hook-form */ \"(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs\");\n/* harmony import */ var _hookform_resolvers_yup__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @hookform/resolvers/yup */ \"(app-pages-browser)/./node_modules/@hookform/resolvers/yup/dist/yup.mjs\");\n/* harmony import */ var yup__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! yup */ \"(app-pages-browser)/./node_modules/yup/index.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* __next_internal_client_entry_do_not_use__ default auto */ \nvar _s = $RefreshSig$();\n\n\n\n\nconst schema = yup__WEBPACK_IMPORTED_MODULE_2__.object().shape({\n    name: yup__WEBPACK_IMPORTED_MODULE_2__.string().required(\"Name is required\"),\n    bio: yup__WEBPACK_IMPORTED_MODULE_2__.string().required(\"Bio is required\"),\n    category: yup__WEBPACK_IMPORTED_MODULE_2__.array().min(1, \"Select at least one category\"),\n    languages: yup__WEBPACK_IMPORTED_MODULE_2__.array().min(1, \"Select at least one language\"),\n    fee: yup__WEBPACK_IMPORTED_MODULE_2__.string().required(\"Fee range is required\"),\n    location: yup__WEBPACK_IMPORTED_MODULE_2__.string().required(\"Location is required\")\n});\nconst categories = [\n    \"Singer\",\n    \"Dancer\",\n    \"DJ\",\n    \"Speaker\"\n];\nconst languages = [\n    \"Hindi\",\n    \"English\",\n    \"Tamil\",\n    \"Punjabi\"\n];\nconst fees = [\n    \"< ₹10,000\",\n    \"₹10,000 - ₹25,000\",\n    \"₹25,000 - ₹50,000\",\n    \"> ₹50,000\"\n];\nfunction OnboardPage() {\n    _s();\n    const [image, setImage] = (0,react__WEBPACK_IMPORTED_MODULE_3__.useState)(null);\n    const { register, handleSubmit, control, reset, formState: { errors } } = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_4__.useForm)({\n        resolver: (0,_hookform_resolvers_yup__WEBPACK_IMPORTED_MODULE_1__.yupResolver)(schema),\n        defaultValues: {\n            name: \"\",\n            bio: \"\",\n            category: [],\n            languages: [],\n            fee: \"\",\n            location: \"\"\n        }\n    });\n    const onSubmit = (data)=>{\n        console.log(\"Form Submitted:\", {\n            ...data,\n            image\n        });\n        alert(\"Submitted! Check console for output.\");\n        reset();\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"main\", {\n        className: \"max-w-3xl mx-auto py-10 px-4\",\n        children: [\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"h2\", {\n                className: \"text-2xl font-bold mb-6\",\n                children: \"\\uD83C\\uDFA4 Artist Onboarding\"\n            }, void 0, false, {\n                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                lineNumber: 50,\n                columnNumber: 7\n            }, this),\n            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"form\", {\n                onSubmit: handleSubmit(onSubmit),\n                className: \"space-y-6\",\n                children: [\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Name\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 55,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                ...register(\"name\"),\n                                className: \"w-full border rounded px-3 py-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 56,\n                                columnNumber: 11\n                            }, this),\n                            errors.name && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.name.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 57,\n                                columnNumber: 27\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 54,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Bio\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 62,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"textarea\", {\n                                ...register(\"bio\"),\n                                rows: 4,\n                                className: \"w-full border rounded px-3 py-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 63,\n                                columnNumber: 11\n                            }, this),\n                            errors.bio && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.bio.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 64,\n                                columnNumber: 26\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 61,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Category\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 69,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-1\",\n                                children: categories.map((cat)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"flex items-center space-x-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                value: cat,\n                                                ...register(\"category\")\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                                lineNumber: 73,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: cat\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                                lineNumber: 74,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, cat, true, {\n                                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                        lineNumber: 72,\n                                        columnNumber: 15\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 70,\n                                columnNumber: 11\n                            }, this),\n                            errors.category && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.category.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 78,\n                                columnNumber: 31\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 68,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Languages Spoken\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 83,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                                className: \"space-y-1\",\n                                children: languages.map((lang)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                        className: \"flex items-center space-x-2\",\n                                        children: [\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                                type: \"checkbox\",\n                                                value: lang,\n                                                ...register(\"languages\")\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                                lineNumber: 87,\n                                                columnNumber: 17\n                                            }, this),\n                                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"span\", {\n                                                children: lang\n                                            }, void 0, false, {\n                                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                                lineNumber: 88,\n                                                columnNumber: 17\n                                            }, this)\n                                        ]\n                                    }, lang, true, {\n                                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                        lineNumber: 86,\n                                        columnNumber: 15\n                                    }, this))\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 84,\n                                columnNumber: 11\n                            }, this),\n                            errors.languages && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.languages.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 92,\n                                columnNumber: 32\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 82,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Fee Range\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 97,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"select\", {\n                                ...register(\"fee\"),\n                                className: \"w-full border rounded px-3 py-2\",\n                                children: [\n                                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                        value: \"\",\n                                        children: \"Select range\"\n                                    }, void 0, false, {\n                                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                        lineNumber: 99,\n                                        columnNumber: 13\n                                    }, this),\n                                    fees.map((f)=>/*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"option\", {\n                                            value: f,\n                                            children: f\n                                        }, f, false, {\n                                            fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                            lineNumber: 101,\n                                            columnNumber: 15\n                                        }, this))\n                                ]\n                            }, void 0, true, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 98,\n                                columnNumber: 11\n                            }, this),\n                            errors.fee && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.fee.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 104,\n                                columnNumber: 26\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 96,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Location\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 109,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"text\",\n                                ...register(\"location\"),\n                                className: \"w-full border rounded px-3 py-2\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 110,\n                                columnNumber: 11\n                            }, this),\n                            errors.location && /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"p\", {\n                                className: \"text-sm text-red-600\",\n                                children: errors.location.message\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 111,\n                                columnNumber: 31\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 108,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n                        children: [\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"label\", {\n                                className: \"block mb-1 font-medium\",\n                                children: \"Profile Image (optional)\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 116,\n                                columnNumber: 11\n                            }, this),\n                            /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"input\", {\n                                type: \"file\",\n                                accept: \"image/*\",\n                                onChange: (e)=>{\n                                    var _e_target_files;\n                                    return setImage(((_e_target_files = e.target.files) === null || _e_target_files === void 0 ? void 0 : _e_target_files[0]) || null);\n                                },\n                                className: \"w-full\"\n                            }, void 0, false, {\n                                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                                lineNumber: 117,\n                                columnNumber: 11\n                            }, this)\n                        ]\n                    }, void 0, true, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 115,\n                        columnNumber: 9\n                    }, this),\n                    /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"button\", {\n                        type: \"submit\",\n                        className: \"bg-indigo-600 text-white px-6 py-2 rounded hover:bg-indigo-700\",\n                        children: \"Submit\"\n                    }, void 0, false, {\n                        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                        lineNumber: 126,\n                        columnNumber: 9\n                    }, this)\n                ]\n            }, void 0, true, {\n                fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n                lineNumber: 51,\n                columnNumber: 7\n            }, this)\n        ]\n    }, void 0, true, {\n        fileName: \"C:\\\\Users\\\\tiger\\\\Downloads\\\\artistly\\\\app\\\\onboard\\\\page.tsx\",\n        lineNumber: 49,\n        columnNumber: 5\n    }, this);\n}\n_s(OnboardPage, \"3PKhSShrJTBHnptF1rS6EBYY9I8=\", false, function() {\n    return [\n        react_hook_form__WEBPACK_IMPORTED_MODULE_4__.useForm\n    ];\n});\n_c = OnboardPage;\nvar _c;\n$RefreshReg$(_c, \"OnboardPage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL2FwcC9vbmJvYXJkL3BhZ2UudHN4IiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7OztBQUVzRDtBQUNBO0FBQzNCO0FBQ007QUFFakMsTUFBTUksU0FBU0YsdUNBQVUsR0FBR0ksS0FBSyxDQUFDO0lBQ2hDQyxNQUFNTCx1Q0FBVSxHQUFHTyxRQUFRLENBQUM7SUFDNUJDLEtBQUtSLHVDQUFVLEdBQUdPLFFBQVEsQ0FBQztJQUMzQkUsVUFBVVQsc0NBQVMsR0FBR1csR0FBRyxDQUFDLEdBQUc7SUFDN0JDLFdBQVdaLHNDQUFTLEdBQUdXLEdBQUcsQ0FBQyxHQUFHO0lBQzlCRSxLQUFLYix1Q0FBVSxHQUFHTyxRQUFRLENBQUM7SUFDM0JPLFVBQVVkLHVDQUFVLEdBQUdPLFFBQVEsQ0FBQztBQUNsQztBQUVBLE1BQU1RLGFBQWE7SUFBQztJQUFVO0lBQVU7SUFBTTtDQUFVO0FBQ3hELE1BQU1ILFlBQVk7SUFBQztJQUFTO0lBQVc7SUFBUztDQUFVO0FBQzFELE1BQU1JLE9BQU87SUFBQztJQUFhO0lBQXFCO0lBQXFCO0NBQVk7QUFFbEUsU0FBU0M7O0lBQ3RCLE1BQU0sQ0FBQ0MsT0FBT0MsU0FBUyxHQUFHbEIsK0NBQVFBLENBQWM7SUFFaEQsTUFBTSxFQUNKbUIsUUFBUSxFQUNSQyxZQUFZLEVBQ1pDLE9BQU8sRUFDUEMsS0FBSyxFQUNMQyxXQUFXLEVBQUVDLE1BQU0sRUFBRSxFQUN0QixHQUFHM0Isd0RBQU9BLENBQUM7UUFDVjRCLFVBQVUzQixvRUFBV0EsQ0FBQ0c7UUFDdEJ5QixlQUFlO1lBQ2J0QixNQUFNO1lBQ05HLEtBQUs7WUFDTEMsVUFBVSxFQUFFO1lBQ1pHLFdBQVcsRUFBRTtZQUNiQyxLQUFLO1lBQ0xDLFVBQVU7UUFDWjtJQUNGO0lBRUEsTUFBTWMsV0FBVyxDQUFDQztRQUNoQkMsUUFBUUMsR0FBRyxDQUFDLG1CQUFtQjtZQUFFLEdBQUdGLElBQUk7WUFBRVg7UUFBTTtRQUNoRGMsTUFBTTtRQUNOVDtJQUNG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UUFBTztnQ0FDUEMsVUFBVSxDQUFDQzt3Q0FBZUE7MkNBQVRwQyxTQUFTb0MsRUFBQUEsa0JBQUFBLEVBQUVDLE1BQU0sQ0FBQ0MsS0FBSyxjQUFkRixzQ0FBQUEsZUFBZ0IsQ0FBQyxFQUFFLEtBQUk7O2dDQUNqRHJCLFdBQVU7Ozs7Ozs7Ozs7OztrQ0FLZCw4REFBQ3dCO3dCQUFPbEIsTUFBSzt3QkFBU04sV0FBVTtrQ0FBaUU7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQU16RztHQS9Hd0JqQjs7UUFTbEJuQixvREFBT0E7OztLQVRXbUIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9fTl9FLy4vYXBwL29uYm9hcmQvcGFnZS50c3g/M2Q4NCJdLCJzb3VyY2VzQ29udGVudCI6WyIndXNlIGNsaWVudCc7XHJcblxyXG5pbXBvcnQgeyB1c2VGb3JtLCBDb250cm9sbGVyIH0gZnJvbSAncmVhY3QtaG9vay1mb3JtJztcclxuaW1wb3J0IHsgeXVwUmVzb2x2ZXIgfSBmcm9tICdAaG9va2Zvcm0vcmVzb2x2ZXJzL3l1cCc7XHJcbmltcG9ydCAqIGFzIHl1cCBmcm9tICd5dXAnO1xyXG5pbXBvcnQgeyB1c2VTdGF0ZSB9IGZyb20gJ3JlYWN0JztcclxuXHJcbmNvbnN0IHNjaGVtYSA9IHl1cC5vYmplY3QoKS5zaGFwZSh7XHJcbiAgbmFtZTogeXVwLnN0cmluZygpLnJlcXVpcmVkKCdOYW1lIGlzIHJlcXVpcmVkJyksXHJcbiAgYmlvOiB5dXAuc3RyaW5nKCkucmVxdWlyZWQoJ0JpbyBpcyByZXF1aXJlZCcpLFxyXG4gIGNhdGVnb3J5OiB5dXAuYXJyYXkoKS5taW4oMSwgJ1NlbGVjdCBhdCBsZWFzdCBvbmUgY2F0ZWdvcnknKSxcclxuICBsYW5ndWFnZXM6IHl1cC5hcnJheSgpLm1pbigxLCAnU2VsZWN0IGF0IGxlYXN0IG9uZSBsYW5ndWFnZScpLFxyXG4gIGZlZTogeXVwLnN0cmluZygpLnJlcXVpcmVkKCdGZWUgcmFuZ2UgaXMgcmVxdWlyZWQnKSxcclxuICBsb2NhdGlvbjogeXVwLnN0cmluZygpLnJlcXVpcmVkKCdMb2NhdGlvbiBpcyByZXF1aXJlZCcpXHJcbn0pO1xyXG5cclxuY29uc3QgY2F0ZWdvcmllcyA9IFsnU2luZ2VyJywgJ0RhbmNlcicsICdESicsICdTcGVha2VyJ107XHJcbmNvbnN0IGxhbmd1YWdlcyA9IFsnSGluZGknLCAnRW5nbGlzaCcsICdUYW1pbCcsICdQdW5qYWJpJ107XHJcbmNvbnN0IGZlZXMgPSBbJzwg4oK5MTAsMDAwJywgJ+KCuTEwLDAwMCAtIOKCuTI1LDAwMCcsICfigrkyNSwwMDAgLSDigrk1MCwwMDAnLCAnPiDigrk1MCwwMDAnXTtcclxuXHJcbmV4cG9ydCBkZWZhdWx0IGZ1bmN0aW9uIE9uYm9hcmRQYWdlKCkge1xyXG4gIGNvbnN0IFtpbWFnZSwgc2V0SW1hZ2VdID0gdXNlU3RhdGU8RmlsZSB8IG51bGw+KG51bGwpO1xyXG5cclxuICBjb25zdCB7XHJcbiAgICByZWdpc3RlcixcclxuICAgIGhhbmRsZVN1Ym1pdCxcclxuICAgIGNvbnRyb2wsXHJcbiAgICByZXNldCxcclxuICAgIGZvcm1TdGF0ZTogeyBlcnJvcnMgfVxyXG4gIH0gPSB1c2VGb3JtKHtcclxuICAgIHJlc29sdmVyOiB5dXBSZXNvbHZlcihzY2hlbWEpLFxyXG4gICAgZGVmYXVsdFZhbHVlczoge1xyXG4gICAgICBuYW1lOiAnJyxcclxuICAgICAgYmlvOiAnJyxcclxuICAgICAgY2F0ZWdvcnk6IFtdLFxyXG4gICAgICBsYW5ndWFnZXM6IFtdLFxyXG4gICAgICBmZWU6ICcnLFxyXG4gICAgICBsb2NhdGlvbjogJydcclxuICAgIH1cclxuICB9KTtcclxuXHJcbiAgY29uc3Qgb25TdWJtaXQgPSAoZGF0YTogYW55KSA9PiB7XHJcbiAgICBjb25zb2xlLmxvZygnRm9ybSBTdWJtaXR0ZWQ6JywgeyAuLi5kYXRhLCBpbWFnZSB9KTtcclxuICAgIGFsZXJ0KCdTdWJtaXR0ZWQhIENoZWNrIGNvbnNvbGUgZm9yIG91dHB1dC4nKTtcclxuICAgIHJlc2V0KCk7XHJcbiAgfTtcclxuXHJcbiAgcmV0dXJuIChcclxuICAgIDxtYWluIGNsYXNzTmFtZT1cIm1heC13LTN4bCBteC1hdXRvIHB5LTEwIHB4LTRcIj5cclxuICAgICAgPGgyIGNsYXNzTmFtZT1cInRleHQtMnhsIGZvbnQtYm9sZCBtYi02XCI+8J+OpCBBcnRpc3QgT25ib2FyZGluZzwvaDI+XHJcbiAgICAgIDxmb3JtIG9uU3VibWl0PXtoYW5kbGVTdWJtaXQob25TdWJtaXQpfSBjbGFzc05hbWU9XCJzcGFjZS15LTZcIj5cclxuXHJcbiAgICAgICAgey8qIE5hbWUgKi99XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayBtYi0xIGZvbnQtbWVkaXVtXCI+TmFtZTwvbGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB7Li4ucmVnaXN0ZXIoJ25hbWUnKX0gY2xhc3NOYW1lPVwidy1mdWxsIGJvcmRlciByb3VuZGVkIHB4LTMgcHktMlwiIC8+XHJcbiAgICAgICAgICB7ZXJyb3JzLm5hbWUgJiYgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXJlZC02MDBcIj57ZXJyb3JzLm5hbWUubWVzc2FnZX08L3A+fVxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogQmlvICovfVxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgbWItMSBmb250LW1lZGl1bVwiPkJpbzwvbGFiZWw+XHJcbiAgICAgICAgICA8dGV4dGFyZWEgey4uLnJlZ2lzdGVyKCdiaW8nKX0gcm93cz17NH0gY2xhc3NOYW1lPVwidy1mdWxsIGJvcmRlciByb3VuZGVkIHB4LTMgcHktMlwiIC8+XHJcbiAgICAgICAgICB7ZXJyb3JzLmJpbyAmJiA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtcmVkLTYwMFwiPntlcnJvcnMuYmlvLm1lc3NhZ2V9PC9wPn1cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgey8qIENhdGVnb3J5IChtdWx0aS1zZWxlY3QgY2hlY2tib3hlcykgKi99XHJcbiAgICAgICAgPGRpdj5cclxuICAgICAgICAgIDxsYWJlbCBjbGFzc05hbWU9XCJibG9jayBtYi0xIGZvbnQtbWVkaXVtXCI+Q2F0ZWdvcnk8L2xhYmVsPlxyXG4gICAgICAgICAgPGRpdiBjbGFzc05hbWU9XCJzcGFjZS15LTFcIj5cclxuICAgICAgICAgICAge2NhdGVnb3JpZXMubWFwKChjYXQpID0+IChcclxuICAgICAgICAgICAgICA8bGFiZWwga2V5PXtjYXR9IGNsYXNzTmFtZT1cImZsZXggaXRlbXMtY2VudGVyIHNwYWNlLXgtMlwiPlxyXG4gICAgICAgICAgICAgICAgPGlucHV0IHR5cGU9XCJjaGVja2JveFwiIHZhbHVlPXtjYXR9IHsuLi5yZWdpc3RlcignY2F0ZWdvcnknKX0gLz5cclxuICAgICAgICAgICAgICAgIDxzcGFuPntjYXR9PC9zcGFuPlxyXG4gICAgICAgICAgICAgIDwvbGFiZWw+XHJcbiAgICAgICAgICAgICkpfVxyXG4gICAgICAgICAgPC9kaXY+XHJcbiAgICAgICAgICB7ZXJyb3JzLmNhdGVnb3J5ICYmIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1yZWQtNjAwXCI+e2Vycm9ycy5jYXRlZ29yeS5tZXNzYWdlfTwvcD59XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIHsvKiBMYW5ndWFnZXMgKG11bHRpLXNlbGVjdCBjaGVja2JveGVzKSAqL31cclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImJsb2NrIG1iLTEgZm9udC1tZWRpdW1cIj5MYW5ndWFnZXMgU3Bva2VuPC9sYWJlbD5cclxuICAgICAgICAgIDxkaXYgY2xhc3NOYW1lPVwic3BhY2UteS0xXCI+XHJcbiAgICAgICAgICAgIHtsYW5ndWFnZXMubWFwKChsYW5nKSA9PiAoXHJcbiAgICAgICAgICAgICAgPGxhYmVsIGtleT17bGFuZ30gY2xhc3NOYW1lPVwiZmxleCBpdGVtcy1jZW50ZXIgc3BhY2UteC0yXCI+XHJcbiAgICAgICAgICAgICAgICA8aW5wdXQgdHlwZT1cImNoZWNrYm94XCIgdmFsdWU9e2xhbmd9IHsuLi5yZWdpc3RlcignbGFuZ3VhZ2VzJyl9IC8+XHJcbiAgICAgICAgICAgICAgICA8c3Bhbj57bGFuZ308L3NwYW4+XHJcbiAgICAgICAgICAgICAgPC9sYWJlbD5cclxuICAgICAgICAgICAgKSl9XHJcbiAgICAgICAgICA8L2Rpdj5cclxuICAgICAgICAgIHtlcnJvcnMubGFuZ3VhZ2VzICYmIDxwIGNsYXNzTmFtZT1cInRleHQtc20gdGV4dC1yZWQtNjAwXCI+e2Vycm9ycy5sYW5ndWFnZXMubWVzc2FnZX08L3A+fVxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogRmVlIFJhbmdlICovfVxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgbWItMSBmb250LW1lZGl1bVwiPkZlZSBSYW5nZTwvbGFiZWw+XHJcbiAgICAgICAgICA8c2VsZWN0IHsuLi5yZWdpc3RlcignZmVlJyl9IGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXIgcm91bmRlZCBweC0zIHB5LTJcIj5cclxuICAgICAgICAgICAgPG9wdGlvbiB2YWx1ZT1cIlwiPlNlbGVjdCByYW5nZTwvb3B0aW9uPlxyXG4gICAgICAgICAgICB7ZmVlcy5tYXAoKGYpID0+IChcclxuICAgICAgICAgICAgICA8b3B0aW9uIGtleT17Zn0gdmFsdWU9e2Z9PntmfTwvb3B0aW9uPlxyXG4gICAgICAgICAgICApKX1cclxuICAgICAgICAgIDwvc2VsZWN0PlxyXG4gICAgICAgICAge2Vycm9ycy5mZWUgJiYgPHAgY2xhc3NOYW1lPVwidGV4dC1zbSB0ZXh0LXJlZC02MDBcIj57ZXJyb3JzLmZlZS5tZXNzYWdlfTwvcD59XHJcbiAgICAgICAgPC9kaXY+XHJcblxyXG4gICAgICAgIHsvKiBMb2NhdGlvbiAqL31cclxuICAgICAgICA8ZGl2PlxyXG4gICAgICAgICAgPGxhYmVsIGNsYXNzTmFtZT1cImJsb2NrIG1iLTEgZm9udC1tZWRpdW1cIj5Mb2NhdGlvbjwvbGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXQgdHlwZT1cInRleHRcIiB7Li4ucmVnaXN0ZXIoJ2xvY2F0aW9uJyl9IGNsYXNzTmFtZT1cInctZnVsbCBib3JkZXIgcm91bmRlZCBweC0zIHB5LTJcIiAvPlxyXG4gICAgICAgICAge2Vycm9ycy5sb2NhdGlvbiAmJiA8cCBjbGFzc05hbWU9XCJ0ZXh0LXNtIHRleHQtcmVkLTYwMFwiPntlcnJvcnMubG9jYXRpb24ubWVzc2FnZX08L3A+fVxyXG4gICAgICAgIDwvZGl2PlxyXG5cclxuICAgICAgICB7LyogSW1hZ2UgVXBsb2FkICovfVxyXG4gICAgICAgIDxkaXY+XHJcbiAgICAgICAgICA8bGFiZWwgY2xhc3NOYW1lPVwiYmxvY2sgbWItMSBmb250LW1lZGl1bVwiPlByb2ZpbGUgSW1hZ2UgKG9wdGlvbmFsKTwvbGFiZWw+XHJcbiAgICAgICAgICA8aW5wdXRcclxuICAgICAgICAgICAgdHlwZT1cImZpbGVcIlxyXG4gICAgICAgICAgICBhY2NlcHQ9XCJpbWFnZS8qXCJcclxuICAgICAgICAgICAgb25DaGFuZ2U9eyhlKSA9PiBzZXRJbWFnZShlLnRhcmdldC5maWxlcz8uWzBdIHx8IG51bGwpfVxyXG4gICAgICAgICAgICBjbGFzc05hbWU9XCJ3LWZ1bGxcIlxyXG4gICAgICAgICAgLz5cclxuICAgICAgICA8L2Rpdj5cclxuXHJcbiAgICAgICAgey8qIFN1Ym1pdCAqL31cclxuICAgICAgICA8YnV0dG9uIHR5cGU9XCJzdWJtaXRcIiBjbGFzc05hbWU9XCJiZy1pbmRpZ28tNjAwIHRleHQtd2hpdGUgcHgtNiBweS0yIHJvdW5kZWQgaG92ZXI6YmctaW5kaWdvLTcwMFwiPlxyXG4gICAgICAgICAgU3VibWl0XHJcbiAgICAgICAgPC9idXR0b24+XHJcbiAgICAgIDwvZm9ybT5cclxuICAgIDwvbWFpbj5cclxuICApO1xyXG59XHJcbiJdLCJuYW1lcyI6WyJ1c2VGb3JtIiwieXVwUmVzb2x2ZXIiLCJ5dXAiLCJ1c2VTdGF0ZSIsInNjaGVtYSIsIm9iamVjdCIsInNoYXBlIiwibmFtZSIsInN0cmluZyIsInJlcXVpcmVkIiwiYmlvIiwiY2F0ZWdvcnkiLCJhcnJheSIsIm1pbiIsImxhbmd1YWdlcyIsImZlZSIsImxvY2F0aW9uIiwiY2F0ZWdvcmllcyIsImZlZXMiLCJPbmJvYXJkUGFnZSIsImltYWdlIiwic2V0SW1hZ2UiLCJyZWdpc3RlciIsImhhbmRsZVN1Ym1pdCIsImNvbnRyb2wiLCJyZXNldCIsImZvcm1TdGF0ZSIsImVycm9ycyIsInJlc29sdmVyIiwiZGVmYXVsdFZhbHVlcyIsIm9uU3VibWl0IiwiZGF0YSIsImNvbnNvbGUiLCJsb2ciLCJhbGVydCIsIm1haW4iLCJjbGFzc05hbWUiLCJoMiIsImZvcm0iLCJkaXYiLCJsYWJlbCIsImlucHV0IiwidHlwZSIsInAiLCJtZXNzYWdlIiwidGV4dGFyZWEiLCJyb3dzIiwibWFwIiwiY2F0IiwidmFsdWUiLCJzcGFuIiwibGFuZyIsInNlbGVjdCIsIm9wdGlvbiIsImYiLCJhY2NlcHQiLCJvbkNoYW5nZSIsImUiLCJ0YXJnZXQiLCJmaWxlcyIsImJ1dHRvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/onboard/page.tsx\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@hookform/resolvers/dist/resolvers.mjs":
/*!*************************************************************!*\
  !*** ./node_modules/@hookform/resolvers/dist/resolvers.mjs ***!
  \*************************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   toNestErrors: function() { return /* binding */ s; },\n/* harmony export */   validateFieldsNatively: function() { return /* binding */ o; }\n/* harmony export */ });\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react-hook-form */ \"(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs\");\n\nconst r = (t, r, o)=>{\n    if (t && \"reportValidity\" in t) {\n        const s = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.get)(o, r);\n        t.setCustomValidity(s && s.message || \"\"), t.reportValidity();\n    }\n}, o = (e, t)=>{\n    for(const o in t.fields){\n        const s = t.fields[o];\n        s && s.ref && \"reportValidity\" in s.ref ? r(s.ref, o, e) : s && s.refs && s.refs.forEach((t)=>r(t, o, e));\n    }\n}, s = (r, s)=>{\n    s.shouldUseNativeValidation && o(r, s);\n    const n = {};\n    for(const o in r){\n        const f = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.get)(s.fields, o), c = Object.assign(r[o] || {}, {\n            ref: f && f.ref\n        });\n        if (i(s.names || Object.keys(r), o)) {\n            const r = Object.assign({}, (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.get)(n, o));\n            (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.set)(r, \"root\", c), (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.set)(n, o, r);\n        } else (0,react_hook_form__WEBPACK_IMPORTED_MODULE_0__.set)(n, o, c);\n    }\n    return n;\n}, i = (e, t)=>{\n    const r = n(t);\n    return e.some((e)=>n(e).match(\"^\".concat(r, \"\\\\.\\\\d+\")));\n};\nfunction n(e) {\n    return e.replace(/\\]|\\[/g, \"\");\n}\n //# sourceMappingURL=resolvers.mjs.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaG9va2Zvcm0vcmVzb2x2ZXJzL2Rpc3QvcmVzb2x2ZXJzLm1qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0M7QUFBQSxNQUFNSSxJQUFFLENBQUNELEdBQUVDLEdBQUVDO0lBQUssSUFBR0YsS0FBRyxvQkFBbUJBLEdBQUU7UUFBQyxNQUFNRyxJQUFFTCxvREFBQ0EsQ0FBQ0ksR0FBRUQ7UUFBR0QsRUFBRUksaUJBQWlCLENBQUNELEtBQUdBLEVBQUVFLE9BQU8sSUFBRSxLQUFJTCxFQUFFTSxjQUFjO0lBQUU7QUFBQyxHQUFFSixJQUFFLENBQUNKLEdBQUVFO0lBQUssSUFBSSxNQUFNRSxLQUFLRixFQUFFTyxNQUFNLENBQUM7UUFBQyxNQUFNSixJQUFFSCxFQUFFTyxNQUFNLENBQUNMLEVBQUU7UUFBQ0MsS0FBR0EsRUFBRUssR0FBRyxJQUFFLG9CQUFtQkwsRUFBRUssR0FBRyxHQUFDUCxFQUFFRSxFQUFFSyxHQUFHLEVBQUNOLEdBQUVKLEtBQUdLLEtBQUdBLEVBQUVNLElBQUksSUFBRU4sRUFBRU0sSUFBSSxDQUFDQyxPQUFPLENBQUNWLENBQUFBLElBQUdDLEVBQUVELEdBQUVFLEdBQUVKO0lBQUc7QUFBQyxHQUFFSyxJQUFFLENBQUNGLEdBQUVFO0lBQUtBLEVBQUVRLHlCQUF5QixJQUFFVCxFQUFFRCxHQUFFRTtJQUFHLE1BQU1TLElBQUUsQ0FBQztJQUFFLElBQUksTUFBTVYsS0FBS0QsRUFBRTtRQUFDLE1BQU1ZLElBQUVmLG9EQUFDQSxDQUFDSyxFQUFFSSxNQUFNLEVBQUNMLElBQUdZLElBQUVDLE9BQU9DLE1BQU0sQ0FBQ2YsQ0FBQyxDQUFDQyxFQUFFLElBQUUsQ0FBQyxHQUFFO1lBQUNNLEtBQUlLLEtBQUdBLEVBQUVMLEdBQUc7UUFBQTtRQUFHLElBQUdTLEVBQUVkLEVBQUVlLEtBQUssSUFBRUgsT0FBT0ksSUFBSSxDQUFDbEIsSUFBR0MsSUFBRztZQUFDLE1BQU1ELElBQUVjLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUVsQixvREFBQ0EsQ0FBQ2MsR0FBRVY7WUFBSUYsb0RBQUNBLENBQUNDLEdBQUUsUUFBT2EsSUFBR2Qsb0RBQUNBLENBQUNZLEdBQUVWLEdBQUVEO1FBQUUsT0FBTUQsb0RBQUNBLENBQUNZLEdBQUVWLEdBQUVZO0lBQUU7SUFBQyxPQUFPRjtBQUFDLEdBQUVLLElBQUUsQ0FBQ25CLEdBQUVFO0lBQUssTUFBTUMsSUFBRVcsRUFBRVo7SUFBRyxPQUFPRixFQUFFc0IsSUFBSSxDQUFDdEIsQ0FBQUEsSUFBR2MsRUFBRWQsR0FBR3VCLEtBQUssQ0FBQyxJQUFNLE9BQUZwQixHQUFFO0FBQVU7QUFBRSxTQUFTVyxFQUFFZCxDQUFDO0lBQUUsT0FBT0EsRUFBRXdCLE9BQU8sQ0FBQyxVQUFTO0FBQUc7QUFBdUQsQ0FDenRCLHNDQUFzQyIsInNvdXJjZXMiOlsid2VicGFjazovL19OX0UvLi9ub2RlX21vZHVsZXMvQGhvb2tmb3JtL3Jlc29sdmVycy9kaXN0L3Jlc29sdmVycy5tanM/OWUyMCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7Z2V0IGFzIGUsc2V0IGFzIHR9ZnJvbVwicmVhY3QtaG9vay1mb3JtXCI7Y29uc3Qgcj0odCxyLG8pPT57aWYodCYmXCJyZXBvcnRWYWxpZGl0eVwiaW4gdCl7Y29uc3Qgcz1lKG8scik7dC5zZXRDdXN0b21WYWxpZGl0eShzJiZzLm1lc3NhZ2V8fFwiXCIpLHQucmVwb3J0VmFsaWRpdHkoKX19LG89KGUsdCk9Pntmb3IoY29uc3QgbyBpbiB0LmZpZWxkcyl7Y29uc3Qgcz10LmZpZWxkc1tvXTtzJiZzLnJlZiYmXCJyZXBvcnRWYWxpZGl0eVwiaW4gcy5yZWY/cihzLnJlZixvLGUpOnMmJnMucmVmcyYmcy5yZWZzLmZvckVhY2godD0+cih0LG8sZSkpfX0scz0ocixzKT0+e3Muc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiYmbyhyLHMpO2NvbnN0IG49e307Zm9yKGNvbnN0IG8gaW4gcil7Y29uc3QgZj1lKHMuZmllbGRzLG8pLGM9T2JqZWN0LmFzc2lnbihyW29dfHx7fSx7cmVmOmYmJmYucmVmfSk7aWYoaShzLm5hbWVzfHxPYmplY3Qua2V5cyhyKSxvKSl7Y29uc3Qgcj1PYmplY3QuYXNzaWduKHt9LGUobixvKSk7dChyLFwicm9vdFwiLGMpLHQobixvLHIpfWVsc2UgdChuLG8sYyl9cmV0dXJuIG59LGk9KGUsdCk9Pntjb25zdCByPW4odCk7cmV0dXJuIGUuc29tZShlPT5uKGUpLm1hdGNoKGBeJHtyfVxcXFwuXFxcXGQrYCkpfTtmdW5jdGlvbiBuKGUpe3JldHVybiBlLnJlcGxhY2UoL1xcXXxcXFsvZyxcIlwiKX1leHBvcnR7cyBhcyB0b05lc3RFcnJvcnMsbyBhcyB2YWxpZGF0ZUZpZWxkc05hdGl2ZWx5fTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPXJlc29sdmVycy5tanMubWFwXG4iXSwibmFtZXMiOlsiZ2V0IiwiZSIsInNldCIsInQiLCJyIiwibyIsInMiLCJzZXRDdXN0b21WYWxpZGl0eSIsIm1lc3NhZ2UiLCJyZXBvcnRWYWxpZGl0eSIsImZpZWxkcyIsInJlZiIsInJlZnMiLCJmb3JFYWNoIiwic2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiIsIm4iLCJmIiwiYyIsIk9iamVjdCIsImFzc2lnbiIsImkiLCJuYW1lcyIsImtleXMiLCJzb21lIiwibWF0Y2giLCJyZXBsYWNlIiwidG9OZXN0RXJyb3JzIiwidmFsaWRhdGVGaWVsZHNOYXRpdmVseSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@hookform/resolvers/dist/resolvers.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/@hookform/resolvers/yup/dist/yup.mjs":
/*!***********************************************************!*\
  !*** ./node_modules/@hookform/resolvers/yup/dist/yup.mjs ***!
  \***********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   yupResolver: function() { return /* binding */ o; }\n/* harmony export */ });\n/* harmony import */ var _hookform_resolvers__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @hookform/resolvers */ \"(app-pages-browser)/./node_modules/@hookform/resolvers/dist/resolvers.mjs\");\n/* harmony import */ var react_hook_form__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-hook-form */ \"(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs\");\n\n\nfunction o(o, n, s) {\n    return void 0 === s && (s = {}), function(a, i, c) {\n        try {\n            return Promise.resolve(function(t, r) {\n                try {\n                    var u = (null != n && n.context && \"development\" === \"development\" && console.warn(\"You should not used the yup options context. Please, use the 'useForm' context object instead\"), Promise.resolve(o[\"sync\" === s.mode ? \"validateSync\" : \"validate\"](a, Object.assign({\n                        abortEarly: !1\n                    }, n, {\n                        context: i\n                    }))).then(function(t) {\n                        return c.shouldUseNativeValidation && (0,_hookform_resolvers__WEBPACK_IMPORTED_MODULE_0__.validateFieldsNatively)({}, c), {\n                            values: s.raw ? Object.assign({}, a) : t,\n                            errors: {}\n                        };\n                    }));\n                } catch (e) {\n                    return r(e);\n                }\n                return u && u.then ? u.then(void 0, r) : u;\n            }(0, function(e) {\n                if (!e.inner) throw e;\n                return {\n                    values: {},\n                    errors: (0,_hookform_resolvers__WEBPACK_IMPORTED_MODULE_0__.toNestErrors)((o = e, n = !c.shouldUseNativeValidation && \"all\" === c.criteriaMode, (o.inner || []).reduce(function(e, t) {\n                        if (e[t.path] || (e[t.path] = {\n                            message: t.message,\n                            type: t.type\n                        }), n) {\n                            var o = e[t.path].types, s = o && o[t.type];\n                            e[t.path] = (0,react_hook_form__WEBPACK_IMPORTED_MODULE_1__.appendErrors)(t.path, n, e, t.type, s ? [].concat(s, t.message) : t.message);\n                        }\n                        return e;\n                    }, {})), c)\n                };\n                var o, n;\n            }));\n        } catch (e) {\n            return Promise.reject(e);\n        }\n    };\n}\n //# sourceMappingURL=yup.module.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9AaG9va2Zvcm0vcmVzb2x2ZXJzL3l1cC9kaXN0L3l1cC5tanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQStFO0FBQStDO0FBQUEsU0FBU00sRUFBRUEsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7SUFBRSxPQUFPLEtBQUssTUFBSUEsS0FBSUEsQ0FBQUEsSUFBRSxDQUFDLElBQUcsU0FBU0MsQ0FBQyxFQUFDQyxDQUFDLEVBQUNDLENBQUM7UUFBRSxJQUFHO1lBQUMsT0FBT0MsUUFBUUMsT0FBTyxDQUFDLFNBQVNWLENBQUMsRUFBQ0UsQ0FBQztnQkFBRSxJQUFHO29CQUFDLElBQUlTLElBQUcsU0FBTVAsS0FBR0EsRUFBRVEsT0FBTyxJQUFFLGtCQUFsUSxpQkFBd1NDLFFBQVFDLElBQUksQ0FBQyxrR0FBaUdMLFFBQVFDLE9BQU8sQ0FBQ1AsQ0FBQyxDQUFDLFdBQVNFLEVBQUVVLElBQUksR0FBQyxpQkFBZSxXQUFXLENBQUNULEdBQUVVLE9BQU9DLE1BQU0sQ0FBQzt3QkFBQ0MsWUFBVyxDQUFDO29CQUFDLEdBQUVkLEdBQUU7d0JBQUNRLFNBQVFMO29CQUFDLEtBQUtZLElBQUksQ0FBQyxTQUFTbkIsQ0FBQzt3QkFBRSxPQUFPUSxFQUFFWSx5QkFBeUIsSUFBRXRCLDJFQUFDQSxDQUFDLENBQUMsR0FBRVUsSUFBRzs0QkFBQ2EsUUFBT2hCLEVBQUVpQixHQUFHLEdBQUNOLE9BQU9DLE1BQU0sQ0FBQyxDQUFDLEdBQUVYLEtBQUdOOzRCQUFFdUIsUUFBTyxDQUFDO3dCQUFDO29CQUFDLEVBQUM7Z0JBQUUsRUFBQyxPQUFNekIsR0FBRTtvQkFBQyxPQUFPSSxFQUFFSjtnQkFBRTtnQkFBQyxPQUFPYSxLQUFHQSxFQUFFUSxJQUFJLEdBQUNSLEVBQUVRLElBQUksQ0FBQyxLQUFLLEdBQUVqQixLQUFHUztZQUFDLEVBQUUsR0FBRSxTQUFTYixDQUFDO2dCQUFFLElBQUcsQ0FBQ0EsRUFBRTBCLEtBQUssRUFBQyxNQUFNMUI7Z0JBQUUsT0FBTTtvQkFBQ3VCLFFBQU8sQ0FBQztvQkFBRUUsUUFBT3ZCLGlFQUFDQSxDQUFFRyxDQUFBQSxJQUFFTCxHQUFFTSxJQUFFLENBQUNJLEVBQUVZLHlCQUF5QixJQUFFLFVBQVFaLEVBQUVpQixZQUFZLEVBQUMsQ0FBQ3RCLEVBQUVxQixLQUFLLElBQUUsRUFBRSxFQUFFRSxNQUFNLENBQUMsU0FBUzVCLENBQUMsRUFBQ0UsQ0FBQzt3QkFBRSxJQUFHRixDQUFDLENBQUNFLEVBQUUyQixJQUFJLENBQUMsSUFBRzdCLENBQUFBLENBQUMsQ0FBQ0UsRUFBRTJCLElBQUksQ0FBQyxHQUFDOzRCQUFDQyxTQUFRNUIsRUFBRTRCLE9BQU87NEJBQUNDLE1BQUs3QixFQUFFNkIsSUFBSTt3QkFBQSxJQUFHekIsR0FBRTs0QkFBQyxJQUFJRCxJQUFFTCxDQUFDLENBQUNFLEVBQUUyQixJQUFJLENBQUMsQ0FBQ0csS0FBSyxFQUFDekIsSUFBRUYsS0FBR0EsQ0FBQyxDQUFDSCxFQUFFNkIsSUFBSSxDQUFDOzRCQUFDL0IsQ0FBQyxDQUFDRSxFQUFFMkIsSUFBSSxDQUFDLEdBQUN6Qiw2REFBQ0EsQ0FBQ0YsRUFBRTJCLElBQUksRUFBQ3ZCLEdBQUVOLEdBQUVFLEVBQUU2QixJQUFJLEVBQUN4QixJQUFFLEVBQUUsQ0FBQzBCLE1BQU0sQ0FBQzFCLEdBQUVMLEVBQUU0QixPQUFPLElBQUU1QixFQUFFNEIsT0FBTzt3QkFBQzt3QkFBQyxPQUFPOUI7b0JBQUMsR0FBRSxDQUFDLEVBQUMsR0FBR1U7Z0JBQUU7Z0JBQUUsSUFBSUwsR0FBRUM7WUFBQztRQUFHLEVBQUMsT0FBTU4sR0FBRTtZQUFDLE9BQU9XLFFBQVF1QixNQUFNLENBQUNsQztRQUFFO0lBQUM7QUFBQztBQUEwQixDQUN2a0Msc0NBQXNDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vX05fRS8uL25vZGVfbW9kdWxlcy9AaG9va2Zvcm0vcmVzb2x2ZXJzL3l1cC9kaXN0L3l1cC5tanM/M2RiZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnR7dmFsaWRhdGVGaWVsZHNOYXRpdmVseSBhcyBlLHRvTmVzdEVycm9ycyBhcyB0fWZyb21cIkBob29rZm9ybS9yZXNvbHZlcnNcIjtpbXBvcnR7YXBwZW5kRXJyb3JzIGFzIHJ9ZnJvbVwicmVhY3QtaG9vay1mb3JtXCI7ZnVuY3Rpb24gbyhvLG4scyl7cmV0dXJuIHZvaWQgMD09PXMmJihzPXt9KSxmdW5jdGlvbihhLGksYyl7dHJ5e3JldHVybiBQcm9taXNlLnJlc29sdmUoZnVuY3Rpb24odCxyKXt0cnl7dmFyIHU9KG51bGwhPW4mJm4uY29udGV4dCYmXCJkZXZlbG9wbWVudFwiPT09cHJvY2Vzcy5lbnYuTk9ERV9FTlYmJmNvbnNvbGUud2FybihcIllvdSBzaG91bGQgbm90IHVzZWQgdGhlIHl1cCBvcHRpb25zIGNvbnRleHQuIFBsZWFzZSwgdXNlIHRoZSAndXNlRm9ybScgY29udGV4dCBvYmplY3QgaW5zdGVhZFwiKSxQcm9taXNlLnJlc29sdmUob1tcInN5bmNcIj09PXMubW9kZT9cInZhbGlkYXRlU3luY1wiOlwidmFsaWRhdGVcIl0oYSxPYmplY3QuYXNzaWduKHthYm9ydEVhcmx5OiExfSxuLHtjb250ZXh0Oml9KSkpLnRoZW4oZnVuY3Rpb24odCl7cmV0dXJuIGMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiYmZSh7fSxjKSx7dmFsdWVzOnMucmF3P09iamVjdC5hc3NpZ24oe30sYSk6dCxlcnJvcnM6e319fSkpfWNhdGNoKGUpe3JldHVybiByKGUpfXJldHVybiB1JiZ1LnRoZW4/dS50aGVuKHZvaWQgMCxyKTp1fSgwLGZ1bmN0aW9uKGUpe2lmKCFlLmlubmVyKXRocm93IGU7cmV0dXJue3ZhbHVlczp7fSxlcnJvcnM6dCgobz1lLG49IWMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiYmXCJhbGxcIj09PWMuY3JpdGVyaWFNb2RlLChvLmlubmVyfHxbXSkucmVkdWNlKGZ1bmN0aW9uKGUsdCl7aWYoZVt0LnBhdGhdfHwoZVt0LnBhdGhdPXttZXNzYWdlOnQubWVzc2FnZSx0eXBlOnQudHlwZX0pLG4pe3ZhciBvPWVbdC5wYXRoXS50eXBlcyxzPW8mJm9bdC50eXBlXTtlW3QucGF0aF09cih0LnBhdGgsbixlLHQudHlwZSxzP1tdLmNvbmNhdChzLHQubWVzc2FnZSk6dC5tZXNzYWdlKX1yZXR1cm4gZX0se30pKSxjKX07dmFyIG8sbn0pKX1jYXRjaChlKXtyZXR1cm4gUHJvbWlzZS5yZWplY3QoZSl9fX1leHBvcnR7byBhcyB5dXBSZXNvbHZlcn07XG4vLyMgc291cmNlTWFwcGluZ1VSTD15dXAubW9kdWxlLmpzLm1hcFxuIl0sIm5hbWVzIjpbInZhbGlkYXRlRmllbGRzTmF0aXZlbHkiLCJlIiwidG9OZXN0RXJyb3JzIiwidCIsImFwcGVuZEVycm9ycyIsInIiLCJvIiwibiIsInMiLCJhIiwiaSIsImMiLCJQcm9taXNlIiwicmVzb2x2ZSIsInUiLCJjb250ZXh0IiwiY29uc29sZSIsIndhcm4iLCJtb2RlIiwiT2JqZWN0IiwiYXNzaWduIiwiYWJvcnRFYXJseSIsInRoZW4iLCJzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uIiwidmFsdWVzIiwicmF3IiwiZXJyb3JzIiwiaW5uZXIiLCJjcml0ZXJpYU1vZGUiLCJyZWR1Y2UiLCJwYXRoIiwibWVzc2FnZSIsInR5cGUiLCJ0eXBlcyIsImNvbmNhdCIsInJlamVjdCIsInl1cFJlc29sdmVyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/@hookform/resolvers/yup/dist/yup.mjs\n"));

/***/ }),

/***/ "(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs":
/*!*********************************************************!*\
  !*** ./node_modules/react-hook-form/dist/index.esm.mjs ***!
  \*********************************************************/
/***/ (function(__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) {

"use strict";
eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Controller: function() { return /* binding */ Controller; },\n/* harmony export */   Form: function() { return /* binding */ Form; },\n/* harmony export */   FormProvider: function() { return /* binding */ FormProvider; },\n/* harmony export */   appendErrors: function() { return /* binding */ appendErrors; },\n/* harmony export */   createFormControl: function() { return /* binding */ createFormControl; },\n/* harmony export */   get: function() { return /* binding */ get; },\n/* harmony export */   set: function() { return /* binding */ set; },\n/* harmony export */   useController: function() { return /* binding */ useController; },\n/* harmony export */   useFieldArray: function() { return /* binding */ useFieldArray; },\n/* harmony export */   useForm: function() { return /* binding */ useForm; },\n/* harmony export */   useFormContext: function() { return /* binding */ useFormContext; },\n/* harmony export */   useFormState: function() { return /* binding */ useFormState; },\n/* harmony export */   useWatch: function() { return /* binding */ useWatch; }\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/next/dist/compiled/react/index.js\");\nvar _s = $RefreshSig$(), _s1 = $RefreshSig$(), _s2 = $RefreshSig$(), _s3 = $RefreshSig$(), _s4 = $RefreshSig$(), _s5 = $RefreshSig$(), _s6 = $RefreshSig$(), _s7 = $RefreshSig$();\n\n\nvar isCheckBoxInput = (element)=>element.type === \"checkbox\";\nvar isDateObject = (value1)=>value1 instanceof Date;\nvar isNullOrUndefined = (value1)=>value1 == null;\nconst isObjectType = (value1)=>typeof value1 === \"object\";\nvar isObject = (value1)=>!isNullOrUndefined(value1) && !Array.isArray(value1) && isObjectType(value1) && !isDateObject(value1);\nvar getEventValue = (event)=>isObject(event) && event.target ? isCheckBoxInput(event.target) ? event.target.checked : event.target.value : event;\nvar getNodeParentName = (name)=>name.substring(0, name.search(/\\.\\d+(\\.|$)/)) || name;\nvar isNameInFieldArray = (names, name)=>names.has(getNodeParentName(name));\nvar isPlainObject = (tempObject)=>{\n    const prototypeCopy = tempObject.constructor && tempObject.constructor.prototype;\n    return isObject(prototypeCopy) && prototypeCopy.hasOwnProperty(\"isPrototypeOf\");\n};\nvar isWeb =  true && typeof window.HTMLElement !== \"undefined\" && typeof document !== \"undefined\";\nfunction cloneObject(data) {\n    let copy;\n    const isArray = Array.isArray(data);\n    const isFileListInstance = typeof FileList !== \"undefined\" ? data instanceof FileList : false;\n    if (data instanceof Date) {\n        copy = new Date(data);\n    } else if (data instanceof Set) {\n        copy = new Set(data);\n    } else if (!(isWeb && (data instanceof Blob || isFileListInstance)) && (isArray || isObject(data))) {\n        copy = isArray ? [] : {};\n        if (!isArray && !isPlainObject(data)) {\n            copy = data;\n        } else {\n            for(const key in data){\n                if (data.hasOwnProperty(key)) {\n                    copy[key] = cloneObject(data[key]);\n                }\n            }\n        }\n    } else {\n        return data;\n    }\n    return copy;\n}\nvar isKey = (value1)=>/^\\w*$/.test(value1);\nvar isUndefined = (val)=>val === undefined;\nvar compact = (value1)=>Array.isArray(value1) ? value1.filter(Boolean) : [];\nvar stringToPath = (input)=>compact(input.replace(/[\"|']|\\]/g, \"\").split(/\\.|\\[/));\nvar get = (object, path, defaultValue)=>{\n    if (!path || !isObject(object)) {\n        return defaultValue;\n    }\n    const result = (isKey(path) ? [\n        path\n    ] : stringToPath(path)).reduce((result, key)=>isNullOrUndefined(result) ? result : result[key], object);\n    return isUndefined(result) || result === object ? isUndefined(object[path]) ? defaultValue : object[path] : result;\n};\nvar isBoolean = (value1)=>typeof value1 === \"boolean\";\nvar set = (object, path, value1)=>{\n    let index = -1;\n    const tempPath = isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const length = tempPath.length;\n    const lastIndex = length - 1;\n    while(++index < length){\n        const key = tempPath[index];\n        let newValue = value1;\n        if (index !== lastIndex) {\n            const objValue = object[key];\n            newValue = isObject(objValue) || Array.isArray(objValue) ? objValue : !isNaN(+tempPath[index + 1]) ? [] : {};\n        }\n        if (key === \"__proto__\" || key === \"constructor\" || key === \"prototype\") {\n            return;\n        }\n        object[key] = newValue;\n        object = object[key];\n    }\n};\nconst EVENTS = {\n    BLUR: \"blur\",\n    FOCUS_OUT: \"focusout\",\n    CHANGE: \"change\"\n};\nconst VALIDATION_MODE = {\n    onBlur: \"onBlur\",\n    onChange: \"onChange\",\n    onSubmit: \"onSubmit\",\n    onTouched: \"onTouched\",\n    all: \"all\"\n};\nconst INPUT_VALIDATION_RULES = {\n    max: \"max\",\n    min: \"min\",\n    maxLength: \"maxLength\",\n    minLength: \"minLength\",\n    pattern: \"pattern\",\n    required: \"required\",\n    validate: \"validate\"\n};\nconst HookFormContext = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nHookFormContext.displayName = \"HookFormContext\";\n/**\n * This custom hook allows you to access the form context. useFormContext is intended to be used in deeply nested structures, where it would become inconvenient to pass the context as a prop. To be used with {@link FormProvider}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @returns return all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const useFormContext = ()=>{\n    _s();\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(HookFormContext);\n};\n_s(useFormContext, \"gDsCjeeItUuvgOWf1v4qoK9RF6k=\");\n/**\n * A provider component that propagates the `useForm` methods to all children components via [React Context](https://reactjs.org/docs/context.html) API. To be used with {@link useFormContext}.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformcontext) • [Demo](https://codesandbox.io/s/react-hook-form-v7-form-context-ytudi)\n *\n * @param props - all useForm methods\n *\n * @example\n * ```tsx\n * function App() {\n *   const methods = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   return (\n *     <FormProvider {...methods} >\n *       <form onSubmit={methods.handleSubmit(onSubmit)}>\n *         <NestedInput />\n *         <input type=\"submit\" />\n *       </form>\n *     </FormProvider>\n *   );\n * }\n *\n *  function NestedInput() {\n *   const { register } = useFormContext(); // retrieve all hook methods\n *   return <input {...register(\"test\")} />;\n * }\n * ```\n */ const FormProvider = (props)=>{\n    const { children, ...data } = props;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(HookFormContext.Provider, {\n        value: data\n    }, children);\n};\n_c = FormProvider;\nvar getProxyFormState = function(formState, control, localProxyFormState) {\n    let isRoot = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : true;\n    const result = {\n        defaultValues: control._defaultValues\n    };\n    for(const key in formState){\n        Object.defineProperty(result, key, {\n            get: ()=>{\n                const _key = key;\n                if (control._proxyFormState[_key] !== VALIDATION_MODE.all) {\n                    control._proxyFormState[_key] = !isRoot || VALIDATION_MODE.all;\n                }\n                localProxyFormState && (localProxyFormState[_key] = true);\n                return formState[_key];\n            }\n        });\n    }\n    return result;\n};\nconst useIsomorphicLayoutEffect =  true ? react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect : 0;\n/**\n * This custom hook allows you to subscribe to each form state, and isolate the re-render at the custom hook level. It has its scope in terms of form state subscription, so it would not affect other useFormState and useForm. Using this hook can reduce the re-render impact on large and complex form application.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useformstate) • [Demo](https://codesandbox.io/s/useformstate-75xly)\n *\n * @param props - include options on specify fields to subscribe. {@link UseFormStateReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, control } = useForm({\n *     defaultValues: {\n *     firstName: \"firstName\"\n *   }});\n *   const { dirtyFields } = useFormState({\n *     control\n *   });\n *   const onSubmit = (data) => console.log(data);\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input {...register(\"firstName\")} placeholder=\"First Name\" />\n *       {dirtyFields.firstName && <p>Field is dirty.</p>}\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFormState(props) {\n    _s1();\n    const methods = useFormContext();\n    const { control = methods.control, disabled, name, exact } = props || {};\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._formState);\n    const _localProxyFormState = react__WEBPACK_IMPORTED_MODULE_0__.useRef({\n        isDirty: false,\n        isLoading: false,\n        dirtyFields: false,\n        touchedFields: false,\n        validatingFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    });\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: _localProxyFormState.current,\n            exact,\n            callback: (formState)=>{\n                !disabled && updateFormState({\n                    ...control._formState,\n                    ...formState\n                });\n            }\n        }), [\n        name,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        _localProxyFormState.current.isValid && control._setValid(true);\n    }, [\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>getProxyFormState(formState, control, _localProxyFormState.current, false), [\n        formState,\n        control\n    ]);\n}\n_s1(useFormState, \"47t2d+znfh7l4dYX8UoToAjQn38=\", false, function() {\n    return [\n        useFormContext,\n        useIsomorphicLayoutEffect\n    ];\n});\nvar isString = (value1)=>typeof value1 === \"string\";\nvar generateWatchOutput = (names, _names, formValues, isGlobal, defaultValue)=>{\n    if (isString(names)) {\n        isGlobal && _names.watch.add(names);\n        return get(formValues, names, defaultValue);\n    }\n    if (Array.isArray(names)) {\n        return names.map((fieldName)=>(isGlobal && _names.watch.add(fieldName), get(formValues, fieldName)));\n    }\n    isGlobal && (_names.watchAll = true);\n    return formValues;\n};\n/**\n * Custom hook to subscribe to field change and isolate re-rendering at the component level.\n *\n * @remarks\n *\n * [API](https://react-hook-form.com/docs/usewatch) • [Demo](https://codesandbox.io/s/react-hook-form-v7-ts-usewatch-h9i5e)\n *\n * @example\n * ```tsx\n * const { control } = useForm();\n * const values = useWatch({\n *   name: \"fieldName\"\n *   control,\n * })\n * ```\n */ function useWatch(props) {\n    _s2();\n    const methods = useFormContext();\n    const { control = methods.control, name, defaultValue, disabled, exact } = props || {};\n    const _defaultValue = react__WEBPACK_IMPORTED_MODULE_0__.useRef(defaultValue);\n    const [value1, updateValue] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getWatch(name, _defaultValue.current));\n    useIsomorphicLayoutEffect(()=>control._subscribe({\n            name,\n            formState: {\n                values: true\n            },\n            exact,\n            callback: (formState)=>!disabled && updateValue(generateWatchOutput(name, control._names, formState.values || control._formValues, false, _defaultValue.current))\n        }), [\n        name,\n        control,\n        disabled,\n        exact\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._removeUnmounted());\n    return value1;\n}\n_s2(useWatch, \"ES1ynaV6GzXmlEUYp0vexgrWJc4=\", false, function() {\n    return [\n        useFormContext,\n        useIsomorphicLayoutEffect\n    ];\n});\n/**\n * Custom hook to work with controlled component, this function provide you with both form and field level state. Re-render is isolated at the hook level.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller) • [Demo](https://codesandbox.io/s/usecontroller-0o8px)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns field properties, field and form state. {@link UseControllerReturn}\n *\n * @example\n * ```tsx\n * function Input(props) {\n *   const { field, fieldState, formState } = useController(props);\n *   return (\n *     <div>\n *       <input {...field} placeholder={props.name} />\n *       <p>{fieldState.isTouched && \"Touched\"}</p>\n *       <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *     </div>\n *   );\n * }\n * ```\n */ function useController(props) {\n    _s3();\n    const methods = useFormContext();\n    const { name, disabled, control = methods.control, shouldUnregister } = props;\n    const isArrayField = isNameInFieldArray(control._names.array, name);\n    const value1 = useWatch({\n        control,\n        name,\n        defaultValue: get(control._formValues, name, get(control._defaultValues, name, props.defaultValue)),\n        exact: true\n    });\n    const formState = useFormState({\n        control,\n        name,\n        exact: true\n    });\n    const _props = react__WEBPACK_IMPORTED_MODULE_0__.useRef(props);\n    const _registerProps = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control.register(name, {\n        ...props.rules,\n        value: value1,\n        ...isBoolean(props.disabled) ? {\n            disabled: props.disabled\n        } : {}\n    }));\n    const fieldState = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>Object.defineProperties({}, {\n            invalid: {\n                enumerable: true,\n                get: ()=>!!get(formState.errors, name)\n            },\n            isDirty: {\n                enumerable: true,\n                get: ()=>!!get(formState.dirtyFields, name)\n            },\n            isTouched: {\n                enumerable: true,\n                get: ()=>!!get(formState.touchedFields, name)\n            },\n            isValidating: {\n                enumerable: true,\n                get: ()=>!!get(formState.validatingFields, name)\n            },\n            error: {\n                enumerable: true,\n                get: ()=>get(formState.errors, name)\n            }\n        }), [\n        formState,\n        name\n    ]);\n    const onChange = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((event)=>_registerProps.current.onChange({\n            target: {\n                value: getEventValue(event),\n                name: name\n            },\n            type: EVENTS.CHANGE\n        }), [\n        name\n    ]);\n    const onBlur = react__WEBPACK_IMPORTED_MODULE_0__.useCallback(()=>_registerProps.current.onBlur({\n            target: {\n                value: get(control._formValues, name),\n                name: name\n            },\n            type: EVENTS.BLUR\n        }), [\n        name,\n        control._formValues\n    ]);\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((elm)=>{\n        const field = get(control._fields, name);\n        if (field && elm) {\n            field._f.ref = {\n                focus: ()=>elm.focus && elm.focus(),\n                select: ()=>elm.select && elm.select(),\n                setCustomValidity: (message)=>elm.setCustomValidity(message),\n                reportValidity: ()=>elm.reportValidity()\n            };\n        }\n    }, [\n        control._fields,\n        name\n    ]);\n    const field = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            name,\n            value: value1,\n            ...isBoolean(disabled) || formState.disabled ? {\n                disabled: formState.disabled || disabled\n            } : {},\n            onChange,\n            onBlur,\n            ref\n        }), [\n        name,\n        disabled,\n        formState.disabled,\n        onChange,\n        onBlur,\n        ref,\n        value1\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        const _shouldUnregisterField = control._options.shouldUnregister || shouldUnregister;\n        control.register(name, {\n            ..._props.current.rules,\n            ...isBoolean(_props.current.disabled) ? {\n                disabled: _props.current.disabled\n            } : {}\n        });\n        const updateMounted = (name, value1)=>{\n            const field = get(control._fields, name);\n            if (field && field._f) {\n                field._f.mount = value1;\n            }\n        };\n        updateMounted(name, true);\n        if (_shouldUnregisterField) {\n            const value1 = cloneObject(get(control._options.defaultValues, name));\n            set(control._defaultValues, name, value1);\n            if (isUndefined(get(control._formValues, name))) {\n                set(control._formValues, name, value1);\n            }\n        }\n        !isArrayField && control.register(name);\n        return ()=>{\n            (isArrayField ? _shouldUnregisterField && !control._state.action : _shouldUnregisterField) ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        isArrayField,\n        shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._setDisabledField({\n            disabled,\n            name\n        });\n    }, [\n        disabled,\n        name,\n        control\n    ]);\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            field,\n            formState,\n            fieldState\n        }), [\n        field,\n        formState,\n        fieldState\n    ]);\n}\n_s3(useController, \"BwqOiZYbRPscn0PnWj6ztIweXcg=\", false, function() {\n    return [\n        useFormContext,\n        useWatch,\n        useFormState\n    ];\n});\n/**\n * Component based on `useController` hook to work with controlled component.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usecontroller/controller) • [Demo](https://codesandbox.io/s/react-hook-form-v6-controller-ts-jwyzw) • [Video](https://www.youtube.com/watch?v=N2UNk_UCVyA)\n *\n * @param props - the path name to the form field value, and validation rules.\n *\n * @returns provide field handler functions, field and form state.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control } = useForm<FormValues>({\n *     defaultValues: {\n *       test: \"\"\n *     }\n *   });\n *\n *   return (\n *     <form>\n *       <Controller\n *         control={control}\n *         name=\"test\"\n *         render={({ field: { onChange, onBlur, value, ref }, formState, fieldState }) => (\n *           <>\n *             <input\n *               onChange={onChange} // send value to hook form\n *               onBlur={onBlur} // notify when input is touched\n *               value={value} // return updated value\n *               ref={ref} // set ref for focus management\n *             />\n *             <p>{formState.isSubmitted ? \"submitted\" : \"\"}</p>\n *             <p>{fieldState.isTouched ? \"touched\" : \"\"}</p>\n *           </>\n *         )}\n *       />\n *     </form>\n *   );\n * }\n * ```\n */ const Controller = (props)=>{\n    _s4();\n    return props.render(useController(props));\n};\n_s4(Controller, \"pXd7c3xsSzTx4CXFSEpr4afsILI=\", false, function() {\n    return [\n        useController\n    ];\n});\n_c1 = Controller;\nconst flatten = (obj)=>{\n    const output = {};\n    for (const key of Object.keys(obj)){\n        if (isObjectType(obj[key]) && obj[key] !== null) {\n            const nested = flatten(obj[key]);\n            for (const nestedKey of Object.keys(nested)){\n                output[\"\".concat(key, \".\").concat(nestedKey)] = nested[nestedKey];\n            }\n        } else {\n            output[key] = obj[key];\n        }\n    }\n    return output;\n};\nconst POST_REQUEST = \"post\";\n/**\n * Form component to manage submission.\n *\n * @param props - to setup submission detail. {@link FormProps}\n *\n * @returns form component or headless render prop.\n *\n * @example\n * ```tsx\n * function App() {\n *   const { control, formState: { errors } } = useForm();\n *\n *   return (\n *     <Form action=\"/api\" control={control}>\n *       <input {...register(\"name\")} />\n *       <p>{errors?.root?.server && 'Server error'}</p>\n *       <button>Submit</button>\n *     </Form>\n *   );\n * }\n * ```\n */ function Form(props) {\n    _s5();\n    const methods = useFormContext();\n    const [mounted, setMounted] = react__WEBPACK_IMPORTED_MODULE_0__.useState(false);\n    const { control = methods.control, onSubmit, children, action, method = POST_REQUEST, headers, encType, onError, render, onSuccess, validateStatus, ...rest } = props;\n    const submit = async (event)=>{\n        let hasError = false;\n        let type = \"\";\n        await control.handleSubmit(async (data)=>{\n            const formData = new FormData();\n            let formDataJson = \"\";\n            try {\n                formDataJson = JSON.stringify(data);\n            } catch (_a) {}\n            const flattenFormValues = flatten(control._formValues);\n            for(const key in flattenFormValues){\n                formData.append(key, flattenFormValues[key]);\n            }\n            if (onSubmit) {\n                await onSubmit({\n                    data,\n                    event,\n                    method,\n                    formData,\n                    formDataJson\n                });\n            }\n            if (action) {\n                try {\n                    const shouldStringifySubmissionData = [\n                        headers && headers[\"Content-Type\"],\n                        encType\n                    ].some((value1)=>value1 && value1.includes(\"json\"));\n                    const response = await fetch(String(action), {\n                        method,\n                        headers: {\n                            ...headers,\n                            ...encType ? {\n                                \"Content-Type\": encType\n                            } : {}\n                        },\n                        body: shouldStringifySubmissionData ? formDataJson : formData\n                    });\n                    if (response && (validateStatus ? !validateStatus(response.status) : response.status < 200 || response.status >= 300)) {\n                        hasError = true;\n                        onError && onError({\n                            response\n                        });\n                        type = String(response.status);\n                    } else {\n                        onSuccess && onSuccess({\n                            response\n                        });\n                    }\n                } catch (error) {\n                    hasError = true;\n                    onError && onError({\n                        error\n                    });\n                }\n            }\n        })(event);\n        if (hasError && props.control) {\n            props.control._subjects.state.next({\n                isSubmitSuccessful: false\n            });\n            props.control.setError(\"root.server\", {\n                type\n            });\n        }\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        setMounted(true);\n    }, []);\n    return render ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, render({\n        submit\n    })) : /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"form\", {\n        noValidate: mounted,\n        action: action,\n        method: method,\n        encType: encType,\n        onSubmit: submit,\n        ...rest\n    }, children);\n}\n_s5(Form, \"l5XX9HH+oeW+AlfkmhWvgtRMT0s=\", false, function() {\n    return [\n        useFormContext\n    ];\n});\n_c2 = Form;\nvar appendErrors = (name, validateAllFieldCriteria, errors, type, message)=>validateAllFieldCriteria ? {\n        ...errors[name],\n        types: {\n            ...errors[name] && errors[name].types ? errors[name].types : {},\n            [type]: message || true\n        }\n    } : {};\nvar convertToArrayPayload = (value1)=>Array.isArray(value1) ? value1 : [\n        value1\n    ];\nvar createSubject = ()=>{\n    let _observers = [];\n    const next = (value1)=>{\n        for (const observer of _observers){\n            observer.next && observer.next(value1);\n        }\n    };\n    const subscribe = (observer)=>{\n        _observers.push(observer);\n        return {\n            unsubscribe: ()=>{\n                _observers = _observers.filter((o)=>o !== observer);\n            }\n        };\n    };\n    const unsubscribe = ()=>{\n        _observers = [];\n    };\n    return {\n        get observers () {\n            return _observers;\n        },\n        next,\n        subscribe,\n        unsubscribe\n    };\n};\nvar isPrimitive = (value1)=>isNullOrUndefined(value1) || !isObjectType(value1);\nfunction deepEqual(object1, object2) {\n    if (isPrimitive(object1) || isPrimitive(object2)) {\n        return object1 === object2;\n    }\n    if (isDateObject(object1) && isDateObject(object2)) {\n        return object1.getTime() === object2.getTime();\n    }\n    const keys1 = Object.keys(object1);\n    const keys2 = Object.keys(object2);\n    if (keys1.length !== keys2.length) {\n        return false;\n    }\n    for (const key of keys1){\n        const val1 = object1[key];\n        if (!keys2.includes(key)) {\n            return false;\n        }\n        if (key !== \"ref\") {\n            const val2 = object2[key];\n            if (isDateObject(val1) && isDateObject(val2) || isObject(val1) && isObject(val2) || Array.isArray(val1) && Array.isArray(val2) ? !deepEqual(val1, val2) : val1 !== val2) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\nvar isEmptyObject = (value1)=>isObject(value1) && !Object.keys(value1).length;\nvar isFileInput = (element)=>element.type === \"file\";\nvar isFunction = (value1)=>typeof value1 === \"function\";\nvar isHTMLElement = (value1)=>{\n    if (!isWeb) {\n        return false;\n    }\n    const owner = value1 ? value1.ownerDocument : 0;\n    return value1 instanceof (owner && owner.defaultView ? owner.defaultView.HTMLElement : HTMLElement);\n};\nvar isMultipleSelect = (element)=>element.type === \"select-multiple\";\nvar isRadioInput = (element)=>element.type === \"radio\";\nvar isRadioOrCheckbox = (ref)=>isRadioInput(ref) || isCheckBoxInput(ref);\nvar live = (ref)=>isHTMLElement(ref) && ref.isConnected;\nfunction baseGet(object, updatePath) {\n    const length = updatePath.slice(0, -1).length;\n    let index = 0;\n    while(index < length){\n        object = isUndefined(object) ? index++ : object[updatePath[index++]];\n    }\n    return object;\n}\nfunction isEmptyArray(obj) {\n    for(const key in obj){\n        if (obj.hasOwnProperty(key) && !isUndefined(obj[key])) {\n            return false;\n        }\n    }\n    return true;\n}\nfunction unset(object, path) {\n    const paths = Array.isArray(path) ? path : isKey(path) ? [\n        path\n    ] : stringToPath(path);\n    const childObject = paths.length === 1 ? object : baseGet(object, paths);\n    const index = paths.length - 1;\n    const key = paths[index];\n    if (childObject) {\n        delete childObject[key];\n    }\n    if (index !== 0 && (isObject(childObject) && isEmptyObject(childObject) || Array.isArray(childObject) && isEmptyArray(childObject))) {\n        unset(object, paths.slice(0, -1));\n    }\n    return object;\n}\nvar objectHasFunction = (data)=>{\n    for(const key in data){\n        if (isFunction(data[key])) {\n            return true;\n        }\n    }\n    return false;\n};\nfunction markFieldsDirty(data) {\n    let fields = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                fields[key] = Array.isArray(data[key]) ? [] : {};\n                markFieldsDirty(data[key], fields[key]);\n            } else if (!isNullOrUndefined(data[key])) {\n                fields[key] = true;\n            }\n        }\n    }\n    return fields;\n}\nfunction getDirtyFieldsFromDefaultValues(data, formValues, dirtyFieldsFromValues) {\n    const isParentNodeArray = Array.isArray(data);\n    if (isObject(data) || isParentNodeArray) {\n        for(const key in data){\n            if (Array.isArray(data[key]) || isObject(data[key]) && !objectHasFunction(data[key])) {\n                if (isUndefined(formValues) || isPrimitive(dirtyFieldsFromValues[key])) {\n                    dirtyFieldsFromValues[key] = Array.isArray(data[key]) ? markFieldsDirty(data[key], []) : {\n                        ...markFieldsDirty(data[key])\n                    };\n                } else {\n                    getDirtyFieldsFromDefaultValues(data[key], isNullOrUndefined(formValues) ? {} : formValues[key], dirtyFieldsFromValues[key]);\n                }\n            } else {\n                dirtyFieldsFromValues[key] = !deepEqual(data[key], formValues[key]);\n            }\n        }\n    }\n    return dirtyFieldsFromValues;\n}\nvar getDirtyFields = (defaultValues, formValues)=>getDirtyFieldsFromDefaultValues(defaultValues, formValues, markFieldsDirty(formValues));\nconst defaultResult = {\n    value: false,\n    isValid: false\n};\nconst validResult = {\n    value: true,\n    isValid: true\n};\nvar getCheckboxValue = (options)=>{\n    if (Array.isArray(options)) {\n        if (options.length > 1) {\n            const values = options.filter((option)=>option && option.checked && !option.disabled).map((option)=>option.value);\n            return {\n                value: values,\n                isValid: !!values.length\n            };\n        }\n        return options[0].checked && !options[0].disabled ? options[0].attributes && !isUndefined(options[0].attributes.value) ? isUndefined(options[0].value) || options[0].value === \"\" ? validResult : {\n            value: options[0].value,\n            isValid: true\n        } : validResult : defaultResult;\n    }\n    return defaultResult;\n};\nvar getFieldValueAs = (value1, param)=>{\n    let { valueAsNumber, valueAsDate, setValueAs } = param;\n    return isUndefined(value1) ? value1 : valueAsNumber ? value1 === \"\" ? NaN : value1 ? +value1 : value1 : valueAsDate && isString(value1) ? new Date(value1) : setValueAs ? setValueAs(value1) : value1;\n};\nconst defaultReturn = {\n    isValid: false,\n    value: null\n};\nvar getRadioValue = (options)=>Array.isArray(options) ? options.reduce((previous, option)=>option && option.checked && !option.disabled ? {\n            isValid: true,\n            value: option.value\n        } : previous, defaultReturn) : defaultReturn;\nfunction getFieldValue(_f) {\n    const ref = _f.ref;\n    if (isFileInput(ref)) {\n        return ref.files;\n    }\n    if (isRadioInput(ref)) {\n        return getRadioValue(_f.refs).value;\n    }\n    if (isMultipleSelect(ref)) {\n        return [\n            ...ref.selectedOptions\n        ].map((param)=>{\n            let { value: value1 } = param;\n            return value1;\n        });\n    }\n    if (isCheckBoxInput(ref)) {\n        return getCheckboxValue(_f.refs).value;\n    }\n    return getFieldValueAs(isUndefined(ref.value) ? _f.ref.value : ref.value, _f);\n}\nvar getResolverOptions = (fieldsNames, _fields, criteriaMode, shouldUseNativeValidation)=>{\n    const fields = {};\n    for (const name of fieldsNames){\n        const field = get(_fields, name);\n        field && set(fields, name, field._f);\n    }\n    return {\n        criteriaMode,\n        names: [\n            ...fieldsNames\n        ],\n        fields,\n        shouldUseNativeValidation\n    };\n};\nvar isRegex = (value1)=>value1 instanceof RegExp;\nvar getRuleValue = (rule)=>isUndefined(rule) ? rule : isRegex(rule) ? rule.source : isObject(rule) ? isRegex(rule.value) ? rule.value.source : rule.value : rule;\nvar getValidationModes = (mode)=>({\n        isOnSubmit: !mode || mode === VALIDATION_MODE.onSubmit,\n        isOnBlur: mode === VALIDATION_MODE.onBlur,\n        isOnChange: mode === VALIDATION_MODE.onChange,\n        isOnAll: mode === VALIDATION_MODE.all,\n        isOnTouch: mode === VALIDATION_MODE.onTouched\n    });\nconst ASYNC_FUNCTION = \"AsyncFunction\";\nvar hasPromiseValidation = (fieldReference)=>!!fieldReference && !!fieldReference.validate && !!(isFunction(fieldReference.validate) && fieldReference.validate.constructor.name === ASYNC_FUNCTION || isObject(fieldReference.validate) && Object.values(fieldReference.validate).find((validateFunction)=>validateFunction.constructor.name === ASYNC_FUNCTION));\nvar hasValidation = (options)=>options.mount && (options.required || options.min || options.max || options.maxLength || options.minLength || options.pattern || options.validate);\nvar isWatched = (name, _names, isBlurEvent)=>!isBlurEvent && (_names.watchAll || _names.watch.has(name) || [\n        ..._names.watch\n    ].some((watchName)=>name.startsWith(watchName) && /^\\.\\w+/.test(name.slice(watchName.length))));\nconst iterateFieldsByAction = (fields, action, fieldsNames, abortEarly)=>{\n    for (const key of fieldsNames || Object.keys(fields)){\n        const field = get(fields, key);\n        if (field) {\n            const { _f, ...currentField } = field;\n            if (_f) {\n                if (_f.refs && _f.refs[0] && action(_f.refs[0], key) && !abortEarly) {\n                    return true;\n                } else if (_f.ref && action(_f.ref, _f.name) && !abortEarly) {\n                    return true;\n                } else {\n                    if (iterateFieldsByAction(currentField, action)) {\n                        break;\n                    }\n                }\n            } else if (isObject(currentField)) {\n                if (iterateFieldsByAction(currentField, action)) {\n                    break;\n                }\n            }\n        }\n    }\n    return;\n};\nfunction schemaErrorLookup(errors, _fields, name) {\n    const error = get(errors, name);\n    if (error || isKey(name)) {\n        return {\n            error,\n            name\n        };\n    }\n    const names = name.split(\".\");\n    while(names.length){\n        const fieldName = names.join(\".\");\n        const field = get(_fields, fieldName);\n        const foundError = get(errors, fieldName);\n        if (field && !Array.isArray(field) && name !== fieldName) {\n            return {\n                name\n            };\n        }\n        if (foundError && foundError.type) {\n            return {\n                name: fieldName,\n                error: foundError\n            };\n        }\n        if (foundError && foundError.root && foundError.root.type) {\n            return {\n                name: \"\".concat(fieldName, \".root\"),\n                error: foundError.root\n            };\n        }\n        names.pop();\n    }\n    return {\n        name\n    };\n}\nvar shouldRenderFormState = (formStateData, _proxyFormState, updateFormState, isRoot)=>{\n    updateFormState(formStateData);\n    const { name, ...formState } = formStateData;\n    return isEmptyObject(formState) || Object.keys(formState).length >= Object.keys(_proxyFormState).length || Object.keys(formState).find((key)=>_proxyFormState[key] === (!isRoot || VALIDATION_MODE.all));\n};\nvar shouldSubscribeByName = (name, signalName, exact)=>!name || !signalName || name === signalName || convertToArrayPayload(name).some((currentName)=>currentName && (exact ? currentName === signalName : currentName.startsWith(signalName) || signalName.startsWith(currentName)));\nvar skipValidation = (isBlurEvent, isTouched, isSubmitted, reValidateMode, mode)=>{\n    if (mode.isOnAll) {\n        return false;\n    } else if (!isSubmitted && mode.isOnTouch) {\n        return !(isTouched || isBlurEvent);\n    } else if (isSubmitted ? reValidateMode.isOnBlur : mode.isOnBlur) {\n        return !isBlurEvent;\n    } else if (isSubmitted ? reValidateMode.isOnChange : mode.isOnChange) {\n        return isBlurEvent;\n    }\n    return true;\n};\nvar unsetEmptyArray = (ref, name)=>!compact(get(ref, name)).length && unset(ref, name);\nvar updateFieldArrayRootError = (errors, error, name)=>{\n    const fieldArrayErrors = convertToArrayPayload(get(errors, name));\n    set(fieldArrayErrors, \"root\", error[name]);\n    set(errors, name, fieldArrayErrors);\n    return errors;\n};\nvar isMessage = (value1)=>isString(value1);\nfunction getValidateError(result, ref) {\n    let type = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : \"validate\";\n    if (isMessage(result) || Array.isArray(result) && result.every(isMessage) || isBoolean(result) && !result) {\n        return {\n            type,\n            message: isMessage(result) ? result : \"\",\n            ref\n        };\n    }\n}\nvar getValueAndMessage = (validationData)=>isObject(validationData) && !isRegex(validationData) ? validationData : {\n        value: validationData,\n        message: \"\"\n    };\nvar validateField = async (field, disabledFieldNames, formValues, validateAllFieldCriteria, shouldUseNativeValidation, isFieldArray)=>{\n    const { ref, refs, required, maxLength, minLength, min, max, pattern, validate, name, valueAsNumber, mount } = field._f;\n    const inputValue = get(formValues, name);\n    if (!mount || disabledFieldNames.has(name)) {\n        return {};\n    }\n    const inputRef = refs ? refs[0] : ref;\n    const setCustomValidity = (message)=>{\n        if (shouldUseNativeValidation && inputRef.reportValidity) {\n            inputRef.setCustomValidity(isBoolean(message) ? \"\" : message || \"\");\n            inputRef.reportValidity();\n        }\n    };\n    const error = {};\n    const isRadio = isRadioInput(ref);\n    const isCheckBox = isCheckBoxInput(ref);\n    const isRadioOrCheckbox = isRadio || isCheckBox;\n    const isEmpty = (valueAsNumber || isFileInput(ref)) && isUndefined(ref.value) && isUndefined(inputValue) || isHTMLElement(ref) && ref.value === \"\" || inputValue === \"\" || Array.isArray(inputValue) && !inputValue.length;\n    const appendErrorsCurry = appendErrors.bind(null, name, validateAllFieldCriteria, error);\n    const getMinMaxMessage = function(exceedMax, maxLengthMessage, minLengthMessage) {\n        let maxType = arguments.length > 3 && arguments[3] !== void 0 ? arguments[3] : INPUT_VALIDATION_RULES.maxLength, minType = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : INPUT_VALIDATION_RULES.minLength;\n        const message = exceedMax ? maxLengthMessage : minLengthMessage;\n        error[name] = {\n            type: exceedMax ? maxType : minType,\n            message,\n            ref,\n            ...appendErrorsCurry(exceedMax ? maxType : minType, message)\n        };\n    };\n    if (isFieldArray ? !Array.isArray(inputValue) || !inputValue.length : required && (!isRadioOrCheckbox && (isEmpty || isNullOrUndefined(inputValue)) || isBoolean(inputValue) && !inputValue || isCheckBox && !getCheckboxValue(refs).isValid || isRadio && !getRadioValue(refs).isValid)) {\n        const { value: value1, message } = isMessage(required) ? {\n            value: !!required,\n            message: required\n        } : getValueAndMessage(required);\n        if (value1) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.required,\n                message,\n                ref: inputRef,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.required, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (!isEmpty && (!isNullOrUndefined(min) || !isNullOrUndefined(max))) {\n        let exceedMax;\n        let exceedMin;\n        const maxOutput = getValueAndMessage(max);\n        const minOutput = getValueAndMessage(min);\n        if (!isNullOrUndefined(inputValue) && !isNaN(inputValue)) {\n            const valueNumber = ref.valueAsNumber || (inputValue ? +inputValue : inputValue);\n            if (!isNullOrUndefined(maxOutput.value)) {\n                exceedMax = valueNumber > maxOutput.value;\n            }\n            if (!isNullOrUndefined(minOutput.value)) {\n                exceedMin = valueNumber < minOutput.value;\n            }\n        } else {\n            const valueDate = ref.valueAsDate || new Date(inputValue);\n            const convertTimeToDate = (time)=>new Date(new Date().toDateString() + \" \" + time);\n            const isTime = ref.type == \"time\";\n            const isWeek = ref.type == \"week\";\n            if (isString(maxOutput.value) && inputValue) {\n                exceedMax = isTime ? convertTimeToDate(inputValue) > convertTimeToDate(maxOutput.value) : isWeek ? inputValue > maxOutput.value : valueDate > new Date(maxOutput.value);\n            }\n            if (isString(minOutput.value) && inputValue) {\n                exceedMin = isTime ? convertTimeToDate(inputValue) < convertTimeToDate(minOutput.value) : isWeek ? inputValue < minOutput.value : valueDate < new Date(minOutput.value);\n            }\n        }\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(!!exceedMax, maxOutput.message, minOutput.message, INPUT_VALIDATION_RULES.max, INPUT_VALIDATION_RULES.min);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if ((maxLength || minLength) && !isEmpty && (isString(inputValue) || isFieldArray && Array.isArray(inputValue))) {\n        const maxLengthOutput = getValueAndMessage(maxLength);\n        const minLengthOutput = getValueAndMessage(minLength);\n        const exceedMax = !isNullOrUndefined(maxLengthOutput.value) && inputValue.length > +maxLengthOutput.value;\n        const exceedMin = !isNullOrUndefined(minLengthOutput.value) && inputValue.length < +minLengthOutput.value;\n        if (exceedMax || exceedMin) {\n            getMinMaxMessage(exceedMax, maxLengthOutput.message, minLengthOutput.message);\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(error[name].message);\n                return error;\n            }\n        }\n    }\n    if (pattern && !isEmpty && isString(inputValue)) {\n        const { value: patternValue, message } = getValueAndMessage(pattern);\n        if (isRegex(patternValue) && !inputValue.match(patternValue)) {\n            error[name] = {\n                type: INPUT_VALIDATION_RULES.pattern,\n                message,\n                ref,\n                ...appendErrorsCurry(INPUT_VALIDATION_RULES.pattern, message)\n            };\n            if (!validateAllFieldCriteria) {\n                setCustomValidity(message);\n                return error;\n            }\n        }\n    }\n    if (validate) {\n        if (isFunction(validate)) {\n            const result = await validate(inputValue, formValues);\n            const validateError = getValidateError(result, inputRef);\n            if (validateError) {\n                error[name] = {\n                    ...validateError,\n                    ...appendErrorsCurry(INPUT_VALIDATION_RULES.validate, validateError.message)\n                };\n                if (!validateAllFieldCriteria) {\n                    setCustomValidity(validateError.message);\n                    return error;\n                }\n            }\n        } else if (isObject(validate)) {\n            let validationResult = {};\n            for(const key in validate){\n                if (!isEmptyObject(validationResult) && !validateAllFieldCriteria) {\n                    break;\n                }\n                const validateError = getValidateError(await validate[key](inputValue, formValues), inputRef, key);\n                if (validateError) {\n                    validationResult = {\n                        ...validateError,\n                        ...appendErrorsCurry(key, validateError.message)\n                    };\n                    setCustomValidity(validateError.message);\n                    if (validateAllFieldCriteria) {\n                        error[name] = validationResult;\n                    }\n                }\n            }\n            if (!isEmptyObject(validationResult)) {\n                error[name] = {\n                    ref: inputRef,\n                    ...validationResult\n                };\n                if (!validateAllFieldCriteria) {\n                    return error;\n                }\n            }\n        }\n    }\n    setCustomValidity(true);\n    return error;\n};\nconst defaultOptions = {\n    mode: VALIDATION_MODE.onSubmit,\n    reValidateMode: VALIDATION_MODE.onChange,\n    shouldFocusError: true\n};\nfunction createFormControl() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    let _options = {\n        ...defaultOptions,\n        ...props\n    };\n    let _formState = {\n        submitCount: 0,\n        isDirty: false,\n        isReady: false,\n        isLoading: isFunction(_options.defaultValues),\n        isValidating: false,\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        touchedFields: {},\n        dirtyFields: {},\n        validatingFields: {},\n        errors: _options.errors || {},\n        disabled: _options.disabled || false\n    };\n    const _fields = {};\n    let _defaultValues = isObject(_options.defaultValues) || isObject(_options.values) ? cloneObject(_options.defaultValues || _options.values) || {} : {};\n    let _formValues = _options.shouldUnregister ? {} : cloneObject(_defaultValues);\n    let _state = {\n        action: false,\n        mount: false,\n        watch: false\n    };\n    let _names = {\n        mount: new Set(),\n        disabled: new Set(),\n        unMount: new Set(),\n        array: new Set(),\n        watch: new Set()\n    };\n    let delayErrorCallback;\n    let timer = 0;\n    const _proxyFormState = {\n        isDirty: false,\n        dirtyFields: false,\n        validatingFields: false,\n        touchedFields: false,\n        isValidating: false,\n        isValid: false,\n        errors: false\n    };\n    let _proxySubscribeFormState = {\n        ..._proxyFormState\n    };\n    const _subjects = {\n        array: createSubject(),\n        state: createSubject()\n    };\n    const shouldDisplayAllAssociatedErrors = _options.criteriaMode === VALIDATION_MODE.all;\n    const debounce = (callback)=>(wait)=>{\n            clearTimeout(timer);\n            timer = setTimeout(callback, wait);\n        };\n    const _setValid = async (shouldUpdateValid)=>{\n        if (!_options.disabled && (_proxyFormState.isValid || _proxySubscribeFormState.isValid || shouldUpdateValid)) {\n            const isValid = _options.resolver ? isEmptyObject((await _runSchema()).errors) : await executeBuiltInValidation(_fields, true);\n            if (isValid !== _formState.isValid) {\n                _subjects.state.next({\n                    isValid\n                });\n            }\n        }\n    };\n    const _updateIsValidating = (names, isValidating)=>{\n        if (!_options.disabled && (_proxyFormState.isValidating || _proxyFormState.validatingFields || _proxySubscribeFormState.isValidating || _proxySubscribeFormState.validatingFields)) {\n            (names || Array.from(_names.mount)).forEach((name)=>{\n                if (name) {\n                    isValidating ? set(_formState.validatingFields, name, isValidating) : unset(_formState.validatingFields, name);\n                }\n            });\n            _subjects.state.next({\n                validatingFields: _formState.validatingFields,\n                isValidating: !isEmptyObject(_formState.validatingFields)\n            });\n        }\n    };\n    const _setFieldArray = function(name) {\n        let values = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : [], method = arguments.length > 2 ? arguments[2] : void 0, args = arguments.length > 3 ? arguments[3] : void 0, shouldSetValues = arguments.length > 4 && arguments[4] !== void 0 ? arguments[4] : true, shouldUpdateFieldsAndState = arguments.length > 5 && arguments[5] !== void 0 ? arguments[5] : true;\n        if (args && method && !_options.disabled) {\n            _state.action = true;\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_fields, name))) {\n                const fieldValues = method(get(_fields, name), args.argA, args.argB);\n                shouldSetValues && set(_fields, name, fieldValues);\n            }\n            if (shouldUpdateFieldsAndState && Array.isArray(get(_formState.errors, name))) {\n                const errors = method(get(_formState.errors, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.errors, name, errors);\n                unsetEmptyArray(_formState.errors, name);\n            }\n            if ((_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && shouldUpdateFieldsAndState && Array.isArray(get(_formState.touchedFields, name))) {\n                const touchedFields = method(get(_formState.touchedFields, name), args.argA, args.argB);\n                shouldSetValues && set(_formState.touchedFields, name, touchedFields);\n            }\n            if (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) {\n                _formState.dirtyFields = getDirtyFields(_defaultValues, _formValues);\n            }\n            _subjects.state.next({\n                name,\n                isDirty: _getDirty(name, values),\n                dirtyFields: _formState.dirtyFields,\n                errors: _formState.errors,\n                isValid: _formState.isValid\n            });\n        } else {\n            set(_formValues, name, values);\n        }\n    };\n    const updateErrors = (name, error)=>{\n        set(_formState.errors, name, error);\n        _subjects.state.next({\n            errors: _formState.errors\n        });\n    };\n    const _setErrors = (errors)=>{\n        _formState.errors = errors;\n        _subjects.state.next({\n            errors: _formState.errors,\n            isValid: false\n        });\n    };\n    const updateValidAndValue = (name, shouldSkipSetValueAs, value1, ref)=>{\n        const field = get(_fields, name);\n        if (field) {\n            const defaultValue = get(_formValues, name, isUndefined(value1) ? get(_defaultValues, name) : value1);\n            isUndefined(defaultValue) || ref && ref.defaultChecked || shouldSkipSetValueAs ? set(_formValues, name, shouldSkipSetValueAs ? defaultValue : getFieldValue(field._f)) : setFieldValue(name, defaultValue);\n            _state.mount && _setValid();\n        }\n    };\n    const updateTouchAndDirty = (name, fieldValue, isBlurEvent, shouldDirty, shouldRender)=>{\n        let shouldUpdateField = false;\n        let isPreviousDirty = false;\n        const output = {\n            name\n        };\n        if (!_options.disabled) {\n            if (!isBlurEvent || shouldDirty) {\n                if (_proxyFormState.isDirty || _proxySubscribeFormState.isDirty) {\n                    isPreviousDirty = _formState.isDirty;\n                    _formState.isDirty = output.isDirty = _getDirty();\n                    shouldUpdateField = isPreviousDirty !== output.isDirty;\n                }\n                const isCurrentFieldPristine = deepEqual(get(_defaultValues, name), fieldValue);\n                isPreviousDirty = !!get(_formState.dirtyFields, name);\n                isCurrentFieldPristine ? unset(_formState.dirtyFields, name) : set(_formState.dirtyFields, name, true);\n                output.dirtyFields = _formState.dirtyFields;\n                shouldUpdateField = shouldUpdateField || (_proxyFormState.dirtyFields || _proxySubscribeFormState.dirtyFields) && isPreviousDirty !== !isCurrentFieldPristine;\n            }\n            if (isBlurEvent) {\n                const isPreviousFieldTouched = get(_formState.touchedFields, name);\n                if (!isPreviousFieldTouched) {\n                    set(_formState.touchedFields, name, isBlurEvent);\n                    output.touchedFields = _formState.touchedFields;\n                    shouldUpdateField = shouldUpdateField || (_proxyFormState.touchedFields || _proxySubscribeFormState.touchedFields) && isPreviousFieldTouched !== isBlurEvent;\n                }\n            }\n            shouldUpdateField && shouldRender && _subjects.state.next(output);\n        }\n        return shouldUpdateField ? output : {};\n    };\n    const shouldRenderByError = (name, isValid, error, fieldState)=>{\n        const previousFieldError = get(_formState.errors, name);\n        const shouldUpdateValid = (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isBoolean(isValid) && _formState.isValid !== isValid;\n        if (_options.delayError && error) {\n            delayErrorCallback = debounce(()=>updateErrors(name, error));\n            delayErrorCallback(_options.delayError);\n        } else {\n            clearTimeout(timer);\n            delayErrorCallback = null;\n            error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n        }\n        if ((error ? !deepEqual(previousFieldError, error) : previousFieldError) || !isEmptyObject(fieldState) || shouldUpdateValid) {\n            const updatedFormState = {\n                ...fieldState,\n                ...shouldUpdateValid && isBoolean(isValid) ? {\n                    isValid\n                } : {},\n                errors: _formState.errors,\n                name\n            };\n            _formState = {\n                ..._formState,\n                ...updatedFormState\n            };\n            _subjects.state.next(updatedFormState);\n        }\n    };\n    const _runSchema = async (name)=>{\n        _updateIsValidating(name, true);\n        const result = await _options.resolver(_formValues, _options.context, getResolverOptions(name || _names.mount, _fields, _options.criteriaMode, _options.shouldUseNativeValidation));\n        _updateIsValidating(name);\n        return result;\n    };\n    const executeSchemaAndUpdateState = async (names)=>{\n        const { errors } = await _runSchema(names);\n        if (names) {\n            for (const name of names){\n                const error = get(errors, name);\n                error ? set(_formState.errors, name, error) : unset(_formState.errors, name);\n            }\n        } else {\n            _formState.errors = errors;\n        }\n        return errors;\n    };\n    const executeBuiltInValidation = async function(fields, shouldOnlyCheckValid) {\n        let context = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {\n            valid: true\n        };\n        for(const name in fields){\n            const field = fields[name];\n            if (field) {\n                const { _f, ...fieldValue } = field;\n                if (_f) {\n                    const isFieldArrayRoot = _names.array.has(_f.name);\n                    const isPromiseFunction = field._f && hasPromiseValidation(field._f);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            name\n                        ], true);\n                    }\n                    const fieldError = await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation && !shouldOnlyCheckValid, isFieldArrayRoot);\n                    if (isPromiseFunction && _proxyFormState.validatingFields) {\n                        _updateIsValidating([\n                            name\n                        ]);\n                    }\n                    if (fieldError[_f.name]) {\n                        context.valid = false;\n                        if (shouldOnlyCheckValid) {\n                            break;\n                        }\n                    }\n                    !shouldOnlyCheckValid && (get(fieldError, _f.name) ? isFieldArrayRoot ? updateFieldArrayRootError(_formState.errors, fieldError, _f.name) : set(_formState.errors, _f.name, fieldError[_f.name]) : unset(_formState.errors, _f.name));\n                }\n                !isEmptyObject(fieldValue) && await executeBuiltInValidation(fieldValue, shouldOnlyCheckValid, context);\n            }\n        }\n        return context.valid;\n    };\n    const _removeUnmounted = ()=>{\n        for (const name of _names.unMount){\n            const field = get(_fields, name);\n            field && (field._f.refs ? field._f.refs.every((ref)=>!live(ref)) : !live(field._f.ref)) && unregister(name);\n        }\n        _names.unMount = new Set();\n    };\n    const _getDirty = (name, data)=>!_options.disabled && (name && data && set(_formValues, name, data), !deepEqual(getValues(), _defaultValues));\n    const _getWatch = (names, defaultValue, isGlobal)=>generateWatchOutput(names, _names, {\n            ..._state.mount ? _formValues : isUndefined(defaultValue) ? _defaultValues : isString(names) ? {\n                [names]: defaultValue\n            } : defaultValue\n        }, isGlobal, defaultValue);\n    const _getFieldArray = (name)=>compact(get(_state.mount ? _formValues : _defaultValues, name, _options.shouldUnregister ? get(_defaultValues, name, []) : []));\n    const setFieldValue = function(name, value1) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const field = get(_fields, name);\n        let fieldValue = value1;\n        if (field) {\n            const fieldReference = field._f;\n            if (fieldReference) {\n                !fieldReference.disabled && set(_formValues, name, getFieldValueAs(value1, fieldReference));\n                fieldValue = isHTMLElement(fieldReference.ref) && isNullOrUndefined(value1) ? \"\" : value1;\n                if (isMultipleSelect(fieldReference.ref)) {\n                    [\n                        ...fieldReference.ref.options\n                    ].forEach((optionRef)=>optionRef.selected = fieldValue.includes(optionRef.value));\n                } else if (fieldReference.refs) {\n                    if (isCheckBoxInput(fieldReference.ref)) {\n                        fieldReference.refs.forEach((checkboxRef)=>{\n                            if (!checkboxRef.defaultChecked || !checkboxRef.disabled) {\n                                if (Array.isArray(fieldValue)) {\n                                    checkboxRef.checked = !!fieldValue.find((data)=>data === checkboxRef.value);\n                                } else {\n                                    checkboxRef.checked = fieldValue === checkboxRef.value || !!fieldValue;\n                                }\n                            }\n                        });\n                    } else {\n                        fieldReference.refs.forEach((radioRef)=>radioRef.checked = radioRef.value === fieldValue);\n                    }\n                } else if (isFileInput(fieldReference.ref)) {\n                    fieldReference.ref.value = \"\";\n                } else {\n                    fieldReference.ref.value = fieldValue;\n                    if (!fieldReference.ref.type) {\n                        _subjects.state.next({\n                            name,\n                            values: cloneObject(_formValues)\n                        });\n                    }\n                }\n            }\n        }\n        (options.shouldDirty || options.shouldTouch) && updateTouchAndDirty(name, fieldValue, options.shouldTouch, options.shouldDirty, true);\n        options.shouldValidate && trigger(name);\n    };\n    const setValues = (name, value1, options)=>{\n        for(const fieldKey in value1){\n            if (!value1.hasOwnProperty(fieldKey)) {\n                return;\n            }\n            const fieldValue = value1[fieldKey];\n            const fieldName = name + \".\" + fieldKey;\n            const field = get(_fields, fieldName);\n            (_names.array.has(name) || isObject(fieldValue) || field && !field._f) && !isDateObject(fieldValue) ? setValues(fieldName, fieldValue, options) : setFieldValue(fieldName, fieldValue, options);\n        }\n    };\n    const setValue = function(name, value1) {\n        let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n        const field = get(_fields, name);\n        const isFieldArray = _names.array.has(name);\n        const cloneValue = cloneObject(value1);\n        set(_formValues, name, cloneValue);\n        if (isFieldArray) {\n            _subjects.array.next({\n                name,\n                values: cloneObject(_formValues)\n            });\n            if ((_proxyFormState.isDirty || _proxyFormState.dirtyFields || _proxySubscribeFormState.isDirty || _proxySubscribeFormState.dirtyFields) && options.shouldDirty) {\n                _subjects.state.next({\n                    name,\n                    dirtyFields: getDirtyFields(_defaultValues, _formValues),\n                    isDirty: _getDirty(name, cloneValue)\n                });\n            }\n        } else {\n            field && !field._f && !isNullOrUndefined(cloneValue) ? setValues(name, cloneValue, options) : setFieldValue(name, cloneValue, options);\n        }\n        isWatched(name, _names) && _subjects.state.next({\n            ..._formState\n        });\n        _subjects.state.next({\n            name: _state.mount ? name : undefined,\n            values: cloneObject(_formValues)\n        });\n    };\n    const onChange = async (event)=>{\n        _state.mount = true;\n        const target = event.target;\n        let name = target.name;\n        let isFieldValueUpdated = true;\n        const field = get(_fields, name);\n        const _updateIsFieldValueUpdated = (fieldValue)=>{\n            isFieldValueUpdated = Number.isNaN(fieldValue) || isDateObject(fieldValue) && isNaN(fieldValue.getTime()) || deepEqual(fieldValue, get(_formValues, name, fieldValue));\n        };\n        const validationModeBeforeSubmit = getValidationModes(_options.mode);\n        const validationModeAfterSubmit = getValidationModes(_options.reValidateMode);\n        if (field) {\n            let error;\n            let isValid;\n            const fieldValue = target.type ? getFieldValue(field._f) : getEventValue(event);\n            const isBlurEvent = event.type === EVENTS.BLUR || event.type === EVENTS.FOCUS_OUT;\n            const shouldSkipValidation = !hasValidation(field._f) && !_options.resolver && !get(_formState.errors, name) && !field._f.deps || skipValidation(isBlurEvent, get(_formState.touchedFields, name), _formState.isSubmitted, validationModeAfterSubmit, validationModeBeforeSubmit);\n            const watched = isWatched(name, _names, isBlurEvent);\n            set(_formValues, name, fieldValue);\n            if (isBlurEvent) {\n                field._f.onBlur && field._f.onBlur(event);\n                delayErrorCallback && delayErrorCallback(0);\n            } else if (field._f.onChange) {\n                field._f.onChange(event);\n            }\n            const fieldState = updateTouchAndDirty(name, fieldValue, isBlurEvent);\n            const shouldRender = !isEmptyObject(fieldState) || watched;\n            !isBlurEvent && _subjects.state.next({\n                name,\n                type: event.type,\n                values: cloneObject(_formValues)\n            });\n            if (shouldSkipValidation) {\n                if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                    if (_options.mode === \"onBlur\") {\n                        if (isBlurEvent) {\n                            _setValid();\n                        }\n                    } else if (!isBlurEvent) {\n                        _setValid();\n                    }\n                }\n                return shouldRender && _subjects.state.next({\n                    name,\n                    ...watched ? {} : fieldState\n                });\n            }\n            !isBlurEvent && watched && _subjects.state.next({\n                ..._formState\n            });\n            if (_options.resolver) {\n                const { errors } = await _runSchema([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    const previousErrorLookupResult = schemaErrorLookup(_formState.errors, _fields, name);\n                    const errorLookupResult = schemaErrorLookup(errors, _fields, previousErrorLookupResult.name || name);\n                    error = errorLookupResult.error;\n                    name = errorLookupResult.name;\n                    isValid = isEmptyObject(errors);\n                }\n            } else {\n                _updateIsValidating([\n                    name\n                ], true);\n                error = (await validateField(field, _names.disabled, _formValues, shouldDisplayAllAssociatedErrors, _options.shouldUseNativeValidation))[name];\n                _updateIsValidating([\n                    name\n                ]);\n                _updateIsFieldValueUpdated(fieldValue);\n                if (isFieldValueUpdated) {\n                    if (error) {\n                        isValid = false;\n                    } else if (_proxyFormState.isValid || _proxySubscribeFormState.isValid) {\n                        isValid = await executeBuiltInValidation(_fields, true);\n                    }\n                }\n            }\n            if (isFieldValueUpdated) {\n                field._f.deps && trigger(field._f.deps);\n                shouldRenderByError(name, isValid, error, fieldState);\n            }\n        }\n    };\n    const _focusInput = (ref, key)=>{\n        if (get(_formState.errors, key) && ref.focus) {\n            ref.focus();\n            return 1;\n        }\n        return;\n    };\n    const trigger = async function(name) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let isValid;\n        let validationResult;\n        const fieldNames = convertToArrayPayload(name);\n        if (_options.resolver) {\n            const errors = await executeSchemaAndUpdateState(isUndefined(name) ? name : fieldNames);\n            isValid = isEmptyObject(errors);\n            validationResult = name ? !fieldNames.some((name)=>get(errors, name)) : isValid;\n        } else if (name) {\n            validationResult = (await Promise.all(fieldNames.map(async (fieldName)=>{\n                const field = get(_fields, fieldName);\n                return await executeBuiltInValidation(field && field._f ? {\n                    [fieldName]: field\n                } : field);\n            }))).every(Boolean);\n            !(!validationResult && !_formState.isValid) && _setValid();\n        } else {\n            validationResult = isValid = await executeBuiltInValidation(_fields);\n        }\n        _subjects.state.next({\n            ...!isString(name) || (_proxyFormState.isValid || _proxySubscribeFormState.isValid) && isValid !== _formState.isValid ? {} : {\n                name\n            },\n            ..._options.resolver || !name ? {\n                isValid\n            } : {},\n            errors: _formState.errors\n        });\n        options.shouldFocus && !validationResult && iterateFieldsByAction(_fields, _focusInput, name ? fieldNames : _names.mount);\n        return validationResult;\n    };\n    const getValues = (fieldNames)=>{\n        const values = {\n            ..._state.mount ? _formValues : _defaultValues\n        };\n        return isUndefined(fieldNames) ? values : isString(fieldNames) ? get(values, fieldNames) : fieldNames.map((name)=>get(values, name));\n    };\n    const getFieldState = (name, formState)=>({\n            invalid: !!get((formState || _formState).errors, name),\n            isDirty: !!get((formState || _formState).dirtyFields, name),\n            error: get((formState || _formState).errors, name),\n            isValidating: !!get(_formState.validatingFields, name),\n            isTouched: !!get((formState || _formState).touchedFields, name)\n        });\n    const clearErrors = (name)=>{\n        name && convertToArrayPayload(name).forEach((inputName)=>unset(_formState.errors, inputName));\n        _subjects.state.next({\n            errors: name ? _formState.errors : {}\n        });\n    };\n    const setError = (name, error, options)=>{\n        const ref = (get(_fields, name, {\n            _f: {}\n        })._f || {}).ref;\n        const currentError = get(_formState.errors, name) || {};\n        // Don't override existing error messages elsewhere in the object tree.\n        const { ref: currentRef, message, type, ...restOfErrorTree } = currentError;\n        set(_formState.errors, name, {\n            ...restOfErrorTree,\n            ...error,\n            ref\n        });\n        _subjects.state.next({\n            name,\n            errors: _formState.errors,\n            isValid: false\n        });\n        options && options.shouldFocus && ref && ref.focus && ref.focus();\n    };\n    const watch = (name, defaultValue)=>isFunction(name) ? _subjects.state.subscribe({\n            next: (payload)=>name(_getWatch(undefined, defaultValue), payload)\n        }) : _getWatch(name, defaultValue, true);\n    const _subscribe = (props)=>_subjects.state.subscribe({\n            next: (formState)=>{\n                if (shouldSubscribeByName(props.name, formState.name, props.exact) && shouldRenderFormState(formState, props.formState || _proxyFormState, _setFormState, props.reRenderRoot)) {\n                    props.callback({\n                        values: {\n                            ..._formValues\n                        },\n                        ..._formState,\n                        ...formState\n                    });\n                }\n            }\n        }).unsubscribe;\n    const subscribe = (props)=>{\n        _state.mount = true;\n        _proxySubscribeFormState = {\n            ..._proxySubscribeFormState,\n            ...props.formState\n        };\n        return _subscribe({\n            ...props,\n            formState: _proxySubscribeFormState\n        });\n    };\n    const unregister = function(name) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        for (const fieldName of name ? convertToArrayPayload(name) : _names.mount){\n            _names.mount.delete(fieldName);\n            _names.array.delete(fieldName);\n            if (!options.keepValue) {\n                unset(_fields, fieldName);\n                unset(_formValues, fieldName);\n            }\n            !options.keepError && unset(_formState.errors, fieldName);\n            !options.keepDirty && unset(_formState.dirtyFields, fieldName);\n            !options.keepTouched && unset(_formState.touchedFields, fieldName);\n            !options.keepIsValidating && unset(_formState.validatingFields, fieldName);\n            !_options.shouldUnregister && !options.keepDefaultValue && unset(_defaultValues, fieldName);\n        }\n        _subjects.state.next({\n            values: cloneObject(_formValues)\n        });\n        _subjects.state.next({\n            ..._formState,\n            ...!options.keepDirty ? {} : {\n                isDirty: _getDirty()\n            }\n        });\n        !options.keepIsValid && _setValid();\n    };\n    const _setDisabledField = (param)=>{\n        let { disabled, name } = param;\n        if (isBoolean(disabled) && _state.mount || !!disabled || _names.disabled.has(name)) {\n            disabled ? _names.disabled.add(name) : _names.disabled.delete(name);\n        }\n    };\n    const register = function(name) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        let field = get(_fields, name);\n        const disabledIsDefined = isBoolean(options.disabled) || isBoolean(_options.disabled);\n        set(_fields, name, {\n            ...field || {},\n            _f: {\n                ...field && field._f ? field._f : {\n                    ref: {\n                        name\n                    }\n                },\n                name,\n                mount: true,\n                ...options\n            }\n        });\n        _names.mount.add(name);\n        if (field) {\n            _setDisabledField({\n                disabled: isBoolean(options.disabled) ? options.disabled : _options.disabled,\n                name\n            });\n        } else {\n            updateValidAndValue(name, true, options.value);\n        }\n        return {\n            ...disabledIsDefined ? {\n                disabled: options.disabled || _options.disabled\n            } : {},\n            ..._options.progressive ? {\n                required: !!options.required,\n                min: getRuleValue(options.min),\n                max: getRuleValue(options.max),\n                minLength: getRuleValue(options.minLength),\n                maxLength: getRuleValue(options.maxLength),\n                pattern: getRuleValue(options.pattern)\n            } : {},\n            name,\n            onChange,\n            onBlur: onChange,\n            ref: (ref)=>{\n                if (ref) {\n                    register(name, options);\n                    field = get(_fields, name);\n                    const fieldRef = isUndefined(ref.value) ? ref.querySelectorAll ? ref.querySelectorAll(\"input,select,textarea\")[0] || ref : ref : ref;\n                    const radioOrCheckbox = isRadioOrCheckbox(fieldRef);\n                    const refs = field._f.refs || [];\n                    if (radioOrCheckbox ? refs.find((option)=>option === fieldRef) : fieldRef === field._f.ref) {\n                        return;\n                    }\n                    set(_fields, name, {\n                        _f: {\n                            ...field._f,\n                            ...radioOrCheckbox ? {\n                                refs: [\n                                    ...refs.filter(live),\n                                    fieldRef,\n                                    ...Array.isArray(get(_defaultValues, name)) ? [\n                                        {}\n                                    ] : []\n                                ],\n                                ref: {\n                                    type: fieldRef.type,\n                                    name\n                                }\n                            } : {\n                                ref: fieldRef\n                            }\n                        }\n                    });\n                    updateValidAndValue(name, false, undefined, fieldRef);\n                } else {\n                    field = get(_fields, name, {});\n                    if (field._f) {\n                        field._f.mount = false;\n                    }\n                    (_options.shouldUnregister || options.shouldUnregister) && !(isNameInFieldArray(_names.array, name) && _state.action) && _names.unMount.add(name);\n                }\n            }\n        };\n    };\n    const _focusError = ()=>_options.shouldFocusError && iterateFieldsByAction(_fields, _focusInput, _names.mount);\n    const _disableForm = (disabled)=>{\n        if (isBoolean(disabled)) {\n            _subjects.state.next({\n                disabled\n            });\n            iterateFieldsByAction(_fields, (ref, name)=>{\n                const currentField = get(_fields, name);\n                if (currentField) {\n                    ref.disabled = currentField._f.disabled || disabled;\n                    if (Array.isArray(currentField._f.refs)) {\n                        currentField._f.refs.forEach((inputRef)=>{\n                            inputRef.disabled = currentField._f.disabled || disabled;\n                        });\n                    }\n                }\n            }, 0, false);\n        }\n    };\n    const handleSubmit = (onValid, onInvalid)=>async (e)=>{\n            let onValidError = undefined;\n            if (e) {\n                e.preventDefault && e.preventDefault();\n                e.persist && e.persist();\n            }\n            let fieldValues = cloneObject(_formValues);\n            _subjects.state.next({\n                isSubmitting: true\n            });\n            if (_options.resolver) {\n                const { errors, values } = await _runSchema();\n                _formState.errors = errors;\n                fieldValues = values;\n            } else {\n                await executeBuiltInValidation(_fields);\n            }\n            if (_names.disabled.size) {\n                for (const name of _names.disabled){\n                    set(fieldValues, name, undefined);\n                }\n            }\n            unset(_formState.errors, \"root\");\n            if (isEmptyObject(_formState.errors)) {\n                _subjects.state.next({\n                    errors: {}\n                });\n                try {\n                    await onValid(fieldValues, e);\n                } catch (error) {\n                    onValidError = error;\n                }\n            } else {\n                if (onInvalid) {\n                    await onInvalid({\n                        ..._formState.errors\n                    }, e);\n                }\n                _focusError();\n                setTimeout(_focusError);\n            }\n            _subjects.state.next({\n                isSubmitted: true,\n                isSubmitting: false,\n                isSubmitSuccessful: isEmptyObject(_formState.errors) && !onValidError,\n                submitCount: _formState.submitCount + 1,\n                errors: _formState.errors\n            });\n            if (onValidError) {\n                throw onValidError;\n            }\n        };\n    const resetField = function(name) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        if (get(_fields, name)) {\n            if (isUndefined(options.defaultValue)) {\n                setValue(name, cloneObject(get(_defaultValues, name)));\n            } else {\n                setValue(name, options.defaultValue);\n                set(_defaultValues, name, cloneObject(options.defaultValue));\n            }\n            if (!options.keepTouched) {\n                unset(_formState.touchedFields, name);\n            }\n            if (!options.keepDirty) {\n                unset(_formState.dirtyFields, name);\n                _formState.isDirty = options.defaultValue ? _getDirty(name, cloneObject(get(_defaultValues, name))) : _getDirty();\n            }\n            if (!options.keepError) {\n                unset(_formState.errors, name);\n                _proxyFormState.isValid && _setValid();\n            }\n            _subjects.state.next({\n                ..._formState\n            });\n        }\n    };\n    const _reset = function(formValues) {\n        let keepStateOptions = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const updatedValues = formValues ? cloneObject(formValues) : _defaultValues;\n        const cloneUpdatedValues = cloneObject(updatedValues);\n        const isEmptyResetValues = isEmptyObject(formValues);\n        const values = isEmptyResetValues ? _defaultValues : cloneUpdatedValues;\n        if (!keepStateOptions.keepDefaultValues) {\n            _defaultValues = updatedValues;\n        }\n        if (!keepStateOptions.keepValues) {\n            if (keepStateOptions.keepDirtyValues) {\n                const fieldsToCheck = new Set([\n                    ..._names.mount,\n                    ...Object.keys(getDirtyFields(_defaultValues, _formValues))\n                ]);\n                for (const fieldName of Array.from(fieldsToCheck)){\n                    get(_formState.dirtyFields, fieldName) ? set(values, fieldName, get(_formValues, fieldName)) : setValue(fieldName, get(values, fieldName));\n                }\n            } else {\n                if (isWeb && isUndefined(formValues)) {\n                    for (const name of _names.mount){\n                        const field = get(_fields, name);\n                        if (field && field._f) {\n                            const fieldReference = Array.isArray(field._f.refs) ? field._f.refs[0] : field._f.ref;\n                            if (isHTMLElement(fieldReference)) {\n                                const form = fieldReference.closest(\"form\");\n                                if (form) {\n                                    form.reset();\n                                    break;\n                                }\n                            }\n                        }\n                    }\n                }\n                for (const fieldName of _names.mount){\n                    setValue(fieldName, get(values, fieldName));\n                }\n            }\n            _formValues = cloneObject(values);\n            _subjects.array.next({\n                values: {\n                    ...values\n                }\n            });\n            _subjects.state.next({\n                values: {\n                    ...values\n                }\n            });\n        }\n        _names = {\n            mount: keepStateOptions.keepDirtyValues ? _names.mount : new Set(),\n            unMount: new Set(),\n            array: new Set(),\n            disabled: new Set(),\n            watch: new Set(),\n            watchAll: false,\n            focus: \"\"\n        };\n        _state.mount = !_proxyFormState.isValid || !!keepStateOptions.keepIsValid || !!keepStateOptions.keepDirtyValues;\n        _state.watch = !!_options.shouldUnregister;\n        _subjects.state.next({\n            submitCount: keepStateOptions.keepSubmitCount ? _formState.submitCount : 0,\n            isDirty: isEmptyResetValues ? false : keepStateOptions.keepDirty ? _formState.isDirty : !!(keepStateOptions.keepDefaultValues && !deepEqual(formValues, _defaultValues)),\n            isSubmitted: keepStateOptions.keepIsSubmitted ? _formState.isSubmitted : false,\n            dirtyFields: isEmptyResetValues ? {} : keepStateOptions.keepDirtyValues ? keepStateOptions.keepDefaultValues && _formValues ? getDirtyFields(_defaultValues, _formValues) : _formState.dirtyFields : keepStateOptions.keepDefaultValues && formValues ? getDirtyFields(_defaultValues, formValues) : keepStateOptions.keepDirty ? _formState.dirtyFields : {},\n            touchedFields: keepStateOptions.keepTouched ? _formState.touchedFields : {},\n            errors: keepStateOptions.keepErrors ? _formState.errors : {},\n            isSubmitSuccessful: keepStateOptions.keepIsSubmitSuccessful ? _formState.isSubmitSuccessful : false,\n            isSubmitting: false\n        });\n    };\n    const reset = (formValues, keepStateOptions)=>_reset(isFunction(formValues) ? formValues(_formValues) : formValues, keepStateOptions);\n    const setFocus = function(name) {\n        let options = arguments.length > 1 && arguments[1] !== void 0 ? arguments[1] : {};\n        const field = get(_fields, name);\n        const fieldReference = field && field._f;\n        if (fieldReference) {\n            const fieldRef = fieldReference.refs ? fieldReference.refs[0] : fieldReference.ref;\n            if (fieldRef.focus) {\n                fieldRef.focus();\n                options.shouldSelect && isFunction(fieldRef.select) && fieldRef.select();\n            }\n        }\n    };\n    const _setFormState = (updatedFormState)=>{\n        _formState = {\n            ..._formState,\n            ...updatedFormState\n        };\n    };\n    const _resetDefaultValues = ()=>isFunction(_options.defaultValues) && _options.defaultValues().then((values)=>{\n            reset(values, _options.resetOptions);\n            _subjects.state.next({\n                isLoading: false\n            });\n        });\n    const methods = {\n        control: {\n            register,\n            unregister,\n            getFieldState,\n            handleSubmit,\n            setError,\n            _subscribe,\n            _runSchema,\n            _focusError,\n            _getWatch,\n            _getDirty,\n            _setValid,\n            _setFieldArray,\n            _setDisabledField,\n            _setErrors,\n            _getFieldArray,\n            _reset,\n            _resetDefaultValues,\n            _removeUnmounted,\n            _disableForm,\n            _subjects,\n            _proxyFormState,\n            get _fields () {\n                return _fields;\n            },\n            get _formValues () {\n                return _formValues;\n            },\n            get _state () {\n                return _state;\n            },\n            set _state (value){\n                _state = value;\n            },\n            get _defaultValues () {\n                return _defaultValues;\n            },\n            get _names () {\n                return _names;\n            },\n            set _names (value){\n                _names = value;\n            },\n            get _formState () {\n                return _formState;\n            },\n            get _options () {\n                return _options;\n            },\n            set _options (value){\n                _options = {\n                    ..._options,\n                    ...value\n                };\n            }\n        },\n        subscribe,\n        trigger,\n        register,\n        handleSubmit,\n        watch,\n        setValue,\n        getValues,\n        reset,\n        resetField,\n        clearErrors,\n        unregister,\n        setError,\n        setFocus,\n        getFieldState\n    };\n    return {\n        ...methods,\n        formControl: methods\n    };\n}\nvar generateId = ()=>{\n    if (typeof crypto !== \"undefined\" && crypto.randomUUID) {\n        return crypto.randomUUID();\n    }\n    const d = typeof performance === \"undefined\" ? Date.now() : performance.now() * 1000;\n    return \"xxxxxxxx-xxxx-4xxx-yxxx-xxxxxxxxxxxx\".replace(/[xy]/g, (c)=>{\n        const r = (Math.random() * 16 + d) % 16 | 0;\n        return (c == \"x\" ? r : r & 0x3 | 0x8).toString(16);\n    });\n};\nvar getFocusFieldName = function(name, index) {\n    let options = arguments.length > 2 && arguments[2] !== void 0 ? arguments[2] : {};\n    return options.shouldFocus || isUndefined(options.shouldFocus) ? options.focusName || \"\".concat(name, \".\").concat(isUndefined(options.focusIndex) ? index : options.focusIndex, \".\") : \"\";\n};\nvar appendAt = (data, value1)=>[\n        ...data,\n        ...convertToArrayPayload(value1)\n    ];\nvar fillEmptyArray = (value1)=>Array.isArray(value1) ? value1.map(()=>undefined) : undefined;\nfunction insert(data, index, value1) {\n    return [\n        ...data.slice(0, index),\n        ...convertToArrayPayload(value1),\n        ...data.slice(index)\n    ];\n}\nvar moveArrayAt = (data, from, to)=>{\n    if (!Array.isArray(data)) {\n        return [];\n    }\n    if (isUndefined(data[to])) {\n        data[to] = undefined;\n    }\n    data.splice(to, 0, data.splice(from, 1)[0]);\n    return data;\n};\nvar prependAt = (data, value1)=>[\n        ...convertToArrayPayload(value1),\n        ...convertToArrayPayload(data)\n    ];\nfunction removeAtIndexes(data, indexes) {\n    let i = 0;\n    const temp = [\n        ...data\n    ];\n    for (const index of indexes){\n        temp.splice(index - i, 1);\n        i++;\n    }\n    return compact(temp).length ? temp : [];\n}\nvar removeArrayAt = (data, index)=>isUndefined(index) ? [] : removeAtIndexes(data, convertToArrayPayload(index).sort((a, b)=>a - b));\nvar swapArrayAt = (data, indexA, indexB)=>{\n    [data[indexA], data[indexB]] = [\n        data[indexB],\n        data[indexA]\n    ];\n};\nvar updateAt = (fieldValues, index, value1)=>{\n    fieldValues[index] = value1;\n    return fieldValues;\n};\n/**\n * A custom hook that exposes convenient methods to perform operations with a list of dynamic inputs that need to be appended, updated, removed etc. • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn) • [Video](https://youtu.be/4MrbfGSFY2A)\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/usefieldarray) • [Demo](https://codesandbox.io/s/react-hook-form-usefieldarray-ssugn)\n *\n * @param props - useFieldArray props\n *\n * @returns methods - functions to manipulate with the Field Arrays (dynamic inputs) {@link UseFieldArrayReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, control, handleSubmit, reset, trigger, setError } = useForm({\n *     defaultValues: {\n *       test: []\n *     }\n *   });\n *   const { fields, append } = useFieldArray({\n *     control,\n *     name: \"test\"\n *   });\n *\n *   return (\n *     <form onSubmit={handleSubmit(data => console.log(data))}>\n *       {fields.map((item, index) => (\n *          <input key={item.id} {...register(`test.${index}.firstName`)}  />\n *       ))}\n *       <button type=\"button\" onClick={() => append({ firstName: \"bill\" })}>\n *         append\n *       </button>\n *       <input type=\"submit\" />\n *     </form>\n *   );\n * }\n * ```\n */ function useFieldArray(props) {\n    _s6();\n    const methods = useFormContext();\n    const { control = methods.control, name, keyName = \"id\", shouldUnregister, rules } = props;\n    const [fields, setFields] = react__WEBPACK_IMPORTED_MODULE_0__.useState(control._getFieldArray(name));\n    const ids = react__WEBPACK_IMPORTED_MODULE_0__.useRef(control._getFieldArray(name).map(generateId));\n    const _fieldIds = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fields);\n    const _name = react__WEBPACK_IMPORTED_MODULE_0__.useRef(name);\n    const _actioned = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    _name.current = name;\n    _fieldIds.current = fields;\n    control._names.array.add(name);\n    rules && control.register(name, rules);\n    useIsomorphicLayoutEffect(()=>control._subjects.array.subscribe({\n            next: (param)=>{\n                let { values, name: fieldArrayName } = param;\n                if (fieldArrayName === _name.current || !fieldArrayName) {\n                    const fieldValues = get(values, _name.current);\n                    if (Array.isArray(fieldValues)) {\n                        setFields(fieldValues);\n                        ids.current = fieldValues.map(generateId);\n                    }\n                }\n            }\n        }).unsubscribe, [\n        control\n    ]);\n    const updateValues = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((updatedFieldArrayValues)=>{\n        _actioned.current = true;\n        control._setFieldArray(name, updatedFieldArrayValues);\n    }, [\n        control,\n        name\n    ]);\n    const append = (value1, options)=>{\n        const appendValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = appendAt(control._getFieldArray(name), appendValue);\n        control._names.focus = getFocusFieldName(name, updatedFieldArrayValues.length - 1, options);\n        ids.current = appendAt(ids.current, appendValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, appendAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const prepend = (value1, options)=>{\n        const prependValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = prependAt(control._getFieldArray(name), prependValue);\n        control._names.focus = getFocusFieldName(name, 0, options);\n        ids.current = prependAt(ids.current, prependValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, prependAt, {\n            argA: fillEmptyArray(value1)\n        });\n    };\n    const remove = (index)=>{\n        const updatedFieldArrayValues = removeArrayAt(control._getFieldArray(name), index);\n        ids.current = removeArrayAt(ids.current, index);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        !Array.isArray(get(control._fields, name)) && set(control._fields, name, undefined);\n        control._setFieldArray(name, updatedFieldArrayValues, removeArrayAt, {\n            argA: index\n        });\n    };\n    const insert$1 = (index, value1, options)=>{\n        const insertValue = convertToArrayPayload(cloneObject(value1));\n        const updatedFieldArrayValues = insert(control._getFieldArray(name), index, insertValue);\n        control._names.focus = getFocusFieldName(name, index, options);\n        ids.current = insert(ids.current, index, insertValue.map(generateId));\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, insert, {\n            argA: index,\n            argB: fillEmptyArray(value1)\n        });\n    };\n    const swap = (indexA, indexB)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        swapArrayAt(updatedFieldArrayValues, indexA, indexB);\n        swapArrayAt(ids.current, indexA, indexB);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, swapArrayAt, {\n            argA: indexA,\n            argB: indexB\n        }, false);\n    };\n    const move = (from, to)=>{\n        const updatedFieldArrayValues = control._getFieldArray(name);\n        moveArrayAt(updatedFieldArrayValues, from, to);\n        moveArrayAt(ids.current, from, to);\n        updateValues(updatedFieldArrayValues);\n        setFields(updatedFieldArrayValues);\n        control._setFieldArray(name, updatedFieldArrayValues, moveArrayAt, {\n            argA: from,\n            argB: to\n        }, false);\n    };\n    const update = (index, value1)=>{\n        const updateValue = cloneObject(value1);\n        const updatedFieldArrayValues = updateAt(control._getFieldArray(name), index, updateValue);\n        ids.current = [\n            ...updatedFieldArrayValues\n        ].map((item, i)=>!item || i === index ? generateId() : ids.current[i]);\n        updateValues(updatedFieldArrayValues);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, updatedFieldArrayValues, updateAt, {\n            argA: index,\n            argB: updateValue\n        }, true, false);\n    };\n    const replace = (value1)=>{\n        const updatedFieldArrayValues = convertToArrayPayload(cloneObject(value1));\n        ids.current = updatedFieldArrayValues.map(generateId);\n        updateValues([\n            ...updatedFieldArrayValues\n        ]);\n        setFields([\n            ...updatedFieldArrayValues\n        ]);\n        control._setFieldArray(name, [\n            ...updatedFieldArrayValues\n        ], (data)=>data, {}, true, false);\n    };\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        control._state.action = false;\n        isWatched(name, control._names) && control._subjects.state.next({\n            ...control._formState\n        });\n        if (_actioned.current && (!getValidationModes(control._options.mode).isOnSubmit || control._formState.isSubmitted) && !getValidationModes(control._options.reValidateMode).isOnSubmit) {\n            if (control._options.resolver) {\n                control._runSchema([\n                    name\n                ]).then((result)=>{\n                    const error = get(result.errors, name);\n                    const existingError = get(control._formState.errors, name);\n                    if (existingError ? !error && existingError.type || error && (existingError.type !== error.type || existingError.message !== error.message) : error && error.type) {\n                        error ? set(control._formState.errors, name, error) : unset(control._formState.errors, name);\n                        control._subjects.state.next({\n                            errors: control._formState.errors\n                        });\n                    }\n                });\n            } else {\n                const field = get(control._fields, name);\n                if (field && field._f && !(getValidationModes(control._options.reValidateMode).isOnSubmit && getValidationModes(control._options.mode).isOnSubmit)) {\n                    validateField(field, control._names.disabled, control._formValues, control._options.criteriaMode === VALIDATION_MODE.all, control._options.shouldUseNativeValidation, true).then((error)=>!isEmptyObject(error) && control._subjects.state.next({\n                            errors: updateFieldArrayRootError(control._formState.errors, error, name)\n                        }));\n                }\n            }\n        }\n        control._subjects.state.next({\n            name,\n            values: cloneObject(control._formValues)\n        });\n        control._names.focus && iterateFieldsByAction(control._fields, (ref, key)=>{\n            if (control._names.focus && key.startsWith(control._names.focus) && ref.focus) {\n                ref.focus();\n                return 1;\n            }\n            return;\n        });\n        control._names.focus = \"\";\n        control._setValid();\n        _actioned.current = false;\n    }, [\n        fields,\n        name,\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        !get(control._formValues, name) && control._setFieldArray(name);\n        return ()=>{\n            const updateMounted = (name, value1)=>{\n                const field = get(control._fields, name);\n                if (field && field._f) {\n                    field._f.mount = value1;\n                }\n            };\n            control._options.shouldUnregister || shouldUnregister ? control.unregister(name) : updateMounted(name, false);\n        };\n    }, [\n        name,\n        control,\n        keyName,\n        shouldUnregister\n    ]);\n    return {\n        swap: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(swap, [\n            updateValues,\n            name,\n            control\n        ]),\n        move: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(move, [\n            updateValues,\n            name,\n            control\n        ]),\n        prepend: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(prepend, [\n            updateValues,\n            name,\n            control\n        ]),\n        append: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(append, [\n            updateValues,\n            name,\n            control\n        ]),\n        remove: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(remove, [\n            updateValues,\n            name,\n            control\n        ]),\n        insert: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(insert$1, [\n            updateValues,\n            name,\n            control\n        ]),\n        update: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(update, [\n            updateValues,\n            name,\n            control\n        ]),\n        replace: react__WEBPACK_IMPORTED_MODULE_0__.useCallback(replace, [\n            updateValues,\n            name,\n            control\n        ]),\n        fields: react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>fields.map((field, index)=>({\n                    ...field,\n                    [keyName]: ids.current[index] || generateId()\n                })), [\n            fields,\n            keyName\n        ])\n    };\n}\n_s6(useFieldArray, \"DNXjzJyMGY3jE576dcczn6LfHOE=\", false, function() {\n    return [\n        useFormContext,\n        useIsomorphicLayoutEffect\n    ];\n});\n/**\n * Custom hook to manage the entire form.\n *\n * @remarks\n * [API](https://react-hook-form.com/docs/useform) • [Demo](https://codesandbox.io/s/react-hook-form-get-started-ts-5ksmm) • [Video](https://www.youtube.com/watch?v=RkXv4AXXC_4)\n *\n * @param props - form configuration and validation parameters.\n *\n * @returns methods - individual functions to manage the form state. {@link UseFormReturn}\n *\n * @example\n * ```tsx\n * function App() {\n *   const { register, handleSubmit, watch, formState: { errors } } = useForm();\n *   const onSubmit = data => console.log(data);\n *\n *   console.log(watch(\"example\"));\n *\n *   return (\n *     <form onSubmit={handleSubmit(onSubmit)}>\n *       <input defaultValue=\"test\" {...register(\"example\")} />\n *       <input {...register(\"exampleRequired\", { required: true })} />\n *       {errors.exampleRequired && <span>This field is required</span>}\n *       <button>Submit</button>\n *     </form>\n *   );\n * }\n * ```\n */ function useForm() {\n    let props = arguments.length > 0 && arguments[0] !== void 0 ? arguments[0] : {};\n    _s7();\n    const _formControl = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const _values = react__WEBPACK_IMPORTED_MODULE_0__.useRef(undefined);\n    const [formState, updateFormState] = react__WEBPACK_IMPORTED_MODULE_0__.useState({\n        isDirty: false,\n        isValidating: false,\n        isLoading: isFunction(props.defaultValues),\n        isSubmitted: false,\n        isSubmitting: false,\n        isSubmitSuccessful: false,\n        isValid: false,\n        submitCount: 0,\n        dirtyFields: {},\n        touchedFields: {},\n        validatingFields: {},\n        errors: props.errors || {},\n        disabled: props.disabled || false,\n        isReady: false,\n        defaultValues: isFunction(props.defaultValues) ? undefined : props.defaultValues\n    });\n    if (!_formControl.current) {\n        if (props.formControl) {\n            _formControl.current = {\n                ...props.formControl,\n                formState\n            };\n            if (props.defaultValues && !isFunction(props.defaultValues)) {\n                props.formControl.reset(props.defaultValues, props.resetOptions);\n            }\n        } else {\n            const { formControl, ...rest } = createFormControl(props);\n            _formControl.current = {\n                ...rest,\n                formState\n            };\n        }\n    }\n    const control = _formControl.current.control;\n    control._options = props;\n    useIsomorphicLayoutEffect(()=>{\n        const sub = control._subscribe({\n            formState: control._proxyFormState,\n            callback: ()=>updateFormState({\n                    ...control._formState\n                }),\n            reRenderRoot: true\n        });\n        updateFormState((data)=>({\n                ...data,\n                isReady: true\n            }));\n        control._formState.isReady = true;\n        return sub;\n    }, [\n        control\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>control._disableForm(props.disabled), [\n        control,\n        props.disabled\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.mode) {\n            control._options.mode = props.mode;\n        }\n        if (props.reValidateMode) {\n            control._options.reValidateMode = props.reValidateMode;\n        }\n    }, [\n        control,\n        props.mode,\n        props.reValidateMode\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.errors) {\n            control._setErrors(props.errors);\n            control._focusError();\n        }\n    }, [\n        control,\n        props.errors\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        props.shouldUnregister && control._subjects.state.next({\n            values: control._getWatch()\n        });\n    }, [\n        control,\n        props.shouldUnregister\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (control._proxyFormState.isDirty) {\n            const isDirty = control._getDirty();\n            if (isDirty !== formState.isDirty) {\n                control._subjects.state.next({\n                    isDirty\n                });\n            }\n        }\n    }, [\n        control,\n        formState.isDirty\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (props.values && !deepEqual(props.values, _values.current)) {\n            control._reset(props.values, control._options.resetOptions);\n            _values.current = props.values;\n            updateFormState((state)=>({\n                    ...state\n                }));\n        } else {\n            control._resetDefaultValues();\n        }\n    }, [\n        control,\n        props.values\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        if (!control._state.mount) {\n            control._setValid();\n            control._state.mount = true;\n        }\n        if (control._state.watch) {\n            control._state.watch = false;\n            control._subjects.state.next({\n                ...control._formState\n            });\n        }\n        control._removeUnmounted();\n    });\n    _formControl.current.formState = getProxyFormState(formState, control);\n    return _formControl.current;\n}\n_s7(useForm, \"5P/zJLy0BCb+dJxs5FbdJNnOPow=\", false, function() {\n    return [\n        useIsomorphicLayoutEffect\n    ];\n});\n //# sourceMappingURL=index.esm.mjs.map\nvar _c, _c1, _c2;\n$RefreshReg$(_c, \"FormProvider\");\n$RefreshReg$(_c1, \"Controller\");\n$RefreshReg$(_c2, \"Form\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKGFwcC1wYWdlcy1icm93c2VyKS8uL25vZGVfbW9kdWxlcy9yZWFjdC1ob29rLWZvcm0vZGlzdC9pbmRleC5lc20ubWpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUErQjtBQUNJO0FBRW5DLElBQUlFLGtCQUFrQixDQUFDQyxVQUFZQSxRQUFRQyxJQUFJLEtBQUs7QUFFcEQsSUFBSUMsZUFBZSxDQUFDQyxTQUFVQSxrQkFBaUJDO0FBRS9DLElBQUlDLG9CQUFvQixDQUFDRixTQUFVQSxVQUFTO0FBRTVDLE1BQU1HLGVBQWUsQ0FBQ0gsU0FBVSxPQUFPQSxXQUFVO0FBQ2pELElBQUlJLFdBQVcsQ0FBQ0osU0FBVSxDQUFDRSxrQkFBa0JGLFdBQ3pDLENBQUNLLE1BQU1DLE9BQU8sQ0FBQ04sV0FDZkcsYUFBYUgsV0FDYixDQUFDRCxhQUFhQztBQUVsQixJQUFJTyxnQkFBZ0IsQ0FBQ0MsUUFBVUosU0FBU0ksVUFBVUEsTUFBTUMsTUFBTSxHQUN4RGIsZ0JBQWdCWSxNQUFNQyxNQUFNLElBQ3hCRCxNQUFNQyxNQUFNLENBQUNDLE9BQU8sR0FDcEJGLE1BQU1DLE1BQU0sQ0FBQ1QsS0FBSyxHQUN0QlE7QUFFTixJQUFJRyxvQkFBb0IsQ0FBQ0MsT0FBU0EsS0FBS0MsU0FBUyxDQUFDLEdBQUdELEtBQUtFLE1BQU0sQ0FBQyxtQkFBbUJGO0FBRW5GLElBQUlHLHFCQUFxQixDQUFDQyxPQUFPSixPQUFTSSxNQUFNQyxHQUFHLENBQUNOLGtCQUFrQkM7QUFFdEUsSUFBSU0sZ0JBQWdCLENBQUNDO0lBQ2pCLE1BQU1DLGdCQUFnQkQsV0FBV0UsV0FBVyxJQUFJRixXQUFXRSxXQUFXLENBQUNDLFNBQVM7SUFDaEYsT0FBUWxCLFNBQVNnQixrQkFBa0JBLGNBQWNHLGNBQWMsQ0FBQztBQUNwRTtBQUVBLElBQUlDLFFBQVEsS0FBa0IsSUFDMUIsT0FBT0MsT0FBT0MsV0FBVyxLQUFLLGVBQzlCLE9BQU9DLGFBQWE7QUFFeEIsU0FBU0MsWUFBWUMsSUFBSTtJ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bS9kaXN0L2luZGV4LmVzbS5tanM/OWRjMyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgUmVhY3RfX2RlZmF1bHQgZnJvbSAncmVhY3QnO1xuXG52YXIgaXNDaGVja0JveElucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2NoZWNrYm94JztcblxudmFyIGlzRGF0ZU9iamVjdCA9ICh2YWx1ZSkgPT4gdmFsdWUgaW5zdGFuY2VvZiBEYXRlO1xuXG52YXIgaXNOdWxsT3JVbmRlZmluZWQgPSAodmFsdWUpID0+IHZhbHVlID09IG51bGw7XG5cbmNvbnN0IGlzT2JqZWN0VHlwZSA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnb2JqZWN0JztcbnZhciBpc09iamVjdCA9ICh2YWx1ZSkgPT4gIWlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKSAmJlxuICAgICFBcnJheS5pc0FycmF5KHZhbHVlKSAmJlxuICAgIGlzT2JqZWN0VHlwZSh2YWx1ZSkgJiZcbiAgICAhaXNEYXRlT2JqZWN0KHZhbHVlKTtcblxudmFyIGdldEV2ZW50VmFsdWUgPSAoZXZlbnQpID0+IGlzT2JqZWN0KGV2ZW50KSAmJiBldmVudC50YXJnZXRcbiAgICA/IGlzQ2hlY2tCb3hJbnB1dChldmVudC50YXJnZXQpXG4gICAgICAgID8gZXZlbnQudGFyZ2V0LmNoZWNrZWRcbiAgICAgICAgOiBldmVudC50YXJnZXQudmFsdWVcbiAgICA6IGV2ZW50O1xuXG52YXIgZ2V0Tm9kZVBhcmVudE5hbWUgPSAobmFtZSkgPT4gbmFtZS5zdWJzdHJpbmcoMCwgbmFtZS5zZWFyY2goL1xcLlxcZCsoXFwufCQpLykpIHx8IG5hbWU7XG5cbnZhciBpc05hbWVJbkZpZWxkQXJyYXkgPSAobmFtZXMsIG5hbWUpID0+IG5hbWVzLmhhcyhnZXROb2RlUGFyZW50TmFtZShuYW1lKSk7XG5cbnZhciBpc1BsYWluT2JqZWN0ID0gKHRlbXBPYmplY3QpID0+IHtcbiAgICBjb25zdCBwcm90b3R5cGVDb3B5ID0gdGVtcE9iamVjdC5jb25zdHJ1Y3RvciAmJiB0ZW1wT2JqZWN0LmNvbnN0cnVjdG9yLnByb3RvdHlwZTtcbiAgICByZXR1cm4gKGlzT2JqZWN0KHByb3RvdHlwZUNvcHkpICYmIHByb3RvdHlwZUNvcHkuaGFzT3duUHJvcGVydHkoJ2lzUHJvdG90eXBlT2YnKSk7XG59O1xuXG52YXIgaXNXZWIgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJlxuICAgIHR5cGVvZiB3aW5kb3cuSFRNTEVsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmXG4gICAgdHlwZW9mIGRvY3VtZW50ICE9PSAndW5kZWZpbmVkJztcblxuZnVuY3Rpb24gY2xvbmVPYmplY3QoZGF0YSkge1xuICAgIGxldCBjb3B5O1xuICAgIGNvbnN0IGlzQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGNvbnN0IGlzRmlsZUxpc3RJbnN0YW5jZSA9IHR5cGVvZiBGaWxlTGlzdCAhPT0gJ3VuZGVmaW5lZCcgPyBkYXRhIGluc3RhbmNlb2YgRmlsZUxpc3QgOiBmYWxzZTtcbiAgICBpZiAoZGF0YSBpbnN0YW5jZW9mIERhdGUpIHtcbiAgICAgICAgY29weSA9IG5ldyBEYXRlKGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgU2V0KSB7XG4gICAgICAgIGNvcHkgPSBuZXcgU2V0KGRhdGEpO1xuICAgIH1cbiAgICBlbHNlIGlmICghKGlzV2ViICYmIChkYXRhIGluc3RhbmNlb2YgQmxvYiB8fCBpc0ZpbGVMaXN0SW5zdGFuY2UpKSAmJlxuICAgICAgICAoaXNBcnJheSB8fCBpc09iamVjdChkYXRhKSkpIHtcbiAgICAgICAgY29weSA9IGlzQXJyYXkgPyBbXSA6IHt9O1xuICAgICAgICBpZiAoIWlzQXJyYXkgJiYgIWlzUGxhaW5PYmplY3QoZGF0YSkpIHtcbiAgICAgICAgICAgIGNvcHkgPSBkYXRhO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICAgICAgICAgIGlmIChkYXRhLmhhc093blByb3BlcnR5KGtleSkpIHtcbiAgICAgICAgICAgICAgICAgICAgY29weVtrZXldID0gY2xvbmVPYmplY3QoZGF0YVtrZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAgIHJldHVybiBkYXRhO1xuICAgIH1cbiAgICByZXR1cm4gY29weTtcbn1cblxudmFyIGlzS2V5ID0gKHZhbHVlKSA9PiAvXlxcdyokLy50ZXN0KHZhbHVlKTtcblxudmFyIGlzVW5kZWZpbmVkID0gKHZhbCkgPT4gdmFsID09PSB1bmRlZmluZWQ7XG5cbnZhciBjb21wYWN0ID0gKHZhbHVlKSA9PiBBcnJheS5pc0FycmF5KHZhbHVlKSA/IHZhbHVlLmZpbHRlcihCb29sZWFuKSA6IFtdO1xuXG52YXIgc3RyaW5nVG9QYXRoID0gKGlucHV0KSA9PiBjb21wYWN0KGlucHV0LnJlcGxhY2UoL1tcInwnXXxcXF0vZywgJycpLnNwbGl0KC9cXC58XFxbLykpO1xuXG52YXIgZ2V0ID0gKG9iamVjdCwgcGF0aCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKCFwYXRoIHx8ICFpc09iamVjdChvYmplY3QpKSB7XG4gICAgICAgIHJldHVybiBkZWZhdWx0VmFsdWU7XG4gICAgfVxuICAgIGNvbnN0IHJlc3VsdCA9IChpc0tleShwYXRoKSA/IFtwYXRoXSA6IHN0cmluZ1RvUGF0aChwYXRoKSkucmVkdWNlKChyZXN1bHQsIGtleSkgPT4gaXNOdWxsT3JVbmRlZmluZWQocmVzdWx0KSA/IHJlc3VsdCA6IHJlc3VsdFtrZXldLCBvYmplY3QpO1xuICAgIHJldHVybiBpc1VuZGVmaW5lZChyZXN1bHQpIHx8IHJlc3VsdCA9PT0gb2JqZWN0XG4gICAgICAgID8gaXNVbmRlZmluZWQob2JqZWN0W3BhdGhdKVxuICAgICAgICAgICAgPyBkZWZhdWx0VmFsdWVcbiAgICAgICAgICAgIDogb2JqZWN0W3BhdGhdXG4gICAgICAgIDogcmVzdWx0O1xufTtcblxudmFyIGlzQm9vbGVhbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnYm9vbGVhbic7XG5cbnZhciBzZXQgPSAob2JqZWN0LCBwYXRoLCB2YWx1ZSkgPT4ge1xuICAgIGxldCBpbmRleCA9IC0xO1xuICAgIGNvbnN0IHRlbXBQYXRoID0gaXNLZXkocGF0aCkgPyBbcGF0aF0gOiBzdHJpbmdUb1BhdGgocGF0aCk7XG4gICAgY29uc3QgbGVuZ3RoID0gdGVtcFBhdGgubGVuZ3RoO1xuICAgIGNvbnN0IGxhc3RJbmRleCA9IGxlbmd0aCAtIDE7XG4gICAgd2hpbGUgKCsraW5kZXggPCBsZW5ndGgpIHtcbiAgICAgICAgY29uc3Qga2V5ID0gdGVtcFBhdGhbaW5kZXhdO1xuICAgICAgICBsZXQgbmV3VmFsdWUgPSB2YWx1ZTtcbiAgICAgICAgaWYgKGluZGV4ICE9PSBsYXN0SW5kZXgpIHtcbiAgICAgICAgICAgIGNvbnN0IG9ialZhbHVlID0gb2JqZWN0W2tleV07XG4gICAgICAgICAgICBuZXdWYWx1ZSA9XG4gICAgICAgICAgICAgICAgaXNPYmplY3Qob2JqVmFsdWUpIHx8IEFycmF5LmlzQXJyYXkob2JqVmFsdWUpXG4gICAgICAgICAgICAgICAgICAgID8gb2JqVmFsdWVcbiAgICAgICAgICAgICAgICAgICAgOiAhaXNOYU4oK3RlbXBQYXRoW2luZGV4ICsgMV0pXG4gICAgICAgICAgICAgICAgICAgICAgICA/IFtdXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHt9O1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgPT09ICdfX3Byb3RvX18nIHx8IGtleSA9PT0gJ2NvbnN0cnVjdG9yJyB8fCBrZXkgPT09ICdwcm90b3R5cGUnKSB7XG4gICAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgb2JqZWN0W2tleV0gPSBuZXdWYWx1ZTtcbiAgICAgICAgb2JqZWN0ID0gb2JqZWN0W2tleV07XG4gICAgfVxufTtcblxuY29uc3QgRVZFTlRTID0ge1xuICAgIEJMVVI6ICdibHVyJyxcbiAgICBGT0NVU19PVVQ6ICdmb2N1c291dCcsXG4gICAgQ0hBTkdFOiAnY2hhbmdlJyxcbn07XG5jb25zdCBWQUxJREFUSU9OX01PREUgPSB7XG4gICAgb25CbHVyOiAnb25CbHVyJyxcbiAgICBvbkNoYW5nZTogJ29uQ2hhbmdlJyxcbiAgICBvblN1Ym1pdDogJ29uU3VibWl0JyxcbiAgICBvblRvdWNoZWQ6ICdvblRvdWNoZWQnLFxuICAgIGFsbDogJ2FsbCcsXG59O1xuY29uc3QgSU5QVVRfVkFMSURBVElPTl9SVUxFUyA9IHtcbiAgICBtYXg6ICdtYXgnLFxuICAgIG1pbjogJ21pbicsXG4gICAgbWF4TGVuZ3RoOiAnbWF4TGVuZ3RoJyxcbiAgICBtaW5MZW5ndGg6ICdtaW5MZW5ndGgnLFxuICAgIHBhdHRlcm46ICdwYXR0ZXJuJyxcbiAgICByZXF1aXJlZDogJ3JlcXVpcmVkJyxcbiAgICB2YWxpZGF0ZTogJ3ZhbGlkYXRlJyxcbn07XG5cbmNvbnN0IEhvb2tGb3JtQ29udGV4dCA9IFJlYWN0X19kZWZhdWx0LmNyZWF0ZUNvbnRleHQobnVsbCk7XG5Ib29rRm9ybUNvbnRleHQuZGlzcGxheU5hbWUgPSAnSG9va0Zvcm1Db250ZXh0Jztcbi8qKlxuICogVGhpcyBjdXN0b20gaG9vayBhbGxvd3MgeW91IHRvIGFjY2VzcyB0aGUgZm9ybSBjb250ZXh0LiB1c2VGb3JtQ29udGV4dCBpcyBpbnRlbmRlZCB0byBiZSB1c2VkIGluIGRlZXBseSBuZXN0ZWQgc3RydWN0dXJlcywgd2hlcmUgaXQgd291bGQgYmVjb21lIGluY29udmVuaWVudCB0byBwYXNzIHRoZSBjb250ZXh0IGFzIGEgcHJvcC4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayBGb3JtUHJvdmlkZXJ9LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtY29udGV4dCkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXY3LWZvcm0tY29udGV4dC15dHVkaSlcbiAqXG4gKiBAcmV0dXJucyByZXR1cm4gYWxsIHVzZUZvcm0gbWV0aG9kc1xuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgbWV0aG9kcyA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Rm9ybVByb3ZpZGVyIHsuLi5tZXRob2RzfSA+XG4gKiAgICAgICA8Zm9ybSBvblN1Ym1pdD17bWV0aG9kcy5oYW5kbGVTdWJtaXQob25TdWJtaXQpfT5cbiAqICAgICAgICAgPE5lc3RlZElucHV0IC8+XG4gKiAgICAgICAgIDxpbnB1dCB0eXBlPVwic3VibWl0XCIgLz5cbiAqICAgICAgIDwvZm9ybT5cbiAqICAgICA8L0Zvcm1Qcm92aWRlcj5cbiAqICAgKTtcbiAqIH1cbiAqXG4gKiAgZnVuY3Rpb24gTmVzdGVkSW5wdXQoKSB7XG4gKiAgIGNvbnN0IHsgcmVnaXN0ZXIgfSA9IHVzZUZvcm1Db250ZXh0KCk7IC8vIHJldHJpZXZlIGFsbCBob29rIG1ldGhvZHNcbiAqICAgcmV0dXJuIDxpbnB1dCB7Li4ucmVnaXN0ZXIoXCJ0ZXN0XCIpfSAvPjtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCB1c2VGb3JtQ29udGV4dCA9ICgpID0+IFJlYWN0X19kZWZhdWx0LnVzZUNvbnRleHQoSG9va0Zvcm1Db250ZXh0KTtcbi8qKlxuICogQSBwcm92aWRlciBjb21wb25lbnQgdGhhdCBwcm9wYWdhdGVzIHRoZSBgdXNlRm9ybWAgbWV0aG9kcyB0byBhbGwgY2hpbGRyZW4gY29tcG9uZW50cyB2aWEgW1JlYWN0IENvbnRleHRdKGh0dHBzOi8vcmVhY3Rqcy5vcmcvZG9jcy9jb250ZXh0Lmh0bWwpIEFQSS4gVG8gYmUgdXNlZCB3aXRoIHtAbGluayB1c2VGb3JtQ29udGV4dH0uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1jb250ZXh0KSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tdjctZm9ybS1jb250ZXh0LXl0dWRpKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGFsbCB1c2VGb3JtIG1ldGhvZHNcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBmdW5jdGlvbiBBcHAoKSB7XG4gKiAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtKCk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gZGF0YSA9PiBjb25zb2xlLmxvZyhkYXRhKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm1Qcm92aWRlciB7Li4ubWV0aG9kc30gPlxuICogICAgICAgPGZvcm0gb25TdWJtaXQ9e21ldGhvZHMuaGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICAgIDxOZXN0ZWRJbnB1dCAvPlxuICogICAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgICA8L2Zvcm0+XG4gKiAgICAgPC9Gb3JtUHJvdmlkZXI+XG4gKiAgICk7XG4gKiB9XG4gKlxuICogIGZ1bmN0aW9uIE5lc3RlZElucHV0KCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyIH0gPSB1c2VGb3JtQ29udGV4dCgpOyAvLyByZXRyaWV2ZSBhbGwgaG9vayBtZXRob2RzXG4gKiAgIHJldHVybiA8aW5wdXQgey4uLnJlZ2lzdGVyKFwidGVzdFwiKX0gLz47XG4gKiB9XG4gKiBgYGBcbiAqL1xuY29uc3QgRm9ybVByb3ZpZGVyID0gKHByb3BzKSA9PiB7XG4gICAgY29uc3QgeyBjaGlsZHJlbiwgLi4uZGF0YSB9ID0gcHJvcHM7XG4gICAgcmV0dXJuIChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KEhvb2tGb3JtQ29udGV4dC5Qcm92aWRlciwgeyB2YWx1ZTogZGF0YSB9LCBjaGlsZHJlbikpO1xufTtcblxudmFyIGdldFByb3h5Rm9ybVN0YXRlID0gKGZvcm1TdGF0ZSwgY29udHJvbCwgbG9jYWxQcm94eUZvcm1TdGF0ZSwgaXNSb290ID0gdHJ1ZSkgPT4ge1xuICAgIGNvbnN0IHJlc3VsdCA9IHtcbiAgICAgICAgZGVmYXVsdFZhbHVlczogY29udHJvbC5fZGVmYXVsdFZhbHVlcyxcbiAgICB9O1xuICAgIGZvciAoY29uc3Qga2V5IGluIGZvcm1TdGF0ZSkge1xuICAgICAgICBPYmplY3QuZGVmaW5lUHJvcGVydHkocmVzdWx0LCBrZXksIHtcbiAgICAgICAgICAgIGdldDogKCkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IF9rZXkgPSBrZXk7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldICE9PSBWQUxJREFUSU9OX01PREUuYWxsKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlW19rZXldID0gIWlzUm9vdCB8fCBWQUxJREFUSU9OX01PREUuYWxsO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBsb2NhbFByb3h5Rm9ybVN0YXRlICYmIChsb2NhbFByb3h5Rm9ybVN0YXRlW19rZXldID0gdHJ1ZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGZvcm1TdGF0ZVtfa2V5XTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgIH1cbiAgICByZXR1cm4gcmVzdWx0O1xufTtcblxuY29uc3QgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCA9IHR5cGVvZiB3aW5kb3cgIT09ICd1bmRlZmluZWQnID8gUmVhY3QudXNlTGF5b3V0RWZmZWN0IDogUmVhY3QudXNlRWZmZWN0O1xuXG4vKipcbiAqIFRoaXMgY3VzdG9tIGhvb2sgYWxsb3dzIHlvdSB0byBzdWJzY3JpYmUgdG8gZWFjaCBmb3JtIHN0YXRlLCBhbmQgaXNvbGF0ZSB0aGUgcmUtcmVuZGVyIGF0IHRoZSBjdXN0b20gaG9vayBsZXZlbC4gSXQgaGFzIGl0cyBzY29wZSBpbiB0ZXJtcyBvZiBmb3JtIHN0YXRlIHN1YnNjcmlwdGlvbiwgc28gaXQgd291bGQgbm90IGFmZmVjdCBvdGhlciB1c2VGb3JtU3RhdGUgYW5kIHVzZUZvcm0uIFVzaW5nIHRoaXMgaG9vayBjYW4gcmVkdWNlIHRoZSByZS1yZW5kZXIgaW1wYWN0IG9uIGxhcmdlIGFuZCBjb21wbGV4IGZvcm0gYXBwbGljYXRpb24uXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZvcm1zdGF0ZSkg4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvdXNlZm9ybXN0YXRlLTc1eGx5KVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIGluY2x1ZGUgb3B0aW9ucyBvbiBzcGVjaWZ5IGZpZWxkcyB0byBzdWJzY3JpYmUuIHtAbGluayBVc2VGb3JtU3RhdGVSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIGNvbnRyb2wgfSA9IHVzZUZvcm0oe1xuICogICAgIGRlZmF1bHRWYWx1ZXM6IHtcbiAqICAgICBmaXJzdE5hbWU6IFwiZmlyc3ROYW1lXCJcbiAqICAgfX0pO1xuICogICBjb25zdCB7IGRpcnR5RmllbGRzIH0gPSB1c2VGb3JtU3RhdGUoe1xuICogICAgIGNvbnRyb2xcbiAqICAgfSk7XG4gKiAgIGNvbnN0IG9uU3VibWl0ID0gKGRhdGEpID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KG9uU3VibWl0KX0+XG4gKiAgICAgICA8aW5wdXQgey4uLnJlZ2lzdGVyKFwiZmlyc3ROYW1lXCIpfSBwbGFjZWhvbGRlcj1cIkZpcnN0IE5hbWVcIiAvPlxuICogICAgICAge2RpcnR5RmllbGRzLmZpcnN0TmFtZSAmJiA8cD5GaWVsZCBpcyBkaXJ0eS48L3A+fVxuICogICAgICAgPGlucHV0IHR5cGU9XCJzdWJtaXRcIiAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtU3RhdGUocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIGRpc2FibGVkLCBuYW1lLCBleGFjdCB9ID0gcHJvcHMgfHwge307XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGNvbnRyb2wuX2Zvcm1TdGF0ZSk7XG4gICAgY29uc3QgX2xvY2FsUHJveHlGb3JtU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoe1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgaXNMb2FkaW5nOiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB0b3VjaGVkRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdmFsaWRhdGluZ0ZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH0pO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3Vic2NyaWJlKHtcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZm9ybVN0YXRlOiBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LFxuICAgICAgICBleGFjdCxcbiAgICAgICAgY2FsbGJhY2s6IChmb3JtU3RhdGUpID0+IHtcbiAgICAgICAgICAgICFkaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSh7XG4gICAgICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAgICAgLi4uZm9ybVN0YXRlLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICB9LFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGV4YWN0XSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgX2xvY2FsUHJveHlGb3JtU3RhdGUuY3VycmVudC5pc1ZhbGlkICYmIGNvbnRyb2wuX3NldFZhbGlkKHRydWUpO1xuICAgIH0sIFtjb250cm9sXSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCkgPT4gZ2V0UHJveHlGb3JtU3RhdGUoZm9ybVN0YXRlLCBjb250cm9sLCBfbG9jYWxQcm94eUZvcm1TdGF0ZS5jdXJyZW50LCBmYWxzZSksIFtmb3JtU3RhdGUsIGNvbnRyb2xdKTtcbn1cblxudmFyIGlzU3RyaW5nID0gKHZhbHVlKSA9PiB0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnO1xuXG52YXIgZ2VuZXJhdGVXYXRjaE91dHB1dCA9IChuYW1lcywgX25hbWVzLCBmb3JtVmFsdWVzLCBpc0dsb2JhbCwgZGVmYXVsdFZhbHVlKSA9PiB7XG4gICAgaWYgKGlzU3RyaW5nKG5hbWVzKSkge1xuICAgICAgICBpc0dsb2JhbCAmJiBfbmFtZXMud2F0Y2guYWRkKG5hbWVzKTtcbiAgICAgICAgcmV0dXJuIGdldChmb3JtVmFsdWVzLCBuYW1lcywgZGVmYXVsdFZhbHVlKTtcbiAgICB9XG4gICAgaWYgKEFycmF5LmlzQXJyYXkobmFtZXMpKSB7XG4gICAgICAgIHJldHVybiBuYW1lcy5tYXAoKGZpZWxkTmFtZSkgPT4gKGlzR2xvYmFsICYmIF9uYW1lcy53YXRjaC5hZGQoZmllbGROYW1lKSwgZ2V0KGZvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpKTtcbiAgICB9XG4gICAgaXNHbG9iYWwgJiYgKF9uYW1lcy53YXRjaEFsbCA9IHRydWUpO1xuICAgIHJldHVybiBmb3JtVmFsdWVzO1xufTtcblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBzdWJzY3JpYmUgdG8gZmllbGQgY2hhbmdlIGFuZCBpc29sYXRlIHJlLXJlbmRlcmluZyBhdCB0aGUgY29tcG9uZW50IGxldmVsLlxuICpcbiAqIEByZW1hcmtzXG4gKlxuICogW0FQSV0oaHR0cHM6Ly9yZWFjdC1ob29rLWZvcm0uY29tL2RvY3MvdXNld2F0Y2gpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ny10cy11c2V3YXRjaC1oOWk1ZSlcbiAqXG4gKiBAZXhhbXBsZVxuICogYGBgdHN4XG4gKiBjb25zdCB7IGNvbnRyb2wgfSA9IHVzZUZvcm0oKTtcbiAqIGNvbnN0IHZhbHVlcyA9IHVzZVdhdGNoKHtcbiAqICAgbmFtZTogXCJmaWVsZE5hbWVcIlxuICogICBjb250cm9sLFxuICogfSlcbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VXYXRjaChwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgY29udHJvbCA9IG1ldGhvZHMuY29udHJvbCwgbmFtZSwgZGVmYXVsdFZhbHVlLCBkaXNhYmxlZCwgZXhhY3QsIH0gPSBwcm9wcyB8fCB7fTtcbiAgICBjb25zdCBfZGVmYXVsdFZhbHVlID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgW3ZhbHVlLCB1cGRhdGVWYWx1ZV0gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShjb250cm9sLl9nZXRXYXRjaChuYW1lLCBfZGVmYXVsdFZhbHVlLmN1cnJlbnQpKTtcbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgIG5hbWUsXG4gICAgICAgIGZvcm1TdGF0ZToge1xuICAgICAgICAgICAgdmFsdWVzOiB0cnVlLFxuICAgICAgICB9LFxuICAgICAgICBleGFjdCxcbiAgICAgICAgY2FsbGJhY2s6IChmb3JtU3RhdGUpID0+ICFkaXNhYmxlZCAmJlxuICAgICAgICAgICAgdXBkYXRlVmFsdWUoZ2VuZXJhdGVXYXRjaE91dHB1dChuYW1lLCBjb250cm9sLl9uYW1lcywgZm9ybVN0YXRlLnZhbHVlcyB8fCBjb250cm9sLl9mb3JtVmFsdWVzLCBmYWxzZSwgX2RlZmF1bHRWYWx1ZS5jdXJyZW50KSksXG4gICAgfSksIFtuYW1lLCBjb250cm9sLCBkaXNhYmxlZCwgZXhhY3RdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4gY29udHJvbC5fcmVtb3ZlVW5tb3VudGVkKCkpO1xuICAgIHJldHVybiB2YWx1ZTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byB3b3JrIHdpdGggY29udHJvbGxlZCBjb21wb25lbnQsIHRoaXMgZnVuY3Rpb24gcHJvdmlkZSB5b3Ugd2l0aCBib3RoIGZvcm0gYW5kIGZpZWxkIGxldmVsIHN0YXRlLiBSZS1yZW5kZXIgaXMgaXNvbGF0ZWQgYXQgdGhlIGhvb2sgbGV2ZWwuXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWNvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3VzZWNvbnRyb2xsZXItMG84cHgpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gdGhlIHBhdGggbmFtZSB0byB0aGUgZm9ybSBmaWVsZCB2YWx1ZSwgYW5kIHZhbGlkYXRpb24gcnVsZXMuXG4gKlxuICogQHJldHVybnMgZmllbGQgcHJvcGVydGllcywgZmllbGQgYW5kIGZvcm0gc3RhdGUuIHtAbGluayBVc2VDb250cm9sbGVyUmV0dXJufVxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIElucHV0KHByb3BzKSB7XG4gKiAgIGNvbnN0IHsgZmllbGQsIGZpZWxkU3RhdGUsIGZvcm1TdGF0ZSB9ID0gdXNlQ29udHJvbGxlcihwcm9wcyk7XG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGRpdj5cbiAqICAgICAgIDxpbnB1dCB7Li4uZmllbGR9IHBsYWNlaG9sZGVyPXtwcm9wcy5uYW1lfSAvPlxuICogICAgICAgPHA+e2ZpZWxkU3RhdGUuaXNUb3VjaGVkICYmIFwiVG91Y2hlZFwifTwvcD5cbiAqICAgICAgIDxwPntmb3JtU3RhdGUuaXNTdWJtaXR0ZWQgPyBcInN1Ym1pdHRlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgPC9kaXY+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gdXNlQ29udHJvbGxlcihwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IHsgbmFtZSwgZGlzYWJsZWQsIGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIHNob3VsZFVucmVnaXN0ZXIgfSA9IHByb3BzO1xuICAgIGNvbnN0IGlzQXJyYXlGaWVsZCA9IGlzTmFtZUluRmllbGRBcnJheShjb250cm9sLl9uYW1lcy5hcnJheSwgbmFtZSk7XG4gICAgY29uc3QgdmFsdWUgPSB1c2VXYXRjaCh7XG4gICAgICAgIGNvbnRyb2wsXG4gICAgICAgIG5hbWUsXG4gICAgICAgIGRlZmF1bHRWYWx1ZTogZ2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldChjb250cm9sLl9kZWZhdWx0VmFsdWVzLCBuYW1lLCBwcm9wcy5kZWZhdWx0VmFsdWUpKSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgZm9ybVN0YXRlID0gdXNlRm9ybVN0YXRlKHtcbiAgICAgICAgY29udHJvbCxcbiAgICAgICAgbmFtZSxcbiAgICAgICAgZXhhY3Q6IHRydWUsXG4gICAgfSk7XG4gICAgY29uc3QgX3Byb3BzID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKHByb3BzKTtcbiAgICBjb25zdCBfcmVnaXN0ZXJQcm9wcyA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihjb250cm9sLnJlZ2lzdGVyKG5hbWUsIHtcbiAgICAgICAgLi4ucHJvcHMucnVsZXMsXG4gICAgICAgIHZhbHVlLFxuICAgICAgICAuLi4oaXNCb29sZWFuKHByb3BzLmRpc2FibGVkKSA/IHsgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIH0gOiB7fSksXG4gICAgfSkpO1xuICAgIGNvbnN0IGZpZWxkU3RhdGUgPSBSZWFjdF9fZGVmYXVsdC51c2VNZW1vKCgpID0+IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHt9LCB7XG4gICAgICAgIGludmFsaWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc0RpcnR5OiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUuZGlydHlGaWVsZHMsIG5hbWUpLFxuICAgICAgICB9LFxuICAgICAgICBpc1RvdWNoZWQ6IHtcbiAgICAgICAgICAgIGVudW1lcmFibGU6IHRydWUsXG4gICAgICAgICAgICBnZXQ6ICgpID0+ICEhZ2V0KGZvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSxcbiAgICAgICAgfSxcbiAgICAgICAgaXNWYWxpZGF0aW5nOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiAhIWdldChmb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgICAgIGVycm9yOiB7XG4gICAgICAgICAgICBlbnVtZXJhYmxlOiB0cnVlLFxuICAgICAgICAgICAgZ2V0OiAoKSA9PiBnZXQoZm9ybVN0YXRlLmVycm9ycywgbmFtZSksXG4gICAgICAgIH0sXG4gICAgfSksIFtmb3JtU3RhdGUsIG5hbWVdKTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKChldmVudCkgPT4gX3JlZ2lzdGVyUHJvcHMuY3VycmVudC5vbkNoYW5nZSh7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldEV2ZW50VmFsdWUoZXZlbnQpLFxuICAgICAgICAgICAgbmFtZTogbmFtZSxcbiAgICAgICAgfSxcbiAgICAgICAgdHlwZTogRVZFTlRTLkNIQU5HRSxcbiAgICB9KSwgW25hbWVdKTtcbiAgICBjb25zdCBvbkJsdXIgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygoKSA9PiBfcmVnaXN0ZXJQcm9wcy5jdXJyZW50Lm9uQmx1cih7XG4gICAgICAgIHRhcmdldDoge1xuICAgICAgICAgICAgdmFsdWU6IGdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSxcbiAgICAgICAgICAgIG5hbWU6IG5hbWUsXG4gICAgICAgIH0sXG4gICAgICAgIHR5cGU6IEVWRU5UUy5CTFVSLFxuICAgIH0pLCBbbmFtZSwgY29udHJvbC5fZm9ybVZhbHVlc10pO1xuICAgIGNvbnN0IHJlZiA9IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKChlbG0pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmIGVsbSkge1xuICAgICAgICAgICAgZmllbGQuX2YucmVmID0ge1xuICAgICAgICAgICAgICAgIGZvY3VzOiAoKSA9PiBlbG0uZm9jdXMgJiYgZWxtLmZvY3VzKCksXG4gICAgICAgICAgICAgICAgc2VsZWN0OiAoKSA9PiBlbG0uc2VsZWN0ICYmIGVsbS5zZWxlY3QoKSxcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eTogKG1lc3NhZ2UpID0+IGVsbS5zZXRDdXN0b21WYWxpZGl0eShtZXNzYWdlKSxcbiAgICAgICAgICAgICAgICByZXBvcnRWYWxpZGl0eTogKCkgPT4gZWxtLnJlcG9ydFZhbGlkaXR5KCksXG4gICAgICAgICAgICB9O1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wuX2ZpZWxkcywgbmFtZV0pO1xuICAgIGNvbnN0IGZpZWxkID0gUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKSA9PiAoe1xuICAgICAgICBuYW1lLFxuICAgICAgICB2YWx1ZSxcbiAgICAgICAgLi4uKGlzQm9vbGVhbihkaXNhYmxlZCkgfHwgZm9ybVN0YXRlLmRpc2FibGVkXG4gICAgICAgICAgICA/IHsgZGlzYWJsZWQ6IGZvcm1TdGF0ZS5kaXNhYmxlZCB8fCBkaXNhYmxlZCB9XG4gICAgICAgICAgICA6IHt9KSxcbiAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgIG9uQmx1cixcbiAgICAgICAgcmVmLFxuICAgIH0pLCBbbmFtZSwgZGlzYWJsZWQsIGZvcm1TdGF0ZS5kaXNhYmxlZCwgb25DaGFuZ2UsIG9uQmx1ciwgcmVmLCB2YWx1ZV0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQgPSBjb250cm9sLl9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgfHwgc2hvdWxkVW5yZWdpc3RlcjtcbiAgICAgICAgY29udHJvbC5yZWdpc3RlcihuYW1lLCB7XG4gICAgICAgICAgICAuLi5fcHJvcHMuY3VycmVudC5ydWxlcyxcbiAgICAgICAgICAgIC4uLihpc0Jvb2xlYW4oX3Byb3BzLmN1cnJlbnQuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgPyB7IGRpc2FibGVkOiBfcHJvcHMuY3VycmVudC5kaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgIH0pO1xuICAgICAgICBjb25zdCB1cGRhdGVNb3VudGVkID0gKG5hbWUsIHZhbHVlKSA9PiB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChjb250cm9sLl9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSB2YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgICAgdXBkYXRlTW91bnRlZChuYW1lLCB0cnVlKTtcbiAgICAgICAgaWYgKF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlID0gY2xvbmVPYmplY3QoZ2V0KGNvbnRyb2wuX29wdGlvbnMuZGVmYXVsdFZhbHVlcywgbmFtZSkpO1xuICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2RlZmF1bHRWYWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc1VuZGVmaW5lZChnZXQoY29udHJvbC5fZm9ybVZhbHVlcywgbmFtZSkpKSB7XG4gICAgICAgICAgICAgICAgc2V0KGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICAhaXNBcnJheUZpZWxkICYmIGNvbnRyb2wucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgICAgICAoaXNBcnJheUZpZWxkXG4gICAgICAgICAgICAgICAgPyBfc2hvdWxkVW5yZWdpc3RlckZpZWxkICYmICFjb250cm9sLl9zdGF0ZS5hY3Rpb25cbiAgICAgICAgICAgICAgICA6IF9zaG91bGRVbnJlZ2lzdGVyRmllbGQpXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBpc0FycmF5RmllbGQsIHNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBjb250cm9sLl9zZXREaXNhYmxlZEZpZWxkKHtcbiAgICAgICAgICAgIGRpc2FibGVkLFxuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfSk7XG4gICAgfSwgW2Rpc2FibGVkLCBuYW1lLCBjb250cm9sXSk7XG4gICAgcmV0dXJuIFJlYWN0X19kZWZhdWx0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICAgICAgZmllbGQsXG4gICAgICAgIGZvcm1TdGF0ZSxcbiAgICAgICAgZmllbGRTdGF0ZSxcbiAgICB9KSwgW2ZpZWxkLCBmb3JtU3RhdGUsIGZpZWxkU3RhdGVdKTtcbn1cblxuLyoqXG4gKiBDb21wb25lbnQgYmFzZWQgb24gYHVzZUNvbnRyb2xsZXJgIGhvb2sgdG8gd29yayB3aXRoIGNvbnRyb2xsZWQgY29tcG9uZW50LlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vjb250cm9sbGVyL2NvbnRyb2xsZXIpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS12Ni1jb250cm9sbGVyLXRzLWp3eXp3KSDigKIgW1ZpZGVvXShodHRwczovL3d3dy55b3V0dWJlLmNvbS93YXRjaD92PU4yVU5rX1VDVnlBKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHRoZSBwYXRoIG5hbWUgdG8gdGhlIGZvcm0gZmllbGQgdmFsdWUsIGFuZCB2YWxpZGF0aW9uIHJ1bGVzLlxuICpcbiAqIEByZXR1cm5zIHByb3ZpZGUgZmllbGQgaGFuZGxlciBmdW5jdGlvbnMsIGZpZWxkIGFuZCBmb3JtIHN0YXRlLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyBjb250cm9sIH0gPSB1c2VGb3JtPEZvcm1WYWx1ZXM+KHtcbiAqICAgICBkZWZhdWx0VmFsdWVzOiB7XG4gKiAgICAgICB0ZXN0OiBcIlwiXG4gKiAgICAgfVxuICogICB9KTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0+XG4gKiAgICAgICA8Q29udHJvbGxlclxuICogICAgICAgICBjb250cm9sPXtjb250cm9sfVxuICogICAgICAgICBuYW1lPVwidGVzdFwiXG4gKiAgICAgICAgIHJlbmRlcj17KHsgZmllbGQ6IHsgb25DaGFuZ2UsIG9uQmx1ciwgdmFsdWUsIHJlZiB9LCBmb3JtU3RhdGUsIGZpZWxkU3RhdGUgfSkgPT4gKFxuICogICAgICAgICAgIDw+XG4gKiAgICAgICAgICAgICA8aW5wdXRcbiAqICAgICAgICAgICAgICAgb25DaGFuZ2U9e29uQ2hhbmdlfSAvLyBzZW5kIHZhbHVlIHRvIGhvb2sgZm9ybVxuICogICAgICAgICAgICAgICBvbkJsdXI9e29uQmx1cn0gLy8gbm90aWZ5IHdoZW4gaW5wdXQgaXMgdG91Y2hlZFxuICogICAgICAgICAgICAgICB2YWx1ZT17dmFsdWV9IC8vIHJldHVybiB1cGRhdGVkIHZhbHVlXG4gKiAgICAgICAgICAgICAgIHJlZj17cmVmfSAvLyBzZXQgcmVmIGZvciBmb2N1cyBtYW5hZ2VtZW50XG4gKiAgICAgICAgICAgICAvPlxuICogICAgICAgICAgICAgPHA+e2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCA/IFwic3VibWl0dGVkXCIgOiBcIlwifTwvcD5cbiAqICAgICAgICAgICAgIDxwPntmaWVsZFN0YXRlLmlzVG91Y2hlZCA/IFwidG91Y2hlZFwiIDogXCJcIn08L3A+XG4gKiAgICAgICAgICAgPC8+XG4gKiAgICAgICAgICl9XG4gKiAgICAgICAvPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5jb25zdCBDb250cm9sbGVyID0gKHByb3BzKSA9PiBwcm9wcy5yZW5kZXIodXNlQ29udHJvbGxlcihwcm9wcykpO1xuXG5jb25zdCBmbGF0dGVuID0gKG9iaikgPT4ge1xuICAgIGNvbnN0IG91dHB1dCA9IHt9O1xuICAgIGZvciAoY29uc3Qga2V5IG9mIE9iamVjdC5rZXlzKG9iaikpIHtcbiAgICAgICAgaWYgKGlzT2JqZWN0VHlwZShvYmpba2V5XSkgJiYgb2JqW2tleV0gIT09IG51bGwpIHtcbiAgICAgICAgICAgIGNvbnN0IG5lc3RlZCA9IGZsYXR0ZW4ob2JqW2tleV0pO1xuICAgICAgICAgICAgZm9yIChjb25zdCBuZXN0ZWRLZXkgb2YgT2JqZWN0LmtleXMobmVzdGVkKSkge1xuICAgICAgICAgICAgICAgIG91dHB1dFtgJHtrZXl9LiR7bmVzdGVkS2V5fWBdID0gbmVzdGVkW25lc3RlZEtleV07XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBvdXRwdXRba2V5XSA9IG9ialtrZXldO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBvdXRwdXQ7XG59O1xuXG5jb25zdCBQT1NUX1JFUVVFU1QgPSAncG9zdCc7XG4vKipcbiAqIEZvcm0gY29tcG9uZW50IHRvIG1hbmFnZSBzdWJtaXNzaW9uLlxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHRvIHNldHVwIHN1Ym1pc3Npb24gZGV0YWlsLiB7QGxpbmsgRm9ybVByb3BzfVxuICpcbiAqIEByZXR1cm5zIGZvcm0gY29tcG9uZW50IG9yIGhlYWRsZXNzIHJlbmRlciBwcm9wLlxuICpcbiAqIEBleGFtcGxlXG4gKiBgYGB0c3hcbiAqIGZ1bmN0aW9uIEFwcCgpIHtcbiAqICAgY29uc3QgeyBjb250cm9sLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPEZvcm0gYWN0aW9uPVwiL2FwaVwiIGNvbnRyb2w9e2NvbnRyb2x9PlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcIm5hbWVcIil9IC8+XG4gKiAgICAgICA8cD57ZXJyb3JzPy5yb290Py5zZXJ2ZXIgJiYgJ1NlcnZlciBlcnJvcid9PC9wPlxuICogICAgICAgPGJ1dHRvbj5TdWJtaXQ8L2J1dHRvbj5cbiAqICAgICA8L0Zvcm0+XG4gKiAgICk7XG4gKiB9XG4gKiBgYGBcbiAqL1xuZnVuY3Rpb24gRm9ybShwcm9wcykge1xuICAgIGNvbnN0IG1ldGhvZHMgPSB1c2VGb3JtQ29udGV4dCgpO1xuICAgIGNvbnN0IFttb3VudGVkLCBzZXRNb3VudGVkXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKGZhbHNlKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG9uU3VibWl0LCBjaGlsZHJlbiwgYWN0aW9uLCBtZXRob2QgPSBQT1NUX1JFUVVFU1QsIGhlYWRlcnMsIGVuY1R5cGUsIG9uRXJyb3IsIHJlbmRlciwgb25TdWNjZXNzLCB2YWxpZGF0ZVN0YXR1cywgLi4ucmVzdCB9ID0gcHJvcHM7XG4gICAgY29uc3Qgc3VibWl0ID0gYXN5bmMgKGV2ZW50KSA9PiB7XG4gICAgICAgIGxldCBoYXNFcnJvciA9IGZhbHNlO1xuICAgICAgICBsZXQgdHlwZSA9ICcnO1xuICAgICAgICBhd2FpdCBjb250cm9sLmhhbmRsZVN1Ym1pdChhc3luYyAoZGF0YSkgPT4ge1xuICAgICAgICAgICAgY29uc3QgZm9ybURhdGEgPSBuZXcgRm9ybURhdGEoKTtcbiAgICAgICAgICAgIGxldCBmb3JtRGF0YUpzb24gPSAnJztcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgZm9ybURhdGFKc29uID0gSlNPTi5zdHJpbmdpZnkoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoX2EpIHsgfVxuICAgICAgICAgICAgY29uc3QgZmxhdHRlbkZvcm1WYWx1ZXMgPSBmbGF0dGVuKGNvbnRyb2wuX2Zvcm1WYWx1ZXMpO1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gZmxhdHRlbkZvcm1WYWx1ZXMpIHtcbiAgICAgICAgICAgICAgICBmb3JtRGF0YS5hcHBlbmQoa2V5LCBmbGF0dGVuRm9ybVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChvblN1Ym1pdCkge1xuICAgICAgICAgICAgICAgIGF3YWl0IG9uU3VibWl0KHtcbiAgICAgICAgICAgICAgICAgICAgZGF0YSxcbiAgICAgICAgICAgICAgICAgICAgZXZlbnQsXG4gICAgICAgICAgICAgICAgICAgIG1ldGhvZCxcbiAgICAgICAgICAgICAgICAgICAgZm9ybURhdGEsXG4gICAgICAgICAgICAgICAgICAgIGZvcm1EYXRhSnNvbixcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChhY3Rpb24pIHtcbiAgICAgICAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSA9IFtcbiAgICAgICAgICAgICAgICAgICAgICAgIGhlYWRlcnMgJiYgaGVhZGVyc1snQ29udGVudC1UeXBlJ10sXG4gICAgICAgICAgICAgICAgICAgICAgICBlbmNUeXBlLFxuICAgICAgICAgICAgICAgICAgICBdLnNvbWUoKHZhbHVlKSA9PiB2YWx1ZSAmJiB2YWx1ZS5pbmNsdWRlcygnanNvbicpKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmVzcG9uc2UgPSBhd2FpdCBmZXRjaChTdHJpbmcoYWN0aW9uKSwge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kLFxuICAgICAgICAgICAgICAgICAgICAgICAgaGVhZGVyczoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmhlYWRlcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKGVuY1R5cGUgPyB7ICdDb250ZW50LVR5cGUnOiBlbmNUeXBlIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogc2hvdWxkU3RyaW5naWZ5U3VibWlzc2lvbkRhdGEgPyBmb3JtRGF0YUpzb24gOiBmb3JtRGF0YSxcbiAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXNwb25zZSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgKHZhbGlkYXRlU3RhdHVzXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyAhdmFsaWRhdGVTdGF0dXMocmVzcG9uc2Uuc3RhdHVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVzcG9uc2Uuc3RhdHVzIDwgMjAwIHx8IHJlc3BvbnNlLnN0YXR1cyA+PSAzMDApKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBoYXNFcnJvciA9IHRydWU7XG4gICAgICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgICAgIHR5cGUgPSBTdHJpbmcocmVzcG9uc2Uuc3RhdHVzKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIG9uU3VjY2VzcyAmJiBvblN1Y2Nlc3MoeyByZXNwb25zZSB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgaGFzRXJyb3IgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICBvbkVycm9yICYmIG9uRXJyb3IoeyBlcnJvciB9KTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH0pKGV2ZW50KTtcbiAgICAgICAgaWYgKGhhc0Vycm9yICYmIHByb3BzLmNvbnRyb2wpIHtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzU3VibWl0U3VjY2Vzc2Z1bDogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHByb3BzLmNvbnRyb2wuc2V0RXJyb3IoJ3Jvb3Quc2VydmVyJywge1xuICAgICAgICAgICAgICAgIHR5cGUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgc2V0TW91bnRlZCh0cnVlKTtcbiAgICB9LCBbXSk7XG4gICAgcmV0dXJuIHJlbmRlciA/IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFJlYWN0X19kZWZhdWx0LkZyYWdtZW50LCBudWxsLCByZW5kZXIoe1xuICAgICAgICBzdWJtaXQsXG4gICAgfSkpKSA6IChSZWFjdF9fZGVmYXVsdC5jcmVhdGVFbGVtZW50KFwiZm9ybVwiLCB7IG5vVmFsaWRhdGU6IG1vdW50ZWQsIGFjdGlvbjogYWN0aW9uLCBtZXRob2Q6IG1ldGhvZCwgZW5jVHlwZTogZW5jVHlwZSwgb25TdWJtaXQ6IHN1Ym1pdCwgLi4ucmVzdCB9LCBjaGlsZHJlbikpO1xufVxuXG52YXIgYXBwZW5kRXJyb3JzID0gKG5hbWUsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgZXJyb3JzLCB0eXBlLCBtZXNzYWdlKSA9PiB2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWFcbiAgICA/IHtcbiAgICAgICAgLi4uZXJyb3JzW25hbWVdLFxuICAgICAgICB0eXBlczoge1xuICAgICAgICAgICAgLi4uKGVycm9yc1tuYW1lXSAmJiBlcnJvcnNbbmFtZV0udHlwZXMgPyBlcnJvcnNbbmFtZV0udHlwZXMgOiB7fSksXG4gICAgICAgICAgICBbdHlwZV06IG1lc3NhZ2UgfHwgdHJ1ZSxcbiAgICAgICAgfSxcbiAgICB9XG4gICAgOiB7fTtcblxudmFyIGNvbnZlcnRUb0FycmF5UGF5bG9hZCA9ICh2YWx1ZSkgPT4gKEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUgOiBbdmFsdWVdKTtcblxudmFyIGNyZWF0ZVN1YmplY3QgPSAoKSA9PiB7XG4gICAgbGV0IF9vYnNlcnZlcnMgPSBbXTtcbiAgICBjb25zdCBuZXh0ID0gKHZhbHVlKSA9PiB7XG4gICAgICAgIGZvciAoY29uc3Qgb2JzZXJ2ZXIgb2YgX29ic2VydmVycykge1xuICAgICAgICAgICAgb2JzZXJ2ZXIubmV4dCAmJiBvYnNlcnZlci5uZXh0KHZhbHVlKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3Qgc3Vic2NyaWJlID0gKG9ic2VydmVyKSA9PiB7XG4gICAgICAgIF9vYnNlcnZlcnMucHVzaChvYnNlcnZlcik7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICB1bnN1YnNjcmliZTogKCkgPT4ge1xuICAgICAgICAgICAgICAgIF9vYnNlcnZlcnMgPSBfb2JzZXJ2ZXJzLmZpbHRlcigobykgPT4gbyAhPT0gb2JzZXJ2ZXIpO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gKCkgPT4ge1xuICAgICAgICBfb2JzZXJ2ZXJzID0gW107XG4gICAgfTtcbiAgICByZXR1cm4ge1xuICAgICAgICBnZXQgb2JzZXJ2ZXJzKCkge1xuICAgICAgICAgICAgcmV0dXJuIF9vYnNlcnZlcnM7XG4gICAgICAgIH0sXG4gICAgICAgIG5leHQsXG4gICAgICAgIHN1YnNjcmliZSxcbiAgICAgICAgdW5zdWJzY3JpYmUsXG4gICAgfTtcbn07XG5cbnZhciBpc1ByaW1pdGl2ZSA9ICh2YWx1ZSkgPT4gaXNOdWxsT3JVbmRlZmluZWQodmFsdWUpIHx8ICFpc09iamVjdFR5cGUodmFsdWUpO1xuXG5mdW5jdGlvbiBkZWVwRXF1YWwob2JqZWN0MSwgb2JqZWN0Mikge1xuICAgIGlmIChpc1ByaW1pdGl2ZShvYmplY3QxKSB8fCBpc1ByaW1pdGl2ZShvYmplY3QyKSkge1xuICAgICAgICByZXR1cm4gb2JqZWN0MSA9PT0gb2JqZWN0MjtcbiAgICB9XG4gICAgaWYgKGlzRGF0ZU9iamVjdChvYmplY3QxKSAmJiBpc0RhdGVPYmplY3Qob2JqZWN0MikpIHtcbiAgICAgICAgcmV0dXJuIG9iamVjdDEuZ2V0VGltZSgpID09PSBvYmplY3QyLmdldFRpbWUoKTtcbiAgICB9XG4gICAgY29uc3Qga2V5czEgPSBPYmplY3Qua2V5cyhvYmplY3QxKTtcbiAgICBjb25zdCBrZXlzMiA9IE9iamVjdC5rZXlzKG9iamVjdDIpO1xuICAgIGlmIChrZXlzMS5sZW5ndGggIT09IGtleXMyLmxlbmd0aCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGZvciAoY29uc3Qga2V5IG9mIGtleXMxKSB7XG4gICAgICAgIGNvbnN0IHZhbDEgPSBvYmplY3QxW2tleV07XG4gICAgICAgIGlmICgha2V5czIuaW5jbHVkZXMoa2V5KSkge1xuICAgICAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChrZXkgIT09ICdyZWYnKSB7XG4gICAgICAgICAgICBjb25zdCB2YWwyID0gb2JqZWN0MltrZXldO1xuICAgICAgICAgICAgaWYgKChpc0RhdGVPYmplY3QodmFsMSkgJiYgaXNEYXRlT2JqZWN0KHZhbDIpKSB8fFxuICAgICAgICAgICAgICAgIChpc09iamVjdCh2YWwxKSAmJiBpc09iamVjdCh2YWwyKSkgfHxcbiAgICAgICAgICAgICAgICAoQXJyYXkuaXNBcnJheSh2YWwxKSAmJiBBcnJheS5pc0FycmF5KHZhbDIpKVxuICAgICAgICAgICAgICAgID8gIWRlZXBFcXVhbCh2YWwxLCB2YWwyKVxuICAgICAgICAgICAgICAgIDogdmFsMSAhPT0gdmFsMikge1xuICAgICAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cblxudmFyIGlzRW1wdHlPYmplY3QgPSAodmFsdWUpID0+IGlzT2JqZWN0KHZhbHVlKSAmJiAhT2JqZWN0LmtleXModmFsdWUpLmxlbmd0aDtcblxudmFyIGlzRmlsZUlucHV0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gJ2ZpbGUnO1xuXG52YXIgaXNGdW5jdGlvbiA9ICh2YWx1ZSkgPT4gdHlwZW9mIHZhbHVlID09PSAnZnVuY3Rpb24nO1xuXG52YXIgaXNIVE1MRWxlbWVudCA9ICh2YWx1ZSkgPT4ge1xuICAgIGlmICghaXNXZWIpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBjb25zdCBvd25lciA9IHZhbHVlID8gdmFsdWUub3duZXJEb2N1bWVudCA6IDA7XG4gICAgcmV0dXJuICh2YWx1ZSBpbnN0YW5jZW9mXG4gICAgICAgIChvd25lciAmJiBvd25lci5kZWZhdWx0VmlldyA/IG93bmVyLmRlZmF1bHRWaWV3LkhUTUxFbGVtZW50IDogSFRNTEVsZW1lbnQpKTtcbn07XG5cbnZhciBpc011bHRpcGxlU2VsZWN0ID0gKGVsZW1lbnQpID0+IGVsZW1lbnQudHlwZSA9PT0gYHNlbGVjdC1tdWx0aXBsZWA7XG5cbnZhciBpc1JhZGlvSW5wdXQgPSAoZWxlbWVudCkgPT4gZWxlbWVudC50eXBlID09PSAncmFkaW8nO1xuXG52YXIgaXNSYWRpb09yQ2hlY2tib3ggPSAocmVmKSA9PiBpc1JhZGlvSW5wdXQocmVmKSB8fCBpc0NoZWNrQm94SW5wdXQocmVmKTtcblxudmFyIGxpdmUgPSAocmVmKSA9PiBpc0hUTUxFbGVtZW50KHJlZikgJiYgcmVmLmlzQ29ubmVjdGVkO1xuXG5mdW5jdGlvbiBiYXNlR2V0KG9iamVjdCwgdXBkYXRlUGF0aCkge1xuICAgIGNvbnN0IGxlbmd0aCA9IHVwZGF0ZVBhdGguc2xpY2UoMCwgLTEpLmxlbmd0aDtcbiAgICBsZXQgaW5kZXggPSAwO1xuICAgIHdoaWxlIChpbmRleCA8IGxlbmd0aCkge1xuICAgICAgICBvYmplY3QgPSBpc1VuZGVmaW5lZChvYmplY3QpID8gaW5kZXgrKyA6IG9iamVjdFt1cGRhdGVQYXRoW2luZGV4KytdXTtcbiAgICB9XG4gICAgcmV0dXJuIG9iamVjdDtcbn1cbmZ1bmN0aW9uIGlzRW1wdHlBcnJheShvYmopIHtcbiAgICBmb3IgKGNvbnN0IGtleSBpbiBvYmopIHtcbiAgICAgICAgaWYgKG9iai5oYXNPd25Qcm9wZXJ0eShrZXkpICYmICFpc1VuZGVmaW5lZChvYmpba2V5XSkpIHtcbiAgICAgICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbn1cbmZ1bmN0aW9uIHVuc2V0KG9iamVjdCwgcGF0aCkge1xuICAgIGNvbnN0IHBhdGhzID0gQXJyYXkuaXNBcnJheShwYXRoKVxuICAgICAgICA/IHBhdGhcbiAgICAgICAgOiBpc0tleShwYXRoKVxuICAgICAgICAgICAgPyBbcGF0aF1cbiAgICAgICAgICAgIDogc3RyaW5nVG9QYXRoKHBhdGgpO1xuICAgIGNvbnN0IGNoaWxkT2JqZWN0ID0gcGF0aHMubGVuZ3RoID09PSAxID8gb2JqZWN0IDogYmFzZUdldChvYmplY3QsIHBhdGhzKTtcbiAgICBjb25zdCBpbmRleCA9IHBhdGhzLmxlbmd0aCAtIDE7XG4gICAgY29uc3Qga2V5ID0gcGF0aHNbaW5kZXhdO1xuICAgIGlmIChjaGlsZE9iamVjdCkge1xuICAgICAgICBkZWxldGUgY2hpbGRPYmplY3Rba2V5XTtcbiAgICB9XG4gICAgaWYgKGluZGV4ICE9PSAwICYmXG4gICAgICAgICgoaXNPYmplY3QoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlPYmplY3QoY2hpbGRPYmplY3QpKSB8fFxuICAgICAgICAgICAgKEFycmF5LmlzQXJyYXkoY2hpbGRPYmplY3QpICYmIGlzRW1wdHlBcnJheShjaGlsZE9iamVjdCkpKSkge1xuICAgICAgICB1bnNldChvYmplY3QsIHBhdGhzLnNsaWNlKDAsIC0xKSk7XG4gICAgfVxuICAgIHJldHVybiBvYmplY3Q7XG59XG5cbnZhciBvYmplY3RIYXNGdW5jdGlvbiA9IChkYXRhKSA9PiB7XG4gICAgZm9yIChjb25zdCBrZXkgaW4gZGF0YSkge1xuICAgICAgICBpZiAoaXNGdW5jdGlvbihkYXRhW2tleV0pKSB7XG4gICAgICAgICAgICByZXR1cm4gdHJ1ZTtcbiAgICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gZmFsc2U7XG59O1xuXG5mdW5jdGlvbiBtYXJrRmllbGRzRGlydHkoZGF0YSwgZmllbGRzID0ge30pIHtcbiAgICBjb25zdCBpc1BhcmVudE5vZGVBcnJheSA9IEFycmF5LmlzQXJyYXkoZGF0YSk7XG4gICAgaWYgKGlzT2JqZWN0KGRhdGEpIHx8IGlzUGFyZW50Tm9kZUFycmF5KSB7XG4gICAgICAgIGZvciAoY29uc3Qga2V5IGluIGRhdGEpIHtcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGRhdGFba2V5XSkgfHxcbiAgICAgICAgICAgICAgICAoaXNPYmplY3QoZGF0YVtrZXldKSAmJiAhb2JqZWN0SGFzRnVuY3Rpb24oZGF0YVtrZXldKSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKSA/IFtdIDoge307XG4gICAgICAgICAgICAgICAgbWFya0ZpZWxkc0RpcnR5KGRhdGFba2V5XSwgZmllbGRzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKGRhdGFba2V5XSkpIHtcbiAgICAgICAgICAgICAgICBmaWVsZHNba2V5XSA9IHRydWU7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGZpZWxkcztcbn1cbmZ1bmN0aW9uIGdldERpcnR5RmllbGRzRnJvbURlZmF1bHRWYWx1ZXMoZGF0YSwgZm9ybVZhbHVlcywgZGlydHlGaWVsZHNGcm9tVmFsdWVzKSB7XG4gICAgY29uc3QgaXNQYXJlbnROb2RlQXJyYXkgPSBBcnJheS5pc0FycmF5KGRhdGEpO1xuICAgIGlmIChpc09iamVjdChkYXRhKSB8fCBpc1BhcmVudE5vZGVBcnJheSkge1xuICAgICAgICBmb3IgKGNvbnN0IGtleSBpbiBkYXRhKSB7XG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShkYXRhW2tleV0pIHx8XG4gICAgICAgICAgICAgICAgKGlzT2JqZWN0KGRhdGFba2V5XSkgJiYgIW9iamVjdEhhc0Z1bmN0aW9uKGRhdGFba2V5XSkpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpIHx8XG4gICAgICAgICAgICAgICAgICAgIGlzUHJpbWl0aXZlKGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKSkge1xuICAgICAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9IEFycmF5LmlzQXJyYXkoZGF0YVtrZXldKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyBtYXJrRmllbGRzRGlydHkoZGF0YVtrZXldLCBbXSlcbiAgICAgICAgICAgICAgICAgICAgICAgIDogeyAuLi5tYXJrRmllbGRzRGlydHkoZGF0YVtrZXldKSB9O1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkYXRhW2tleV0sIGlzTnVsbE9yVW5kZWZpbmVkKGZvcm1WYWx1ZXMpID8ge30gOiBmb3JtVmFsdWVzW2tleV0sIGRpcnR5RmllbGRzRnJvbVZhbHVlc1trZXldKTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgICAgICBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXNba2V5XSA9ICFkZWVwRXF1YWwoZGF0YVtrZXldLCBmb3JtVmFsdWVzW2tleV0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBkaXJ0eUZpZWxkc0Zyb21WYWx1ZXM7XG59XG52YXIgZ2V0RGlydHlGaWVsZHMgPSAoZGVmYXVsdFZhbHVlcywgZm9ybVZhbHVlcykgPT4gZ2V0RGlydHlGaWVsZHNGcm9tRGVmYXVsdFZhbHVlcyhkZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzLCBtYXJrRmllbGRzRGlydHkoZm9ybVZhbHVlcykpO1xuXG5jb25zdCBkZWZhdWx0UmVzdWx0ID0ge1xuICAgIHZhbHVlOiBmYWxzZSxcbiAgICBpc1ZhbGlkOiBmYWxzZSxcbn07XG5jb25zdCB2YWxpZFJlc3VsdCA9IHsgdmFsdWU6IHRydWUsIGlzVmFsaWQ6IHRydWUgfTtcbnZhciBnZXRDaGVja2JveFZhbHVlID0gKG9wdGlvbnMpID0+IHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShvcHRpb25zKSkge1xuICAgICAgICBpZiAob3B0aW9ucy5sZW5ndGggPiAxKSB7XG4gICAgICAgICAgICBjb25zdCB2YWx1ZXMgPSBvcHRpb25zXG4gICAgICAgICAgICAgICAgLmZpbHRlcigob3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZClcbiAgICAgICAgICAgICAgICAubWFwKChvcHRpb24pID0+IG9wdGlvbi52YWx1ZSk7XG4gICAgICAgICAgICByZXR1cm4geyB2YWx1ZTogdmFsdWVzLCBpc1ZhbGlkOiAhIXZhbHVlcy5sZW5ndGggfTtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gb3B0aW9uc1swXS5jaGVja2VkICYmICFvcHRpb25zWzBdLmRpc2FibGVkXG4gICAgICAgICAgICA/IC8vIEB0cy1leHBlY3QtZXJyb3IgZXhwZWN0ZWQgdG8gd29yayBpbiB0aGUgYnJvd3NlclxuICAgICAgICAgICAgICAgIG9wdGlvbnNbMF0uYXR0cmlidXRlcyAmJiAhaXNVbmRlZmluZWQob3B0aW9uc1swXS5hdHRyaWJ1dGVzLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA/IGlzVW5kZWZpbmVkKG9wdGlvbnNbMF0udmFsdWUpIHx8IG9wdGlvbnNbMF0udmFsdWUgPT09ICcnXG4gICAgICAgICAgICAgICAgICAgICAgICA/IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICAgICAgICAgICAgICA6IHsgdmFsdWU6IG9wdGlvbnNbMF0udmFsdWUsIGlzVmFsaWQ6IHRydWUgfVxuICAgICAgICAgICAgICAgICAgICA6IHZhbGlkUmVzdWx0XG4gICAgICAgICAgICA6IGRlZmF1bHRSZXN1bHQ7XG4gICAgfVxuICAgIHJldHVybiBkZWZhdWx0UmVzdWx0O1xufTtcblxudmFyIGdldEZpZWxkVmFsdWVBcyA9ICh2YWx1ZSwgeyB2YWx1ZUFzTnVtYmVyLCB2YWx1ZUFzRGF0ZSwgc2V0VmFsdWVBcyB9KSA9PiBpc1VuZGVmaW5lZCh2YWx1ZSlcbiAgICA/IHZhbHVlXG4gICAgOiB2YWx1ZUFzTnVtYmVyXG4gICAgICAgID8gdmFsdWUgPT09ICcnXG4gICAgICAgICAgICA/IE5hTlxuICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICAgICAgICAgID8gK3ZhbHVlXG4gICAgICAgICAgICAgICAgOiB2YWx1ZVxuICAgICAgICA6IHZhbHVlQXNEYXRlICYmIGlzU3RyaW5nKHZhbHVlKVxuICAgICAgICAgICAgPyBuZXcgRGF0ZSh2YWx1ZSlcbiAgICAgICAgICAgIDogc2V0VmFsdWVBc1xuICAgICAgICAgICAgICAgID8gc2V0VmFsdWVBcyh2YWx1ZSlcbiAgICAgICAgICAgICAgICA6IHZhbHVlO1xuXG5jb25zdCBkZWZhdWx0UmV0dXJuID0ge1xuICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgIHZhbHVlOiBudWxsLFxufTtcbnZhciBnZXRSYWRpb1ZhbHVlID0gKG9wdGlvbnMpID0+IEFycmF5LmlzQXJyYXkob3B0aW9ucylcbiAgICA/IG9wdGlvbnMucmVkdWNlKChwcmV2aW91cywgb3B0aW9uKSA9PiBvcHRpb24gJiYgb3B0aW9uLmNoZWNrZWQgJiYgIW9wdGlvbi5kaXNhYmxlZFxuICAgICAgICA/IHtcbiAgICAgICAgICAgIGlzVmFsaWQ6IHRydWUsXG4gICAgICAgICAgICB2YWx1ZTogb3B0aW9uLnZhbHVlLFxuICAgICAgICB9XG4gICAgICAgIDogcHJldmlvdXMsIGRlZmF1bHRSZXR1cm4pXG4gICAgOiBkZWZhdWx0UmV0dXJuO1xuXG5mdW5jdGlvbiBnZXRGaWVsZFZhbHVlKF9mKSB7XG4gICAgY29uc3QgcmVmID0gX2YucmVmO1xuICAgIGlmIChpc0ZpbGVJbnB1dChyZWYpKSB7XG4gICAgICAgIHJldHVybiByZWYuZmlsZXM7XG4gICAgfVxuICAgIGlmIChpc1JhZGlvSW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0UmFkaW9WYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgaWYgKGlzTXVsdGlwbGVTZWxlY3QocmVmKSkge1xuICAgICAgICByZXR1cm4gWy4uLnJlZi5zZWxlY3RlZE9wdGlvbnNdLm1hcCgoeyB2YWx1ZSB9KSA9PiB2YWx1ZSk7XG4gICAgfVxuICAgIGlmIChpc0NoZWNrQm94SW5wdXQocmVmKSkge1xuICAgICAgICByZXR1cm4gZ2V0Q2hlY2tib3hWYWx1ZShfZi5yZWZzKS52YWx1ZTtcbiAgICB9XG4gICAgcmV0dXJuIGdldEZpZWxkVmFsdWVBcyhpc1VuZGVmaW5lZChyZWYudmFsdWUpID8gX2YucmVmLnZhbHVlIDogcmVmLnZhbHVlLCBfZik7XG59XG5cbnZhciBnZXRSZXNvbHZlck9wdGlvbnMgPSAoZmllbGRzTmFtZXMsIF9maWVsZHMsIGNyaXRlcmlhTW9kZSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikgPT4ge1xuICAgIGNvbnN0IGZpZWxkcyA9IHt9O1xuICAgIGZvciAoY29uc3QgbmFtZSBvZiBmaWVsZHNOYW1lcykge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgZmllbGQgJiYgc2V0KGZpZWxkcywgbmFtZSwgZmllbGQuX2YpO1xuICAgIH1cbiAgICByZXR1cm4ge1xuICAgICAgICBjcml0ZXJpYU1vZGUsXG4gICAgICAgIG5hbWVzOiBbLi4uZmllbGRzTmFtZXNdLFxuICAgICAgICBmaWVsZHMsXG4gICAgICAgIHNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sXG4gICAgfTtcbn07XG5cbnZhciBpc1JlZ2V4ID0gKHZhbHVlKSA9PiB2YWx1ZSBpbnN0YW5jZW9mIFJlZ0V4cDtcblxudmFyIGdldFJ1bGVWYWx1ZSA9IChydWxlKSA9PiBpc1VuZGVmaW5lZChydWxlKVxuICAgID8gcnVsZVxuICAgIDogaXNSZWdleChydWxlKVxuICAgICAgICA/IHJ1bGUuc291cmNlXG4gICAgICAgIDogaXNPYmplY3QocnVsZSlcbiAgICAgICAgICAgID8gaXNSZWdleChydWxlLnZhbHVlKVxuICAgICAgICAgICAgICAgID8gcnVsZS52YWx1ZS5zb3VyY2VcbiAgICAgICAgICAgICAgICA6IHJ1bGUudmFsdWVcbiAgICAgICAgICAgIDogcnVsZTtcblxudmFyIGdldFZhbGlkYXRpb25Nb2RlcyA9IChtb2RlKSA9PiAoe1xuICAgIGlzT25TdWJtaXQ6ICFtb2RlIHx8IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblN1Ym1pdCxcbiAgICBpc09uQmx1cjogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLm9uQmx1cixcbiAgICBpc09uQ2hhbmdlOiBtb2RlID09PSBWQUxJREFUSU9OX01PREUub25DaGFuZ2UsXG4gICAgaXNPbkFsbDogbW9kZSA9PT0gVkFMSURBVElPTl9NT0RFLmFsbCxcbiAgICBpc09uVG91Y2g6IG1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5vblRvdWNoZWQsXG59KTtcblxuY29uc3QgQVNZTkNfRlVOQ1RJT04gPSAnQXN5bmNGdW5jdGlvbic7XG52YXIgaGFzUHJvbWlzZVZhbGlkYXRpb24gPSAoZmllbGRSZWZlcmVuY2UpID0+ICEhZmllbGRSZWZlcmVuY2UgJiZcbiAgICAhIWZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlICYmXG4gICAgISEoKGlzRnVuY3Rpb24oZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgIGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSB8fFxuICAgICAgICAoaXNPYmplY3QoZmllbGRSZWZlcmVuY2UudmFsaWRhdGUpICYmXG4gICAgICAgICAgICBPYmplY3QudmFsdWVzKGZpZWxkUmVmZXJlbmNlLnZhbGlkYXRlKS5maW5kKCh2YWxpZGF0ZUZ1bmN0aW9uKSA9PiB2YWxpZGF0ZUZ1bmN0aW9uLmNvbnN0cnVjdG9yLm5hbWUgPT09IEFTWU5DX0ZVTkNUSU9OKSkpO1xuXG52YXIgaGFzVmFsaWRhdGlvbiA9IChvcHRpb25zKSA9PiBvcHRpb25zLm1vdW50ICYmXG4gICAgKG9wdGlvbnMucmVxdWlyZWQgfHxcbiAgICAgICAgb3B0aW9ucy5taW4gfHxcbiAgICAgICAgb3B0aW9ucy5tYXggfHxcbiAgICAgICAgb3B0aW9ucy5tYXhMZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5taW5MZW5ndGggfHxcbiAgICAgICAgb3B0aW9ucy5wYXR0ZXJuIHx8XG4gICAgICAgIG9wdGlvbnMudmFsaWRhdGUpO1xuXG52YXIgaXNXYXRjaGVkID0gKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpID0+ICFpc0JsdXJFdmVudCAmJlxuICAgIChfbmFtZXMud2F0Y2hBbGwgfHxcbiAgICAgICAgX25hbWVzLndhdGNoLmhhcyhuYW1lKSB8fFxuICAgICAgICBbLi4uX25hbWVzLndhdGNoXS5zb21lKCh3YXRjaE5hbWUpID0+IG5hbWUuc3RhcnRzV2l0aCh3YXRjaE5hbWUpICYmXG4gICAgICAgICAgICAvXlxcLlxcdysvLnRlc3QobmFtZS5zbGljZSh3YXRjaE5hbWUubGVuZ3RoKSkpKTtcblxuY29uc3QgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uID0gKGZpZWxkcywgYWN0aW9uLCBmaWVsZHNOYW1lcywgYWJvcnRFYXJseSkgPT4ge1xuICAgIGZvciAoY29uc3Qga2V5IG9mIGZpZWxkc05hbWVzIHx8IE9iamVjdC5rZXlzKGZpZWxkcykpIHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoZmllbGRzLCBrZXkpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmN1cnJlbnRGaWVsZCB9ID0gZmllbGQ7XG4gICAgICAgICAgICBpZiAoX2YpIHtcbiAgICAgICAgICAgICAgICBpZiAoX2YucmVmcyAmJiBfZi5yZWZzWzBdICYmIGFjdGlvbihfZi5yZWZzWzBdLCBrZXkpICYmICFhYm9ydEVhcmx5KSB7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiB0cnVlO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBlbHNlIGlmIChfZi5yZWYgJiYgYWN0aW9uKF9mLnJlZiwgX2YubmFtZSkgJiYgIWFib3J0RWFybHkpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGN1cnJlbnRGaWVsZCwgYWN0aW9uKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChpc09iamVjdChjdXJyZW50RmllbGQpKSB7XG4gICAgICAgICAgICAgICAgaWYgKGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihjdXJyZW50RmllbGQsIGFjdGlvbikpIHtcbiAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybjtcbn07XG5cbmZ1bmN0aW9uIHNjaGVtYUVycm9yTG9va3VwKGVycm9ycywgX2ZpZWxkcywgbmFtZSkge1xuICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgaWYgKGVycm9yIHx8IGlzS2V5KG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICBlcnJvcixcbiAgICAgICAgICAgIG5hbWUsXG4gICAgICAgIH07XG4gICAgfVxuICAgIGNvbnN0IG5hbWVzID0gbmFtZS5zcGxpdCgnLicpO1xuICAgIHdoaWxlIChuYW1lcy5sZW5ndGgpIHtcbiAgICAgICAgY29uc3QgZmllbGROYW1lID0gbmFtZXMuam9pbignLicpO1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICBjb25zdCBmb3VuZEVycm9yID0gZ2V0KGVycm9ycywgZmllbGROYW1lKTtcbiAgICAgICAgaWYgKGZpZWxkICYmICFBcnJheS5pc0FycmF5KGZpZWxkKSAmJiBuYW1lICE9PSBmaWVsZE5hbWUpIHtcbiAgICAgICAgICAgIHJldHVybiB7IG5hbWUgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogZmllbGROYW1lLFxuICAgICAgICAgICAgICAgIGVycm9yOiBmb3VuZEVycm9yLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoZm91bmRFcnJvciAmJiBmb3VuZEVycm9yLnJvb3QgJiYgZm91bmRFcnJvci5yb290LnR5cGUpIHtcbiAgICAgICAgICAgIHJldHVybiB7XG4gICAgICAgICAgICAgICAgbmFtZTogYCR7ZmllbGROYW1lfS5yb290YCxcbiAgICAgICAgICAgICAgICBlcnJvcjogZm91bmRFcnJvci5yb290LFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgICBuYW1lcy5wb3AoKTtcbiAgICB9XG4gICAgcmV0dXJuIHtcbiAgICAgICAgbmFtZSxcbiAgICB9O1xufVxuXG52YXIgc2hvdWxkUmVuZGVyRm9ybVN0YXRlID0gKGZvcm1TdGF0ZURhdGEsIF9wcm94eUZvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlLCBpc1Jvb3QpID0+IHtcbiAgICB1cGRhdGVGb3JtU3RhdGUoZm9ybVN0YXRlRGF0YSk7XG4gICAgY29uc3QgeyBuYW1lLCAuLi5mb3JtU3RhdGUgfSA9IGZvcm1TdGF0ZURhdGE7XG4gICAgcmV0dXJuIChpc0VtcHR5T2JqZWN0KGZvcm1TdGF0ZSkgfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5sZW5ndGggPj0gT2JqZWN0LmtleXMoX3Byb3h5Rm9ybVN0YXRlKS5sZW5ndGggfHxcbiAgICAgICAgT2JqZWN0LmtleXMoZm9ybVN0YXRlKS5maW5kKChrZXkpID0+IF9wcm94eUZvcm1TdGF0ZVtrZXldID09PVxuICAgICAgICAgICAgKCFpc1Jvb3QgfHwgVkFMSURBVElPTl9NT0RFLmFsbCkpKTtcbn07XG5cbnZhciBzaG91bGRTdWJzY3JpYmVCeU5hbWUgPSAobmFtZSwgc2lnbmFsTmFtZSwgZXhhY3QpID0+ICFuYW1lIHx8XG4gICAgIXNpZ25hbE5hbWUgfHxcbiAgICBuYW1lID09PSBzaWduYWxOYW1lIHx8XG4gICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLnNvbWUoKGN1cnJlbnROYW1lKSA9PiBjdXJyZW50TmFtZSAmJlxuICAgICAgICAoZXhhY3RcbiAgICAgICAgICAgID8gY3VycmVudE5hbWUgPT09IHNpZ25hbE5hbWVcbiAgICAgICAgICAgIDogY3VycmVudE5hbWUuc3RhcnRzV2l0aChzaWduYWxOYW1lKSB8fFxuICAgICAgICAgICAgICAgIHNpZ25hbE5hbWUuc3RhcnRzV2l0aChjdXJyZW50TmFtZSkpKTtcblxudmFyIHNraXBWYWxpZGF0aW9uID0gKGlzQmx1ckV2ZW50LCBpc1RvdWNoZWQsIGlzU3VibWl0dGVkLCByZVZhbGlkYXRlTW9kZSwgbW9kZSkgPT4ge1xuICAgIGlmIChtb2RlLmlzT25BbGwpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIGlmICghaXNTdWJtaXR0ZWQgJiYgbW9kZS5pc09uVG91Y2gpIHtcbiAgICAgICAgcmV0dXJuICEoaXNUb3VjaGVkIHx8IGlzQmx1ckV2ZW50KTtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQmx1ciA6IG1vZGUuaXNPbkJsdXIpIHtcbiAgICAgICAgcmV0dXJuICFpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgZWxzZSBpZiAoaXNTdWJtaXR0ZWQgPyByZVZhbGlkYXRlTW9kZS5pc09uQ2hhbmdlIDogbW9kZS5pc09uQ2hhbmdlKSB7XG4gICAgICAgIHJldHVybiBpc0JsdXJFdmVudDtcbiAgICB9XG4gICAgcmV0dXJuIHRydWU7XG59O1xuXG52YXIgdW5zZXRFbXB0eUFycmF5ID0gKHJlZiwgbmFtZSkgPT4gIWNvbXBhY3QoZ2V0KHJlZiwgbmFtZSkpLmxlbmd0aCAmJiB1bnNldChyZWYsIG5hbWUpO1xuXG52YXIgdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvciA9IChlcnJvcnMsIGVycm9yLCBuYW1lKSA9PiB7XG4gICAgY29uc3QgZmllbGRBcnJheUVycm9ycyA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChnZXQoZXJyb3JzLCBuYW1lKSk7XG4gICAgc2V0KGZpZWxkQXJyYXlFcnJvcnMsICdyb290JywgZXJyb3JbbmFtZV0pO1xuICAgIHNldChlcnJvcnMsIG5hbWUsIGZpZWxkQXJyYXlFcnJvcnMpO1xuICAgIHJldHVybiBlcnJvcnM7XG59O1xuXG52YXIgaXNNZXNzYWdlID0gKHZhbHVlKSA9PiBpc1N0cmluZyh2YWx1ZSk7XG5cbmZ1bmN0aW9uIGdldFZhbGlkYXRlRXJyb3IocmVzdWx0LCByZWYsIHR5cGUgPSAndmFsaWRhdGUnKSB7XG4gICAgaWYgKGlzTWVzc2FnZShyZXN1bHQpIHx8XG4gICAgICAgIChBcnJheS5pc0FycmF5KHJlc3VsdCkgJiYgcmVzdWx0LmV2ZXJ5KGlzTWVzc2FnZSkpIHx8XG4gICAgICAgIChpc0Jvb2xlYW4ocmVzdWx0KSAmJiAhcmVzdWx0KSkge1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgICAgdHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2U6IGlzTWVzc2FnZShyZXN1bHQpID8gcmVzdWx0IDogJycsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgIH07XG4gICAgfVxufVxuXG52YXIgZ2V0VmFsdWVBbmRNZXNzYWdlID0gKHZhbGlkYXRpb25EYXRhKSA9PiBpc09iamVjdCh2YWxpZGF0aW9uRGF0YSkgJiYgIWlzUmVnZXgodmFsaWRhdGlvbkRhdGEpXG4gICAgPyB2YWxpZGF0aW9uRGF0YVxuICAgIDoge1xuICAgICAgICB2YWx1ZTogdmFsaWRhdGlvbkRhdGEsXG4gICAgICAgIG1lc3NhZ2U6ICcnLFxuICAgIH07XG5cbnZhciB2YWxpZGF0ZUZpZWxkID0gYXN5bmMgKGZpZWxkLCBkaXNhYmxlZEZpZWxkTmFtZXMsIGZvcm1WYWx1ZXMsIHZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSwgc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiwgaXNGaWVsZEFycmF5KSA9PiB7XG4gICAgY29uc3QgeyByZWYsIHJlZnMsIHJlcXVpcmVkLCBtYXhMZW5ndGgsIG1pbkxlbmd0aCwgbWluLCBtYXgsIHBhdHRlcm4sIHZhbGlkYXRlLCBuYW1lLCB2YWx1ZUFzTnVtYmVyLCBtb3VudCwgfSA9IGZpZWxkLl9mO1xuICAgIGNvbnN0IGlucHV0VmFsdWUgPSBnZXQoZm9ybVZhbHVlcywgbmFtZSk7XG4gICAgaWYgKCFtb3VudCB8fCBkaXNhYmxlZEZpZWxkTmFtZXMuaGFzKG5hbWUpKSB7XG4gICAgICAgIHJldHVybiB7fTtcbiAgICB9XG4gICAgY29uc3QgaW5wdXRSZWYgPSByZWZzID8gcmVmc1swXSA6IHJlZjtcbiAgICBjb25zdCBzZXRDdXN0b21WYWxpZGl0eSA9IChtZXNzYWdlKSA9PiB7XG4gICAgICAgIGlmIChzaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uICYmIGlucHV0UmVmLnJlcG9ydFZhbGlkaXR5KSB7XG4gICAgICAgICAgICBpbnB1dFJlZi5zZXRDdXN0b21WYWxpZGl0eShpc0Jvb2xlYW4obWVzc2FnZSkgPyAnJyA6IG1lc3NhZ2UgfHwgJycpO1xuICAgICAgICAgICAgaW5wdXRSZWYucmVwb3J0VmFsaWRpdHkoKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgZXJyb3IgPSB7fTtcbiAgICBjb25zdCBpc1JhZGlvID0gaXNSYWRpb0lucHV0KHJlZik7XG4gICAgY29uc3QgaXNDaGVja0JveCA9IGlzQ2hlY2tCb3hJbnB1dChyZWYpO1xuICAgIGNvbnN0IGlzUmFkaW9PckNoZWNrYm94ID0gaXNSYWRpbyB8fCBpc0NoZWNrQm94O1xuICAgIGNvbnN0IGlzRW1wdHkgPSAoKHZhbHVlQXNOdW1iZXIgfHwgaXNGaWxlSW5wdXQocmVmKSkgJiZcbiAgICAgICAgaXNVbmRlZmluZWQocmVmLnZhbHVlKSAmJlxuICAgICAgICBpc1VuZGVmaW5lZChpbnB1dFZhbHVlKSkgfHxcbiAgICAgICAgKGlzSFRNTEVsZW1lbnQocmVmKSAmJiByZWYudmFsdWUgPT09ICcnKSB8fFxuICAgICAgICBpbnB1dFZhbHVlID09PSAnJyB8fFxuICAgICAgICAoQXJyYXkuaXNBcnJheShpbnB1dFZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5sZW5ndGgpO1xuICAgIGNvbnN0IGFwcGVuZEVycm9yc0N1cnJ5ID0gYXBwZW5kRXJyb3JzLmJpbmQobnVsbCwgbmFtZSwgdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhLCBlcnJvcik7XG4gICAgY29uc3QgZ2V0TWluTWF4TWVzc2FnZSA9IChleGNlZWRNYXgsIG1heExlbmd0aE1lc3NhZ2UsIG1pbkxlbmd0aE1lc3NhZ2UsIG1heFR5cGUgPSBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heExlbmd0aCwgbWluVHlwZSA9IElOUFVUX1ZBTElEQVRJT05fUlVMRVMubWluTGVuZ3RoKSA9PiB7XG4gICAgICAgIGNvbnN0IG1lc3NhZ2UgPSBleGNlZWRNYXggPyBtYXhMZW5ndGhNZXNzYWdlIDogbWluTGVuZ3RoTWVzc2FnZTtcbiAgICAgICAgZXJyb3JbbmFtZV0gPSB7XG4gICAgICAgICAgICB0eXBlOiBleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSxcbiAgICAgICAgICAgIG1lc3NhZ2UsXG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShleGNlZWRNYXggPyBtYXhUeXBlIDogbWluVHlwZSwgbWVzc2FnZSksXG4gICAgICAgIH07XG4gICAgfTtcbiAgICBpZiAoaXNGaWVsZEFycmF5XG4gICAgICAgID8gIUFycmF5LmlzQXJyYXkoaW5wdXRWYWx1ZSkgfHwgIWlucHV0VmFsdWUubGVuZ3RoXG4gICAgICAgIDogcmVxdWlyZWQgJiZcbiAgICAgICAgICAgICgoIWlzUmFkaW9PckNoZWNrYm94ICYmIChpc0VtcHR5IHx8IGlzTnVsbE9yVW5kZWZpbmVkKGlucHV0VmFsdWUpKSkgfHxcbiAgICAgICAgICAgICAgICAoaXNCb29sZWFuKGlucHV0VmFsdWUpICYmICFpbnB1dFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChpc0NoZWNrQm94ICYmICFnZXRDaGVja2JveFZhbHVlKHJlZnMpLmlzVmFsaWQpIHx8XG4gICAgICAgICAgICAgICAgKGlzUmFkaW8gJiYgIWdldFJhZGlvVmFsdWUocmVmcykuaXNWYWxpZCkpKSB7XG4gICAgICAgIGNvbnN0IHsgdmFsdWUsIG1lc3NhZ2UgfSA9IGlzTWVzc2FnZShyZXF1aXJlZClcbiAgICAgICAgICAgID8geyB2YWx1ZTogISFyZXF1aXJlZCwgbWVzc2FnZTogcmVxdWlyZWQgfVxuICAgICAgICAgICAgOiBnZXRWYWx1ZUFuZE1lc3NhZ2UocmVxdWlyZWQpO1xuICAgICAgICBpZiAodmFsdWUpIHtcbiAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgIHR5cGU6IElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgIC4uLmFwcGVuZEVycm9yc0N1cnJ5KElOUFVUX1ZBTElEQVRJT05fUlVMRVMucmVxdWlyZWQsIG1lc3NhZ2UpLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgc2V0Q3VzdG9tVmFsaWRpdHkobWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfVxuICAgIGlmICghaXNFbXB0eSAmJiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1pbikgfHwgIWlzTnVsbE9yVW5kZWZpbmVkKG1heCkpKSB7XG4gICAgICAgIGxldCBleGNlZWRNYXg7XG4gICAgICAgIGxldCBleGNlZWRNaW47XG4gICAgICAgIGNvbnN0IG1heE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtYXgpO1xuICAgICAgICBjb25zdCBtaW5PdXRwdXQgPSBnZXRWYWx1ZUFuZE1lc3NhZ2UobWluKTtcbiAgICAgICAgaWYgKCFpc051bGxPclVuZGVmaW5lZChpbnB1dFZhbHVlKSAmJiAhaXNOYU4oaW5wdXRWYWx1ZSkpIHtcbiAgICAgICAgICAgIGNvbnN0IHZhbHVlTnVtYmVyID0gcmVmLnZhbHVlQXNOdW1iZXIgfHxcbiAgICAgICAgICAgICAgICAoaW5wdXRWYWx1ZSA/ICtpbnB1dFZhbHVlIDogaW5wdXRWYWx1ZSk7XG4gICAgICAgICAgICBpZiAoIWlzTnVsbE9yVW5kZWZpbmVkKG1heE91dHB1dC52YWx1ZSkpIHtcbiAgICAgICAgICAgICAgICBleGNlZWRNYXggPSB2YWx1ZU51bWJlciA+IG1heE91dHB1dC52YWx1ZTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNOdWxsT3JVbmRlZmluZWQobWluT3V0cHV0LnZhbHVlKSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1pbiA9IHZhbHVlTnVtYmVyIDwgbWluT3V0cHV0LnZhbHVlO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29uc3QgdmFsdWVEYXRlID0gcmVmLnZhbHVlQXNEYXRlIHx8IG5ldyBEYXRlKGlucHV0VmFsdWUpO1xuICAgICAgICAgICAgY29uc3QgY29udmVydFRpbWVUb0RhdGUgPSAodGltZSkgPT4gbmV3IERhdGUobmV3IERhdGUoKS50b0RhdGVTdHJpbmcoKSArICcgJyArIHRpbWUpO1xuICAgICAgICAgICAgY29uc3QgaXNUaW1lID0gcmVmLnR5cGUgPT0gJ3RpbWUnO1xuICAgICAgICAgICAgY29uc3QgaXNXZWVrID0gcmVmLnR5cGUgPT0gJ3dlZWsnO1xuICAgICAgICAgICAgaWYgKGlzU3RyaW5nKG1heE91dHB1dC52YWx1ZSkgJiYgaW5wdXRWYWx1ZSkge1xuICAgICAgICAgICAgICAgIGV4Y2VlZE1heCA9IGlzVGltZVxuICAgICAgICAgICAgICAgICAgICA/IGNvbnZlcnRUaW1lVG9EYXRlKGlucHV0VmFsdWUpID4gY29udmVydFRpbWVUb0RhdGUobWF4T3V0cHV0LnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICA6IGlzV2Vla1xuICAgICAgICAgICAgICAgICAgICAgICAgPyBpbnB1dFZhbHVlID4gbWF4T3V0cHV0LnZhbHVlXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHZhbHVlRGF0ZSA+IG5ldyBEYXRlKG1heE91dHB1dC52YWx1ZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNTdHJpbmcobWluT3V0cHV0LnZhbHVlKSAmJiBpbnB1dFZhbHVlKSB7XG4gICAgICAgICAgICAgICAgZXhjZWVkTWluID0gaXNUaW1lXG4gICAgICAgICAgICAgICAgICAgID8gY29udmVydFRpbWVUb0RhdGUoaW5wdXRWYWx1ZSkgPCBjb252ZXJ0VGltZVRvRGF0ZShtaW5PdXRwdXQudmFsdWUpXG4gICAgICAgICAgICAgICAgICAgIDogaXNXZWVrXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGlucHV0VmFsdWUgPCBtaW5PdXRwdXQudmFsdWVcbiAgICAgICAgICAgICAgICAgICAgICAgIDogdmFsdWVEYXRlIDwgbmV3IERhdGUobWluT3V0cHV0LnZhbHVlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZSghIWV4Y2VlZE1heCwgbWF4T3V0cHV0Lm1lc3NhZ2UsIG1pbk91dHB1dC5tZXNzYWdlLCBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLm1heCwgSU5QVVRfVkFMSURBVElPTl9SVUxFUy5taW4pO1xuICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICBzZXRDdXN0b21WYWxpZGl0eShlcnJvcltuYW1lXS5tZXNzYWdlKTtcbiAgICAgICAgICAgICAgICByZXR1cm4gZXJyb3I7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICB9XG4gICAgaWYgKChtYXhMZW5ndGggfHwgbWluTGVuZ3RoKSAmJlxuICAgICAgICAhaXNFbXB0eSAmJlxuICAgICAgICAoaXNTdHJpbmcoaW5wdXRWYWx1ZSkgfHwgKGlzRmllbGRBcnJheSAmJiBBcnJheS5pc0FycmF5KGlucHV0VmFsdWUpKSkpIHtcbiAgICAgICAgY29uc3QgbWF4TGVuZ3RoT3V0cHV0ID0gZ2V0VmFsdWVBbmRNZXNzYWdlKG1heExlbmd0aCk7XG4gICAgICAgIGNvbnN0IG1pbkxlbmd0aE91dHB1dCA9IGdldFZhbHVlQW5kTWVzc2FnZShtaW5MZW5ndGgpO1xuICAgICAgICBjb25zdCBleGNlZWRNYXggPSAhaXNOdWxsT3JVbmRlZmluZWQobWF4TGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPiArbWF4TGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBjb25zdCBleGNlZWRNaW4gPSAhaXNOdWxsT3JVbmRlZmluZWQobWluTGVuZ3RoT3V0cHV0LnZhbHVlKSAmJlxuICAgICAgICAgICAgaW5wdXRWYWx1ZS5sZW5ndGggPCArbWluTGVuZ3RoT3V0cHV0LnZhbHVlO1xuICAgICAgICBpZiAoZXhjZWVkTWF4IHx8IGV4Y2VlZE1pbikge1xuICAgICAgICAgICAgZ2V0TWluTWF4TWVzc2FnZShleGNlZWRNYXgsIG1heExlbmd0aE91dHB1dC5tZXNzYWdlLCBtaW5MZW5ndGhPdXRwdXQubWVzc2FnZSk7XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KGVycm9yW25hbWVdLm1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAocGF0dGVybiAmJiAhaXNFbXB0eSAmJiBpc1N0cmluZyhpbnB1dFZhbHVlKSkge1xuICAgICAgICBjb25zdCB7IHZhbHVlOiBwYXR0ZXJuVmFsdWUsIG1lc3NhZ2UgfSA9IGdldFZhbHVlQW5kTWVzc2FnZShwYXR0ZXJuKTtcbiAgICAgICAgaWYgKGlzUmVnZXgocGF0dGVyblZhbHVlKSAmJiAhaW5wdXRWYWx1ZS5tYXRjaChwYXR0ZXJuVmFsdWUpKSB7XG4gICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICB0eXBlOiBJTlBVVF9WQUxJREFUSU9OX1JVTEVTLnBhdHRlcm4sXG4gICAgICAgICAgICAgICAgbWVzc2FnZSxcbiAgICAgICAgICAgICAgICByZWYsXG4gICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy5wYXR0ZXJuLCBtZXNzYWdlKSxcbiAgICAgICAgICAgIH07XG4gICAgICAgICAgICBpZiAoIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KG1lc3NhZ2UpO1xuICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBpZiAodmFsaWRhdGUpIHtcbiAgICAgICAgaWYgKGlzRnVuY3Rpb24odmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBjb25zdCByZXN1bHQgPSBhd2FpdCB2YWxpZGF0ZShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIGNvbnN0IHZhbGlkYXRlRXJyb3IgPSBnZXRWYWxpZGF0ZUVycm9yKHJlc3VsdCwgaW5wdXRSZWYpO1xuICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICBlcnJvcltuYW1lXSA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4udmFsaWRhdGVFcnJvcixcbiAgICAgICAgICAgICAgICAgICAgLi4uYXBwZW5kRXJyb3JzQ3VycnkoSU5QVVRfVkFMSURBVElPTl9SVUxFUy52YWxpZGF0ZSwgdmFsaWRhdGVFcnJvci5tZXNzYWdlKSxcbiAgICAgICAgICAgICAgICB9O1xuICAgICAgICAgICAgICAgIGlmICghdmFsaWRhdGVBbGxGaWVsZENyaXRlcmlhKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBlcnJvcjtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoaXNPYmplY3QodmFsaWRhdGUpKSB7XG4gICAgICAgICAgICBsZXQgdmFsaWRhdGlvblJlc3VsdCA9IHt9O1xuICAgICAgICAgICAgZm9yIChjb25zdCBrZXkgaW4gdmFsaWRhdGUpIHtcbiAgICAgICAgICAgICAgICBpZiAoIWlzRW1wdHlPYmplY3QodmFsaWRhdGlvblJlc3VsdCkgJiYgIXZhbGlkYXRlQWxsRmllbGRDcml0ZXJpYSkge1xuICAgICAgICAgICAgICAgICAgICBicmVhaztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgdmFsaWRhdGVFcnJvciA9IGdldFZhbGlkYXRlRXJyb3IoYXdhaXQgdmFsaWRhdGVba2V5XShpbnB1dFZhbHVlLCBmb3JtVmFsdWVzKSwgaW5wdXRSZWYsIGtleSk7XG4gICAgICAgICAgICAgICAgaWYgKHZhbGlkYXRlRXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGlvblJlc3VsdCA9IHtcbiAgICAgICAgICAgICAgICAgICAgICAgIC4uLnZhbGlkYXRlRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgICAgICAuLi5hcHBlbmRFcnJvcnNDdXJyeShrZXksIHZhbGlkYXRlRXJyb3IubWVzc2FnZSksXG4gICAgICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgICAgIHNldEN1c3RvbVZhbGlkaXR5KHZhbGlkYXRlRXJyb3IubWVzc2FnZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmICh2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0gdmFsaWRhdGlvblJlc3VsdDtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghaXNFbXB0eU9iamVjdCh2YWxpZGF0aW9uUmVzdWx0KSkge1xuICAgICAgICAgICAgICAgIGVycm9yW25hbWVdID0ge1xuICAgICAgICAgICAgICAgICAgICByZWY6IGlucHV0UmVmLFxuICAgICAgICAgICAgICAgICAgICAuLi52YWxpZGF0aW9uUmVzdWx0LFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICAgICAgaWYgKCF2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEpIHtcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGVycm9yO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cbiAgICBzZXRDdXN0b21WYWxpZGl0eSh0cnVlKTtcbiAgICByZXR1cm4gZXJyb3I7XG59O1xuXG5jb25zdCBkZWZhdWx0T3B0aW9ucyA9IHtcbiAgICBtb2RlOiBWQUxJREFUSU9OX01PREUub25TdWJtaXQsXG4gICAgcmVWYWxpZGF0ZU1vZGU6IFZBTElEQVRJT05fTU9ERS5vbkNoYW5nZSxcbiAgICBzaG91bGRGb2N1c0Vycm9yOiB0cnVlLFxufTtcbmZ1bmN0aW9uIGNyZWF0ZUZvcm1Db250cm9sKHByb3BzID0ge30pIHtcbiAgICBsZXQgX29wdGlvbnMgPSB7XG4gICAgICAgIC4uLmRlZmF1bHRPcHRpb25zLFxuICAgICAgICAuLi5wcm9wcyxcbiAgICB9O1xuICAgIGxldCBfZm9ybVN0YXRlID0ge1xuICAgICAgICBzdWJtaXRDb3VudDogMCxcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzUmVhZHk6IGZhbHNlLFxuICAgICAgICBpc0xvYWRpbmc6IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcyksXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzU3VibWl0dGVkOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXR0aW5nOiBmYWxzZSxcbiAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBmYWxzZSxcbiAgICAgICAgaXNWYWxpZDogZmFsc2UsXG4gICAgICAgIHRvdWNoZWRGaWVsZHM6IHt9LFxuICAgICAgICBkaXJ0eUZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IF9vcHRpb25zLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IF9vcHRpb25zLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgIH07XG4gICAgY29uc3QgX2ZpZWxkcyA9IHt9O1xuICAgIGxldCBfZGVmYXVsdFZhbHVlcyA9IGlzT2JqZWN0KF9vcHRpb25zLmRlZmF1bHRWYWx1ZXMpIHx8IGlzT2JqZWN0KF9vcHRpb25zLnZhbHVlcylcbiAgICAgICAgPyBjbG9uZU9iamVjdChfb3B0aW9ucy5kZWZhdWx0VmFsdWVzIHx8IF9vcHRpb25zLnZhbHVlcykgfHwge31cbiAgICAgICAgOiB7fTtcbiAgICBsZXQgX2Zvcm1WYWx1ZXMgPSBfb3B0aW9ucy5zaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgID8ge31cbiAgICAgICAgOiBjbG9uZU9iamVjdChfZGVmYXVsdFZhbHVlcyk7XG4gICAgbGV0IF9zdGF0ZSA9IHtcbiAgICAgICAgYWN0aW9uOiBmYWxzZSxcbiAgICAgICAgbW91bnQ6IGZhbHNlLFxuICAgICAgICB3YXRjaDogZmFsc2UsXG4gICAgfTtcbiAgICBsZXQgX25hbWVzID0ge1xuICAgICAgICBtb3VudDogbmV3IFNldCgpLFxuICAgICAgICBkaXNhYmxlZDogbmV3IFNldCgpLFxuICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgIGFycmF5OiBuZXcgU2V0KCksXG4gICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgfTtcbiAgICBsZXQgZGVsYXlFcnJvckNhbGxiYWNrO1xuICAgIGxldCB0aW1lciA9IDA7XG4gICAgY29uc3QgX3Byb3h5Rm9ybVN0YXRlID0ge1xuICAgICAgICBpc0RpcnR5OiBmYWxzZSxcbiAgICAgICAgZGlydHlGaWVsZHM6IGZhbHNlLFxuICAgICAgICB2YWxpZGF0aW5nRmllbGRzOiBmYWxzZSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICBlcnJvcnM6IGZhbHNlLFxuICAgIH07XG4gICAgbGV0IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZSA9IHtcbiAgICAgICAgLi4uX3Byb3h5Rm9ybVN0YXRlLFxuICAgIH07XG4gICAgY29uc3QgX3N1YmplY3RzID0ge1xuICAgICAgICBhcnJheTogY3JlYXRlU3ViamVjdCgpLFxuICAgICAgICBzdGF0ZTogY3JlYXRlU3ViamVjdCgpLFxuICAgIH07XG4gICAgY29uc3Qgc2hvdWxkRGlzcGxheUFsbEFzc29jaWF0ZWRFcnJvcnMgPSBfb3B0aW9ucy5jcml0ZXJpYU1vZGUgPT09IFZBTElEQVRJT05fTU9ERS5hbGw7XG4gICAgY29uc3QgZGVib3VuY2UgPSAoY2FsbGJhY2spID0+ICh3YWl0KSA9PiB7XG4gICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgIHRpbWVyID0gc2V0VGltZW91dChjYWxsYmFjaywgd2FpdCk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0VmFsaWQgPSBhc3luYyAoc2hvdWxkVXBkYXRlVmFsaWQpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVWYWxpZCkpIHtcbiAgICAgICAgICAgIGNvbnN0IGlzVmFsaWQgPSBfb3B0aW9ucy5yZXNvbHZlclxuICAgICAgICAgICAgICAgID8gaXNFbXB0eU9iamVjdCgoYXdhaXQgX3J1blNjaGVtYSgpKS5lcnJvcnMpXG4gICAgICAgICAgICAgICAgOiBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICBpZiAoaXNWYWxpZCAhPT0gX2Zvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfdXBkYXRlSXNWYWxpZGF0aW5nID0gKG5hbWVzLCBpc1ZhbGlkYXRpbmcpID0+IHtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkYXRpbmcgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykpIHtcbiAgICAgICAgICAgIChuYW1lcyB8fCBBcnJheS5mcm9tKF9uYW1lcy5tb3VudCkpLmZvckVhY2goKG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBpZiAobmFtZSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmdcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcywgbmFtZSwgaXNWYWxpZGF0aW5nKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyxcbiAgICAgICAgICAgICAgICBpc1ZhbGlkYXRpbmc6ICFpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcyksXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX3NldEZpZWxkQXJyYXkgPSAobmFtZSwgdmFsdWVzID0gW10sIG1ldGhvZCwgYXJncywgc2hvdWxkU2V0VmFsdWVzID0gdHJ1ZSwgc2hvdWxkVXBkYXRlRmllbGRzQW5kU3RhdGUgPSB0cnVlKSA9PiB7XG4gICAgICAgIGlmIChhcmdzICYmIG1ldGhvZCAmJiAhX29wdGlvbnMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgIF9zdGF0ZS5hY3Rpb24gPSB0cnVlO1xuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmIEFycmF5LmlzQXJyYXkoZ2V0KF9maWVsZHMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gbWV0aG9kKGdldChfZmllbGRzLCBuYW1lKSwgYXJncy5hcmdBLCBhcmdzLmFyZ0IpO1xuICAgICAgICAgICAgICAgIHNob3VsZFNldFZhbHVlcyAmJiBzZXQoX2ZpZWxkcywgbmFtZSwgZmllbGRWYWx1ZXMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpKSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IG1ldGhvZChnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3JzKTtcbiAgICAgICAgICAgICAgICB1bnNldEVtcHR5QXJyYXkoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKChfcHJveHlGb3JtU3RhdGUudG91Y2hlZEZpZWxkcyB8fFxuICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlICYmXG4gICAgICAgICAgICAgICAgQXJyYXkuaXNBcnJheShnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKSkpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB0b3VjaGVkRmllbGRzID0gbWV0aG9kKGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBhcmdzLmFyZ0EsIGFyZ3MuYXJnQik7XG4gICAgICAgICAgICAgICAgc2hvdWxkU2V0VmFsdWVzICYmIHNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUsIHRvdWNoZWRGaWVsZHMpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICBfZm9ybVN0YXRlLmRpcnR5RmllbGRzID0gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCB2YWx1ZXMpLFxuICAgICAgICAgICAgICAgIGRpcnR5RmllbGRzOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzLFxuICAgICAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgaXNWYWxpZDogX2Zvcm1TdGF0ZS5pc1ZhbGlkLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHZhbHVlcyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZUVycm9ycyA9IChuYW1lLCBlcnJvcikgPT4ge1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBfc2V0RXJyb3JzID0gKGVycm9ycykgPT4ge1xuICAgICAgICBfZm9ybVN0YXRlLmVycm9ycyA9IGVycm9ycztcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgIGlzVmFsaWQ6IGZhbHNlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVZhbGlkQW5kVmFsdWUgPSAobmFtZSwgc2hvdWxkU2tpcFNldFZhbHVlQXMsIHZhbHVlLCByZWYpID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZGVmYXVsdFZhbHVlID0gZ2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBpc1VuZGVmaW5lZCh2YWx1ZSkgPyBnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpIDogdmFsdWUpO1xuICAgICAgICAgICAgaXNVbmRlZmluZWQoZGVmYXVsdFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChyZWYgJiYgcmVmLmRlZmF1bHRDaGVja2VkKSB8fFxuICAgICAgICAgICAgICAgIHNob3VsZFNraXBTZXRWYWx1ZUFzXG4gICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIHNob3VsZFNraXBTZXRWYWx1ZUFzID8gZGVmYXVsdFZhbHVlIDogZ2V0RmllbGRWYWx1ZShmaWVsZC5fZikpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKG5hbWUsIGRlZmF1bHRWYWx1ZSk7XG4gICAgICAgICAgICBfc3RhdGUubW91bnQgJiYgX3NldFZhbGlkKCk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZVRvdWNoQW5kRGlydHkgPSAobmFtZSwgZmllbGRWYWx1ZSwgaXNCbHVyRXZlbnQsIHNob3VsZERpcnR5LCBzaG91bGRSZW5kZXIpID0+IHtcbiAgICAgICAgbGV0IHNob3VsZFVwZGF0ZUZpZWxkID0gZmFsc2U7XG4gICAgICAgIGxldCBpc1ByZXZpb3VzRGlydHkgPSBmYWxzZTtcbiAgICAgICAgY29uc3Qgb3V0cHV0ID0ge1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgfTtcbiAgICAgICAgaWYgKCFfb3B0aW9ucy5kaXNhYmxlZCkge1xuICAgICAgICAgICAgaWYgKCFpc0JsdXJFdmVudCB8fCBzaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIGlmIChfcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSB8fCBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSBfZm9ybVN0YXRlLmlzRGlydHk7XG4gICAgICAgICAgICAgICAgICAgIF9mb3JtU3RhdGUuaXNEaXJ0eSA9IG91dHB1dC5pc0RpcnR5ID0gX2dldERpcnR5KCk7XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkID0gaXNQcmV2aW91c0RpcnR5ICE9PSBvdXRwdXQuaXNEaXJ0eTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgY29uc3QgaXNDdXJyZW50RmllbGRQcmlzdGluZSA9IGRlZXBFcXVhbChnZXQoX2RlZmF1bHRWYWx1ZXMsIG5hbWUpLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgPSAhIWdldChfZm9ybVN0YXRlLmRpcnR5RmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpc0N1cnJlbnRGaWVsZFByaXN0aW5lXG4gICAgICAgICAgICAgICAgICAgID8gdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSlcbiAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSwgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgb3V0cHV0LmRpcnR5RmllbGRzID0gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcztcbiAgICAgICAgICAgICAgICBzaG91bGRVcGRhdGVGaWVsZCA9XG4gICAgICAgICAgICAgICAgICAgIHNob3VsZFVwZGF0ZUZpZWxkIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcyB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5kaXJ0eUZpZWxkcykgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRGlydHkgIT09ICFpc0N1cnJlbnRGaWVsZFByaXN0aW5lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGlzUHJldmlvdXNGaWVsZFRvdWNoZWQgPSBnZXQoX2Zvcm1TdGF0ZS50b3VjaGVkRmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoIWlzUHJldmlvdXNGaWVsZFRvdWNoZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSwgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgICAgICAgICBvdXRwdXQudG91Y2hlZEZpZWxkcyA9IF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcztcbiAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgPVxuICAgICAgICAgICAgICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgfHxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS50b3VjaGVkRmllbGRzKSAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpc1ByZXZpb3VzRmllbGRUb3VjaGVkICE9PSBpc0JsdXJFdmVudCk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlRmllbGQgJiYgc2hvdWxkUmVuZGVyICYmIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KG91dHB1dCk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHNob3VsZFVwZGF0ZUZpZWxkID8gb3V0cHV0IDoge307XG4gICAgfTtcbiAgICBjb25zdCBzaG91bGRSZW5kZXJCeUVycm9yID0gKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzRmllbGRFcnJvciA9IGdldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIGNvbnN0IHNob3VsZFVwZGF0ZVZhbGlkID0gKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSAmJlxuICAgICAgICAgICAgaXNCb29sZWFuKGlzVmFsaWQpICYmXG4gICAgICAgICAgICBfZm9ybVN0YXRlLmlzVmFsaWQgIT09IGlzVmFsaWQ7XG4gICAgICAgIGlmIChfb3B0aW9ucy5kZWxheUVycm9yICYmIGVycm9yKSB7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBkZWJvdW5jZSgoKSA9PiB1cGRhdGVFcnJvcnMobmFtZSwgZXJyb3IpKTtcbiAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayhfb3B0aW9ucy5kZWxheUVycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNsZWFyVGltZW91dCh0aW1lcik7XG4gICAgICAgICAgICBkZWxheUVycm9yQ2FsbGJhY2sgPSBudWxsO1xuICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICA/IHNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSwgZXJyb3IpXG4gICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKChlcnJvciA/ICFkZWVwRXF1YWwocHJldmlvdXNGaWVsZEVycm9yLCBlcnJvcikgOiBwcmV2aW91c0ZpZWxkRXJyb3IpIHx8XG4gICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFN0YXRlKSB8fFxuICAgICAgICAgICAgc2hvdWxkVXBkYXRlVmFsaWQpIHtcbiAgICAgICAgICAgIGNvbnN0IHVwZGF0ZWRGb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uZmllbGRTdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi4oc2hvdWxkVXBkYXRlVmFsaWQgJiYgaXNCb29sZWFuKGlzVmFsaWQpID8geyBpc1ZhbGlkIH0gOiB7fSksXG4gICAgICAgICAgICAgICAgZXJyb3JzOiBfZm9ybVN0YXRlLmVycm9ycyxcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUgPSB7XG4gICAgICAgICAgICAgICAgLi4uX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHVwZGF0ZWRGb3JtU3RhdGUpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcnVuU2NoZW1hID0gYXN5bmMgKG5hbWUpID0+IHtcbiAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhuYW1lLCB0cnVlKTtcbiAgICAgICAgY29uc3QgcmVzdWx0ID0gYXdhaXQgX29wdGlvbnMucmVzb2x2ZXIoX2Zvcm1WYWx1ZXMsIF9vcHRpb25zLmNvbnRleHQsIGdldFJlc29sdmVyT3B0aW9ucyhuYW1lIHx8IF9uYW1lcy5tb3VudCwgX2ZpZWxkcywgX29wdGlvbnMuY3JpdGVyaWFNb2RlLCBfb3B0aW9ucy5zaG91bGRVc2VOYXRpdmVWYWxpZGF0aW9uKSk7XG4gICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcobmFtZSk7XG4gICAgICAgIHJldHVybiByZXN1bHQ7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUgPSBhc3luYyAobmFtZXMpID0+IHtcbiAgICAgICAgY29uc3QgeyBlcnJvcnMgfSA9IGF3YWl0IF9ydW5TY2hlbWEobmFtZXMpO1xuICAgICAgICBpZiAobmFtZXMpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBuYW1lcykge1xuICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yID0gZ2V0KGVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgZXJyb3JcbiAgICAgICAgICAgICAgICAgICAgPyBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICA6IHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIF9mb3JtU3RhdGUuZXJyb3JzID0gZXJyb3JzO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBlcnJvcnM7XG4gICAgfTtcbiAgICBjb25zdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24gPSBhc3luYyAoZmllbGRzLCBzaG91bGRPbmx5Q2hlY2tWYWxpZCwgY29udGV4dCA9IHtcbiAgICAgICAgdmFsaWQ6IHRydWUsXG4gICAgfSkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgaW4gZmllbGRzKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGZpZWxkc1tuYW1lXTtcbiAgICAgICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgICAgIGNvbnN0IHsgX2YsIC4uLmZpZWxkVmFsdWUgfSA9IGZpZWxkO1xuICAgICAgICAgICAgICAgIGlmIChfZikge1xuICAgICAgICAgICAgICAgICAgICBjb25zdCBpc0ZpZWxkQXJyYXlSb290ID0gX25hbWVzLmFycmF5LmhhcyhfZi5uYW1lKTtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgaXNQcm9taXNlRnVuY3Rpb24gPSBmaWVsZC5fZiAmJiBoYXNQcm9taXNlVmFsaWRhdGlvbihmaWVsZC5fZik7XG4gICAgICAgICAgICAgICAgICAgIGlmIChpc1Byb21pc2VGdW5jdGlvbiAmJiBfcHJveHlGb3JtU3RhdGUudmFsaWRhdGluZ0ZpZWxkcykge1xuICAgICAgICAgICAgICAgICAgICAgICAgX3VwZGF0ZUlzVmFsaWRhdGluZyhbbmFtZV0sIHRydWUpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkRXJyb3IgPSBhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfbmFtZXMuZGlzYWJsZWQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbiAmJiAhc2hvdWxkT25seUNoZWNrVmFsaWQsIGlzRmllbGRBcnJheVJvb3QpO1xuICAgICAgICAgICAgICAgICAgICBpZiAoaXNQcm9taXNlRnVuY3Rpb24gJiYgX3Byb3h5Rm9ybVN0YXRlLnZhbGlkYXRpbmdGaWVsZHMpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBpZiAoZmllbGRFcnJvcltfZi5uYW1lXSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY29udGV4dC52YWxpZCA9IGZhbHNlO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHNob3VsZE9ubHlDaGVja1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgIXNob3VsZE9ubHlDaGVja1ZhbGlkICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAoZ2V0KGZpZWxkRXJyb3IsIF9mLm5hbWUpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgPyBpc0ZpZWxkQXJyYXlSb290XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihfZm9ybVN0YXRlLmVycm9ycywgZmllbGRFcnJvciwgX2YubmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIF9mLm5hbWUsIGZpZWxkRXJyb3JbX2YubmFtZV0pXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB1bnNldChfZm9ybVN0YXRlLmVycm9ycywgX2YubmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAhaXNFbXB0eU9iamVjdChmaWVsZFZhbHVlKSAmJlxuICAgICAgICAgICAgICAgICAgICAoYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKGZpZWxkVmFsdWUsIHNob3VsZE9ubHlDaGVja1ZhbGlkLCBjb250ZXh0KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIGNvbnRleHQudmFsaWQ7XG4gICAgfTtcbiAgICBjb25zdCBfcmVtb3ZlVW5tb3VudGVkID0gKCkgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IG5hbWUgb2YgX25hbWVzLnVuTW91bnQpIHtcbiAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgZmllbGQgJiZcbiAgICAgICAgICAgICAgICAoZmllbGQuX2YucmVmc1xuICAgICAgICAgICAgICAgICAgICA/IGZpZWxkLl9mLnJlZnMuZXZlcnkoKHJlZikgPT4gIWxpdmUocmVmKSlcbiAgICAgICAgICAgICAgICAgICAgOiAhbGl2ZShmaWVsZC5fZi5yZWYpKSAmJlxuICAgICAgICAgICAgICAgIHVucmVnaXN0ZXIobmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX25hbWVzLnVuTW91bnQgPSBuZXcgU2V0KCk7XG4gICAgfTtcbiAgICBjb25zdCBfZ2V0RGlydHkgPSAobmFtZSwgZGF0YSkgPT4gIV9vcHRpb25zLmRpc2FibGVkICYmXG4gICAgICAgIChuYW1lICYmIGRhdGEgJiYgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBkYXRhKSxcbiAgICAgICAgICAgICFkZWVwRXF1YWwoZ2V0VmFsdWVzKCksIF9kZWZhdWx0VmFsdWVzKSk7XG4gICAgY29uc3QgX2dldFdhdGNoID0gKG5hbWVzLCBkZWZhdWx0VmFsdWUsIGlzR2xvYmFsKSA9PiBnZW5lcmF0ZVdhdGNoT3V0cHV0KG5hbWVzLCBfbmFtZXMsIHtcbiAgICAgICAgLi4uKF9zdGF0ZS5tb3VudFxuICAgICAgICAgICAgPyBfZm9ybVZhbHVlc1xuICAgICAgICAgICAgOiBpc1VuZGVmaW5lZChkZWZhdWx0VmFsdWUpXG4gICAgICAgICAgICAgICAgPyBfZGVmYXVsdFZhbHVlc1xuICAgICAgICAgICAgICAgIDogaXNTdHJpbmcobmFtZXMpXG4gICAgICAgICAgICAgICAgICAgID8geyBbbmFtZXNdOiBkZWZhdWx0VmFsdWUgfVxuICAgICAgICAgICAgICAgICAgICA6IGRlZmF1bHRWYWx1ZSksXG4gICAgfSwgaXNHbG9iYWwsIGRlZmF1bHRWYWx1ZSk7XG4gICAgY29uc3QgX2dldEZpZWxkQXJyYXkgPSAobmFtZSkgPT4gY29tcGFjdChnZXQoX3N0YXRlLm1vdW50ID8gX2Zvcm1WYWx1ZXMgOiBfZGVmYXVsdFZhbHVlcywgbmFtZSwgX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciA/IGdldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgW10pIDogW10pKTtcbiAgICBjb25zdCBzZXRGaWVsZFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGxldCBmaWVsZFZhbHVlID0gdmFsdWU7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZC5fZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZmVyZW5jZSkge1xuICAgICAgICAgICAgICAgICFmaWVsZFJlZmVyZW5jZS5kaXNhYmxlZCAmJlxuICAgICAgICAgICAgICAgICAgICBzZXQoX2Zvcm1WYWx1ZXMsIG5hbWUsIGdldEZpZWxkVmFsdWVBcyh2YWx1ZSwgZmllbGRSZWZlcmVuY2UpKTtcbiAgICAgICAgICAgICAgICBmaWVsZFZhbHVlID1cbiAgICAgICAgICAgICAgICAgICAgaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZS5yZWYpICYmIGlzTnVsbE9yVW5kZWZpbmVkKHZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyAnJ1xuICAgICAgICAgICAgICAgICAgICAgICAgOiB2YWx1ZTtcbiAgICAgICAgICAgICAgICBpZiAoaXNNdWx0aXBsZVNlbGVjdChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgIFsuLi5maWVsZFJlZmVyZW5jZS5yZWYub3B0aW9uc10uZm9yRWFjaCgob3B0aW9uUmVmKSA9PiAob3B0aW9uUmVmLnNlbGVjdGVkID0gZmllbGRWYWx1ZS5pbmNsdWRlcyhvcHRpb25SZWYudmFsdWUpKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2UgaWYgKGZpZWxkUmVmZXJlbmNlLnJlZnMpIHtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzQ2hlY2tCb3hJbnB1dChmaWVsZFJlZmVyZW5jZS5yZWYpKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKGNoZWNrYm94UmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCFjaGVja2JveFJlZi5kZWZhdWx0Q2hlY2tlZCB8fCAhY2hlY2tib3hSZWYuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNoZWNrYm94UmVmLmNoZWNrZWQgPSAhIWZpZWxkVmFsdWUuZmluZCgoZGF0YSkgPT4gZGF0YSA9PT0gY2hlY2tib3hSZWYudmFsdWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY2hlY2tib3hSZWYuY2hlY2tlZCA9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRWYWx1ZSA9PT0gY2hlY2tib3hSZWYudmFsdWUgfHwgISFmaWVsZFZhbHVlO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWZzLmZvckVhY2goKHJhZGlvUmVmKSA9PiAocmFkaW9SZWYuY2hlY2tlZCA9IHJhZGlvUmVmLnZhbHVlID09PSBmaWVsZFZhbHVlKSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSBpZiAoaXNGaWxlSW5wdXQoZmllbGRSZWZlcmVuY2UucmVmKSkge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZFJlZmVyZW5jZS5yZWYudmFsdWUgPSAnJztcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmZXJlbmNlLnJlZi52YWx1ZSA9IGZpZWxkVmFsdWU7XG4gICAgICAgICAgICAgICAgICAgIGlmICghZmllbGRSZWZlcmVuY2UucmVmLnR5cGUpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgKG9wdGlvbnMuc2hvdWxkRGlydHkgfHwgb3B0aW9ucy5zaG91bGRUb3VjaCkgJiZcbiAgICAgICAgICAgIHVwZGF0ZVRvdWNoQW5kRGlydHkobmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucy5zaG91bGRUb3VjaCwgb3B0aW9ucy5zaG91bGREaXJ0eSwgdHJ1ZSk7XG4gICAgICAgIG9wdGlvbnMuc2hvdWxkVmFsaWRhdGUgJiYgdHJpZ2dlcihuYW1lKTtcbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlcyA9IChuYW1lLCB2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBmb3IgKGNvbnN0IGZpZWxkS2V5IGluIHZhbHVlKSB7XG4gICAgICAgICAgICBpZiAoIXZhbHVlLmhhc093blByb3BlcnR5KGZpZWxkS2V5KSkge1xuICAgICAgICAgICAgICAgIHJldHVybjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWUgPSB2YWx1ZVtmaWVsZEtleV07XG4gICAgICAgICAgICBjb25zdCBmaWVsZE5hbWUgPSBuYW1lICsgJy4nICsgZmllbGRLZXk7XG4gICAgICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgKF9uYW1lcy5hcnJheS5oYXMobmFtZSkgfHxcbiAgICAgICAgICAgICAgICBpc09iamVjdChmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgIChmaWVsZCAmJiAhZmllbGQuX2YpKSAmJlxuICAgICAgICAgICAgICAgICFpc0RhdGVPYmplY3QoZmllbGRWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhmaWVsZE5hbWUsIGZpZWxkVmFsdWUsIG9wdGlvbnMpXG4gICAgICAgICAgICAgICAgOiBzZXRGaWVsZFZhbHVlKGZpZWxkTmFtZSwgZmllbGRWYWx1ZSwgb3B0aW9ucyk7XG4gICAgICAgIH1cbiAgICB9O1xuICAgIGNvbnN0IHNldFZhbHVlID0gKG5hbWUsIHZhbHVlLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IGlzRmllbGRBcnJheSA9IF9uYW1lcy5hcnJheS5oYXMobmFtZSk7XG4gICAgICAgIGNvbnN0IGNsb25lVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIHNldChfZm9ybVZhbHVlcywgbmFtZSwgY2xvbmVWYWx1ZSk7XG4gICAgICAgIGlmIChpc0ZpZWxkQXJyYXkpIHtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgfSk7XG4gICAgICAgICAgICBpZiAoKF9wcm94eUZvcm1TdGF0ZS5pc0RpcnR5IHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5Rm9ybVN0YXRlLmRpcnR5RmllbGRzIHx8XG4gICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzRGlydHkgfHxcbiAgICAgICAgICAgICAgICBfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUuZGlydHlGaWVsZHMpICYmXG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGREaXJ0eSkge1xuICAgICAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgICAgICAgICAgZGlydHlGaWVsZHM6IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcyksXG4gICAgICAgICAgICAgICAgICAgIGlzRGlydHk6IF9nZXREaXJ0eShuYW1lLCBjbG9uZVZhbHVlKSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGZpZWxkICYmICFmaWVsZC5fZiAmJiAhaXNOdWxsT3JVbmRlZmluZWQoY2xvbmVWYWx1ZSlcbiAgICAgICAgICAgICAgICA/IHNldFZhbHVlcyhuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKVxuICAgICAgICAgICAgICAgIDogc2V0RmllbGRWYWx1ZShuYW1lLCBjbG9uZVZhbHVlLCBvcHRpb25zKTtcbiAgICAgICAgfVxuICAgICAgICBpc1dhdGNoZWQobmFtZSwgX25hbWVzKSAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIG5hbWU6IF9zdGF0ZS5tb3VudCA/IG5hbWUgOiB1bmRlZmluZWQsXG4gICAgICAgICAgICB2YWx1ZXM6IGNsb25lT2JqZWN0KF9mb3JtVmFsdWVzKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBvbkNoYW5nZSA9IGFzeW5jIChldmVudCkgPT4ge1xuICAgICAgICBfc3RhdGUubW91bnQgPSB0cnVlO1xuICAgICAgICBjb25zdCB0YXJnZXQgPSBldmVudC50YXJnZXQ7XG4gICAgICAgIGxldCBuYW1lID0gdGFyZ2V0Lm5hbWU7XG4gICAgICAgIGxldCBpc0ZpZWxkVmFsdWVVcGRhdGVkID0gdHJ1ZTtcbiAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgIGNvbnN0IF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkID0gKGZpZWxkVmFsdWUpID0+IHtcbiAgICAgICAgICAgIGlzRmllbGRWYWx1ZVVwZGF0ZWQgPVxuICAgICAgICAgICAgICAgIE51bWJlci5pc05hTihmaWVsZFZhbHVlKSB8fFxuICAgICAgICAgICAgICAgICAgICAoaXNEYXRlT2JqZWN0KGZpZWxkVmFsdWUpICYmIGlzTmFOKGZpZWxkVmFsdWUuZ2V0VGltZSgpKSkgfHxcbiAgICAgICAgICAgICAgICAgICAgZGVlcEVxdWFsKGZpZWxkVmFsdWUsIGdldChfZm9ybVZhbHVlcywgbmFtZSwgZmllbGRWYWx1ZSkpO1xuICAgICAgICB9O1xuICAgICAgICBjb25zdCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5tb2RlKTtcbiAgICAgICAgY29uc3QgdmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCA9IGdldFZhbGlkYXRpb25Nb2Rlcyhfb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSk7XG4gICAgICAgIGlmIChmaWVsZCkge1xuICAgICAgICAgICAgbGV0IGVycm9yO1xuICAgICAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFZhbHVlID0gdGFyZ2V0LnR5cGVcbiAgICAgICAgICAgICAgICA/IGdldEZpZWxkVmFsdWUoZmllbGQuX2YpXG4gICAgICAgICAgICAgICAgOiBnZXRFdmVudFZhbHVlKGV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IGlzQmx1ckV2ZW50ID0gZXZlbnQudHlwZSA9PT0gRVZFTlRTLkJMVVIgfHwgZXZlbnQudHlwZSA9PT0gRVZFTlRTLkZPQ1VTX09VVDtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFNraXBWYWxpZGF0aW9uID0gKCFoYXNWYWxpZGF0aW9uKGZpZWxkLl9mKSAmJlxuICAgICAgICAgICAgICAgICFfb3B0aW9ucy5yZXNvbHZlciAmJlxuICAgICAgICAgICAgICAgICFnZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpICYmXG4gICAgICAgICAgICAgICAgIWZpZWxkLl9mLmRlcHMpIHx8XG4gICAgICAgICAgICAgICAgc2tpcFZhbGlkYXRpb24oaXNCbHVyRXZlbnQsIGdldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIG5hbWUpLCBfZm9ybVN0YXRlLmlzU3VibWl0dGVkLCB2YWxpZGF0aW9uTW9kZUFmdGVyU3VibWl0LCB2YWxpZGF0aW9uTW9kZUJlZm9yZVN1Ym1pdCk7XG4gICAgICAgICAgICBjb25zdCB3YXRjaGVkID0gaXNXYXRjaGVkKG5hbWUsIF9uYW1lcywgaXNCbHVyRXZlbnQpO1xuICAgICAgICAgICAgc2V0KF9mb3JtVmFsdWVzLCBuYW1lLCBmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgIGlmIChpc0JsdXJFdmVudCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQmx1ciAmJiBmaWVsZC5fZi5vbkJsdXIoZXZlbnQpO1xuICAgICAgICAgICAgICAgIGRlbGF5RXJyb3JDYWxsYmFjayAmJiBkZWxheUVycm9yQ2FsbGJhY2soMCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBlbHNlIGlmIChmaWVsZC5fZi5vbkNoYW5nZSkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLm9uQ2hhbmdlKGV2ZW50KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGNvbnN0IGZpZWxkU3RhdGUgPSB1cGRhdGVUb3VjaEFuZERpcnR5KG5hbWUsIGZpZWxkVmFsdWUsIGlzQmx1ckV2ZW50KTtcbiAgICAgICAgICAgIGNvbnN0IHNob3VsZFJlbmRlciA9ICFpc0VtcHR5T2JqZWN0KGZpZWxkU3RhdGUpIHx8IHdhdGNoZWQ7XG4gICAgICAgICAgICAhaXNCbHVyRXZlbnQgJiZcbiAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgICAgIHR5cGU6IGV2ZW50LnR5cGUsXG4gICAgICAgICAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoX2Zvcm1WYWx1ZXMpLFxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHNob3VsZFNraXBWYWxpZGF0aW9uKSB7XG4gICAgICAgICAgICAgICAgaWYgKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSB7XG4gICAgICAgICAgICAgICAgICAgIGlmIChfb3B0aW9ucy5tb2RlID09PSAnb25CbHVyJykge1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlzQmx1ckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX3NldFZhbGlkKCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgZWxzZSBpZiAoIWlzQmx1ckV2ZW50KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfc2V0VmFsaWQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm4gKHNob3VsZFJlbmRlciAmJlxuICAgICAgICAgICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IG5hbWUsIC4uLih3YXRjaGVkID8ge30gOiBmaWVsZFN0YXRlKSB9KSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICAhaXNCbHVyRXZlbnQgJiYgd2F0Y2hlZCAmJiBfc3ViamVjdHMuc3RhdGUubmV4dCh7IC4uLl9mb3JtU3RhdGUgfSk7XG4gICAgICAgICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb25zdCB7IGVycm9ycyB9ID0gYXdhaXQgX3J1blNjaGVtYShbbmFtZV0pO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc0ZpZWxkVmFsdWVVcGRhdGVkKGZpZWxkVmFsdWUpO1xuICAgICAgICAgICAgICAgIGlmIChpc0ZpZWxkVmFsdWVVcGRhdGVkKSB7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IHByZXZpb3VzRXJyb3JMb29rdXBSZXN1bHQgPSBzY2hlbWFFcnJvckxvb2t1cChfZm9ybVN0YXRlLmVycm9ycywgX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGVycm9yTG9va3VwUmVzdWx0ID0gc2NoZW1hRXJyb3JMb29rdXAoZXJyb3JzLCBfZmllbGRzLCBwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0Lm5hbWUgfHwgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGVycm9yID0gZXJyb3JMb29rdXBSZXN1bHQuZXJyb3I7XG4gICAgICAgICAgICAgICAgICAgIG5hbWUgPSBlcnJvckxvb2t1cFJlc3VsdC5uYW1lO1xuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkID0gaXNFbXB0eU9iamVjdChlcnJvcnMpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdLCB0cnVlKTtcbiAgICAgICAgICAgICAgICBlcnJvciA9IChhd2FpdCB2YWxpZGF0ZUZpZWxkKGZpZWxkLCBfbmFtZXMuZGlzYWJsZWQsIF9mb3JtVmFsdWVzLCBzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycywgX29wdGlvbnMuc2hvdWxkVXNlTmF0aXZlVmFsaWRhdGlvbikpW25hbWVdO1xuICAgICAgICAgICAgICAgIF91cGRhdGVJc1ZhbGlkYXRpbmcoW25hbWVdKTtcbiAgICAgICAgICAgICAgICBfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZChmaWVsZFZhbHVlKTtcbiAgICAgICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICBlbHNlIGlmIChfcHJveHlGb3JtU3RhdGUuaXNWYWxpZCB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLmlzVmFsaWQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzVmFsaWQgPSBhd2FpdCBleGVjdXRlQnVpbHRJblZhbGlkYXRpb24oX2ZpZWxkcywgdHJ1ZSk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoaXNGaWVsZFZhbHVlVXBkYXRlZCkge1xuICAgICAgICAgICAgICAgIGZpZWxkLl9mLmRlcHMgJiZcbiAgICAgICAgICAgICAgICAgICAgdHJpZ2dlcihmaWVsZC5fZi5kZXBzKTtcbiAgICAgICAgICAgICAgICBzaG91bGRSZW5kZXJCeUVycm9yKG5hbWUsIGlzVmFsaWQsIGVycm9yLCBmaWVsZFN0YXRlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgX2ZvY3VzSW5wdXQgPSAocmVmLCBrZXkpID0+IHtcbiAgICAgICAgaWYgKGdldChfZm9ybVN0YXRlLmVycm9ycywga2V5KSAmJiByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgIHJlZi5mb2N1cygpO1xuICAgICAgICAgICAgcmV0dXJuIDE7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuO1xuICAgIH07XG4gICAgY29uc3QgdHJpZ2dlciA9IGFzeW5jIChuYW1lLCBvcHRpb25zID0ge30pID0+IHtcbiAgICAgICAgbGV0IGlzVmFsaWQ7XG4gICAgICAgIGxldCB2YWxpZGF0aW9uUmVzdWx0O1xuICAgICAgICBjb25zdCBmaWVsZE5hbWVzID0gY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpO1xuICAgICAgICBpZiAoX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgIGNvbnN0IGVycm9ycyA9IGF3YWl0IGV4ZWN1dGVTY2hlbWFBbmRVcGRhdGVTdGF0ZShpc1VuZGVmaW5lZChuYW1lKSA/IG5hbWUgOiBmaWVsZE5hbWVzKTtcbiAgICAgICAgICAgIGlzVmFsaWQgPSBpc0VtcHR5T2JqZWN0KGVycm9ycyk7XG4gICAgICAgICAgICB2YWxpZGF0aW9uUmVzdWx0ID0gbmFtZVxuICAgICAgICAgICAgICAgID8gIWZpZWxkTmFtZXMuc29tZSgobmFtZSkgPT4gZ2V0KGVycm9ycywgbmFtZSkpXG4gICAgICAgICAgICAgICAgOiBpc1ZhbGlkO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKG5hbWUpIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSAoYXdhaXQgUHJvbWlzZS5hbGwoZmllbGROYW1lcy5tYXAoYXN5bmMgKGZpZWxkTmFtZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAgICAgcmV0dXJuIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihmaWVsZCAmJiBmaWVsZC5fZiA/IHsgW2ZpZWxkTmFtZV06IGZpZWxkIH0gOiBmaWVsZCk7XG4gICAgICAgICAgICB9KSkpLmV2ZXJ5KEJvb2xlYW4pO1xuICAgICAgICAgICAgISghdmFsaWRhdGlvblJlc3VsdCAmJiAhX2Zvcm1TdGF0ZS5pc1ZhbGlkKSAmJiBfc2V0VmFsaWQoKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHZhbGlkYXRpb25SZXN1bHQgPSBpc1ZhbGlkID0gYXdhaXQgZXhlY3V0ZUJ1aWx0SW5WYWxpZGF0aW9uKF9maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIC4uLighaXNTdHJpbmcobmFtZSkgfHxcbiAgICAgICAgICAgICAgICAoKF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkIHx8IF9wcm94eVN1YnNjcmliZUZvcm1TdGF0ZS5pc1ZhbGlkKSAmJlxuICAgICAgICAgICAgICAgICAgICBpc1ZhbGlkICE9PSBfZm9ybVN0YXRlLmlzVmFsaWQpXG4gICAgICAgICAgICAgICAgPyB7fVxuICAgICAgICAgICAgICAgIDogeyBuYW1lIH0pLFxuICAgICAgICAgICAgLi4uKF9vcHRpb25zLnJlc29sdmVyIHx8ICFuYW1lID8geyBpc1ZhbGlkIH0gOiB7fSksXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICAgICAgb3B0aW9ucy5zaG91bGRGb2N1cyAmJlxuICAgICAgICAgICAgIXZhbGlkYXRpb25SZXN1bHQgJiZcbiAgICAgICAgICAgIGl0ZXJhdGVGaWVsZHNCeUFjdGlvbihfZmllbGRzLCBfZm9jdXNJbnB1dCwgbmFtZSA/IGZpZWxkTmFtZXMgOiBfbmFtZXMubW91bnQpO1xuICAgICAgICByZXR1cm4gdmFsaWRhdGlvblJlc3VsdDtcbiAgICB9O1xuICAgIGNvbnN0IGdldFZhbHVlcyA9IChmaWVsZE5hbWVzKSA9PiB7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IHtcbiAgICAgICAgICAgIC4uLihfc3RhdGUubW91bnQgPyBfZm9ybVZhbHVlcyA6IF9kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgfTtcbiAgICAgICAgcmV0dXJuIGlzVW5kZWZpbmVkKGZpZWxkTmFtZXMpXG4gICAgICAgICAgICA/IHZhbHVlc1xuICAgICAgICAgICAgOiBpc1N0cmluZyhmaWVsZE5hbWVzKVxuICAgICAgICAgICAgICAgID8gZ2V0KHZhbHVlcywgZmllbGROYW1lcylcbiAgICAgICAgICAgICAgICA6IGZpZWxkTmFtZXMubWFwKChuYW1lKSA9PiBnZXQodmFsdWVzLCBuYW1lKSk7XG4gICAgfTtcbiAgICBjb25zdCBnZXRGaWVsZFN0YXRlID0gKG5hbWUsIGZvcm1TdGF0ZSkgPT4gKHtcbiAgICAgICAgaW52YWxpZDogISFnZXQoKGZvcm1TdGF0ZSB8fCBfZm9ybVN0YXRlKS5lcnJvcnMsIG5hbWUpLFxuICAgICAgICBpc0RpcnR5OiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmRpcnR5RmllbGRzLCBuYW1lKSxcbiAgICAgICAgZXJyb3I6IGdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLmVycm9ycywgbmFtZSksXG4gICAgICAgIGlzVmFsaWRhdGluZzogISFnZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBuYW1lKSxcbiAgICAgICAgaXNUb3VjaGVkOiAhIWdldCgoZm9ybVN0YXRlIHx8IF9mb3JtU3RhdGUpLnRvdWNoZWRGaWVsZHMsIG5hbWUpLFxuICAgIH0pO1xuICAgIGNvbnN0IGNsZWFyRXJyb3JzID0gKG5hbWUpID0+IHtcbiAgICAgICAgbmFtZSAmJlxuICAgICAgICAgICAgY29udmVydFRvQXJyYXlQYXlsb2FkKG5hbWUpLmZvckVhY2goKGlucHV0TmFtZSkgPT4gdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIGlucHV0TmFtZSkpO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBlcnJvcnM6IG5hbWUgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHNldEVycm9yID0gKG5hbWUsIGVycm9yLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHJlZiA9IChnZXQoX2ZpZWxkcywgbmFtZSwgeyBfZjoge30gfSkuX2YgfHwge30pLnJlZjtcbiAgICAgICAgY29uc3QgY3VycmVudEVycm9yID0gZ2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBuYW1lKSB8fCB7fTtcbiAgICAgICAgLy8gRG9uJ3Qgb3ZlcnJpZGUgZXhpc3RpbmcgZXJyb3IgbWVzc2FnZXMgZWxzZXdoZXJlIGluIHRoZSBvYmplY3QgdHJlZS5cbiAgICAgICAgY29uc3QgeyByZWY6IGN1cnJlbnRSZWYsIG1lc3NhZ2UsIHR5cGUsIC4uLnJlc3RPZkVycm9yVHJlZSB9ID0gY3VycmVudEVycm9yO1xuICAgICAgICBzZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLnJlc3RPZkVycm9yVHJlZSxcbiAgICAgICAgICAgIC4uLmVycm9yLFxuICAgICAgICAgICAgcmVmLFxuICAgICAgICB9KTtcbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIGVycm9yczogX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgfSk7XG4gICAgICAgIG9wdGlvbnMgJiYgb3B0aW9ucy5zaG91bGRGb2N1cyAmJiByZWYgJiYgcmVmLmZvY3VzICYmIHJlZi5mb2N1cygpO1xuICAgIH07XG4gICAgY29uc3Qgd2F0Y2ggPSAobmFtZSwgZGVmYXVsdFZhbHVlKSA9PiBpc0Z1bmN0aW9uKG5hbWUpXG4gICAgICAgID8gX3N1YmplY3RzLnN0YXRlLnN1YnNjcmliZSh7XG4gICAgICAgICAgICBuZXh0OiAocGF5bG9hZCkgPT4gbmFtZShfZ2V0V2F0Y2godW5kZWZpbmVkLCBkZWZhdWx0VmFsdWUpLCBwYXlsb2FkKSxcbiAgICAgICAgfSlcbiAgICAgICAgOiBfZ2V0V2F0Y2gobmFtZSwgZGVmYXVsdFZhbHVlLCB0cnVlKTtcbiAgICBjb25zdCBfc3Vic2NyaWJlID0gKHByb3BzKSA9PiBfc3ViamVjdHMuc3RhdGUuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKGZvcm1TdGF0ZSkgPT4ge1xuICAgICAgICAgICAgaWYgKHNob3VsZFN1YnNjcmliZUJ5TmFtZShwcm9wcy5uYW1lLCBmb3JtU3RhdGUubmFtZSwgcHJvcHMuZXhhY3QpICYmXG4gICAgICAgICAgICAgICAgc2hvdWxkUmVuZGVyRm9ybVN0YXRlKGZvcm1TdGF0ZSwgcHJvcHMuZm9ybVN0YXRlIHx8IF9wcm94eUZvcm1TdGF0ZSwgX3NldEZvcm1TdGF0ZSwgcHJvcHMucmVSZW5kZXJSb290KSkge1xuICAgICAgICAgICAgICAgIHByb3BzLmNhbGxiYWNrKHtcbiAgICAgICAgICAgICAgICAgICAgdmFsdWVzOiB7IC4uLl9mb3JtVmFsdWVzIH0sXG4gICAgICAgICAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAgICAgICAgIC4uLmZvcm1TdGF0ZSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KS51bnN1YnNjcmliZTtcbiAgICBjb25zdCBzdWJzY3JpYmUgPSAocHJvcHMpID0+IHtcbiAgICAgICAgX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlID0ge1xuICAgICAgICAgICAgLi4uX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4ucHJvcHMuZm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgICAgICByZXR1cm4gX3N1YnNjcmliZSh7XG4gICAgICAgICAgICAuLi5wcm9wcyxcbiAgICAgICAgICAgIGZvcm1TdGF0ZTogX3Byb3h5U3Vic2NyaWJlRm9ybVN0YXRlLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHVucmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIG5hbWUgPyBjb252ZXJ0VG9BcnJheVBheWxvYWQobmFtZSkgOiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgIF9uYW1lcy5tb3VudC5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIF9uYW1lcy5hcnJheS5kZWxldGUoZmllbGROYW1lKTtcbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVmFsdWUpIHtcbiAgICAgICAgICAgICAgICB1bnNldChfZmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtVmFsdWVzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgIW9wdGlvbnMua2VlcEVycm9yICYmIHVuc2V0KF9mb3JtU3RhdGUuZXJyb3JzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIW9wdGlvbnMua2VlcERpcnR5ICYmIHVuc2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwVG91Y2hlZCAmJiB1bnNldChfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHMsIGZpZWxkTmFtZSk7XG4gICAgICAgICAgICAhb3B0aW9ucy5rZWVwSXNWYWxpZGF0aW5nICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS52YWxpZGF0aW5nRmllbGRzLCBmaWVsZE5hbWUpO1xuICAgICAgICAgICAgIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXIgJiZcbiAgICAgICAgICAgICAgICAhb3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlICYmXG4gICAgICAgICAgICAgICAgdW5zZXQoX2RlZmF1bHRWYWx1ZXMsIGZpZWxkTmFtZSk7XG4gICAgICAgIH1cbiAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgdmFsdWVzOiBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAuLi5fZm9ybVN0YXRlLFxuICAgICAgICAgICAgLi4uKCFvcHRpb25zLmtlZXBEaXJ0eSA/IHt9IDogeyBpc0RpcnR5OiBfZ2V0RGlydHkoKSB9KSxcbiAgICAgICAgfSk7XG4gICAgICAgICFvcHRpb25zLmtlZXBJc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgIH07XG4gICAgY29uc3QgX3NldERpc2FibGVkRmllbGQgPSAoeyBkaXNhYmxlZCwgbmFtZSwgfSkgPT4ge1xuICAgICAgICBpZiAoKGlzQm9vbGVhbihkaXNhYmxlZCkgJiYgX3N0YXRlLm1vdW50KSB8fFxuICAgICAgICAgICAgISFkaXNhYmxlZCB8fFxuICAgICAgICAgICAgX25hbWVzLmRpc2FibGVkLmhhcyhuYW1lKSkge1xuICAgICAgICAgICAgZGlzYWJsZWQgPyBfbmFtZXMuZGlzYWJsZWQuYWRkKG5hbWUpIDogX25hbWVzLmRpc2FibGVkLmRlbGV0ZShuYW1lKTtcbiAgICAgICAgfVxuICAgIH07XG4gICAgY29uc3QgcmVnaXN0ZXIgPSAobmFtZSwgb3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGxldCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZGlzYWJsZWRJc0RlZmluZWQgPSBpc0Jvb2xlYW4ob3B0aW9ucy5kaXNhYmxlZCkgfHwgaXNCb29sZWFuKF9vcHRpb25zLmRpc2FibGVkKTtcbiAgICAgICAgc2V0KF9maWVsZHMsIG5hbWUsIHtcbiAgICAgICAgICAgIC4uLihmaWVsZCB8fCB7fSksXG4gICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgIC4uLihmaWVsZCAmJiBmaWVsZC5fZiA/IGZpZWxkLl9mIDogeyByZWY6IHsgbmFtZSB9IH0pLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICAgICAgbW91bnQ6IHRydWUsXG4gICAgICAgICAgICAgICAgLi4ub3B0aW9ucyxcbiAgICAgICAgICAgIH0sXG4gICAgICAgIH0pO1xuICAgICAgICBfbmFtZXMubW91bnQuYWRkKG5hbWUpO1xuICAgICAgICBpZiAoZmllbGQpIHtcbiAgICAgICAgICAgIF9zZXREaXNhYmxlZEZpZWxkKHtcbiAgICAgICAgICAgICAgICBkaXNhYmxlZDogaXNCb29sZWFuKG9wdGlvbnMuZGlzYWJsZWQpXG4gICAgICAgICAgICAgICAgICAgID8gb3B0aW9ucy5kaXNhYmxlZFxuICAgICAgICAgICAgICAgICAgICA6IF9vcHRpb25zLmRpc2FibGVkLFxuICAgICAgICAgICAgICAgIG5hbWUsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIHVwZGF0ZVZhbGlkQW5kVmFsdWUobmFtZSwgdHJ1ZSwgb3B0aW9ucy52YWx1ZSk7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICAgIC4uLihkaXNhYmxlZElzRGVmaW5lZFxuICAgICAgICAgICAgICAgID8geyBkaXNhYmxlZDogb3B0aW9ucy5kaXNhYmxlZCB8fCBfb3B0aW9ucy5kaXNhYmxlZCB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICAuLi4oX29wdGlvbnMucHJvZ3Jlc3NpdmVcbiAgICAgICAgICAgICAgICA/IHtcbiAgICAgICAgICAgICAgICAgICAgcmVxdWlyZWQ6ICEhb3B0aW9ucy5yZXF1aXJlZCxcbiAgICAgICAgICAgICAgICAgICAgbWluOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5taW4pLFxuICAgICAgICAgICAgICAgICAgICBtYXg6IGdldFJ1bGVWYWx1ZShvcHRpb25zLm1heCksXG4gICAgICAgICAgICAgICAgICAgIG1pbkxlbmd0aDogZ2V0UnVsZVZhbHVlKG9wdGlvbnMubWluTGVuZ3RoKSxcbiAgICAgICAgICAgICAgICAgICAgbWF4TGVuZ3RoOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5tYXhMZW5ndGgpLFxuICAgICAgICAgICAgICAgICAgICBwYXR0ZXJuOiBnZXRSdWxlVmFsdWUob3B0aW9ucy5wYXR0ZXJuKSxcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgOiB7fSksXG4gICAgICAgICAgICBuYW1lLFxuICAgICAgICAgICAgb25DaGFuZ2UsXG4gICAgICAgICAgICBvbkJsdXI6IG9uQ2hhbmdlLFxuICAgICAgICAgICAgcmVmOiAocmVmKSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKHJlZikge1xuICAgICAgICAgICAgICAgICAgICByZWdpc3RlcihuYW1lLCBvcHRpb25zKTtcbiAgICAgICAgICAgICAgICAgICAgZmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkUmVmID0gaXNVbmRlZmluZWQocmVmLnZhbHVlKVxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWYucXVlcnlTZWxlY3RvckFsbFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gcmVmLnF1ZXJ5U2VsZWN0b3JBbGwoJ2lucHV0LHNlbGVjdCx0ZXh0YXJlYScpWzBdIHx8IHJlZlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogcmVmXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHJlZjtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgcmFkaW9PckNoZWNrYm94ID0gaXNSYWRpb09yQ2hlY2tib3goZmllbGRSZWYpO1xuICAgICAgICAgICAgICAgICAgICBjb25zdCByZWZzID0gZmllbGQuX2YucmVmcyB8fCBbXTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKHJhZGlvT3JDaGVja2JveFxuICAgICAgICAgICAgICAgICAgICAgICAgPyByZWZzLmZpbmQoKG9wdGlvbikgPT4gb3B0aW9uID09PSBmaWVsZFJlZilcbiAgICAgICAgICAgICAgICAgICAgICAgIDogZmllbGRSZWYgPT09IGZpZWxkLl9mLnJlZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIHNldChfZmllbGRzLCBuYW1lLCB7XG4gICAgICAgICAgICAgICAgICAgICAgICBfZjoge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLmZpZWxkLl9mLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC4uLihyYWRpb09yQ2hlY2tib3hcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgPyB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZWZzOiBbXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4ucmVmcy5maWx0ZXIobGl2ZSksXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgZmllbGRSZWYsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLi4uKEFycmF5LmlzQXJyYXkoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkgPyBbe31dIDogW10pLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgXSxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlZjogeyB0eXBlOiBmaWVsZFJlZi50eXBlLCBuYW1lIH0sXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgOiB7IHJlZjogZmllbGRSZWYgfSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9LFxuICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgdXBkYXRlVmFsaWRBbmRWYWx1ZShuYW1lLCBmYWxzZSwgdW5kZWZpbmVkLCBmaWVsZFJlZik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lLCB7fSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChmaWVsZC5fZikge1xuICAgICAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YubW91bnQgPSBmYWxzZTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAoX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBvcHRpb25zLnNob3VsZFVucmVnaXN0ZXIpICYmXG4gICAgICAgICAgICAgICAgICAgICAgICAhKGlzTmFtZUluRmllbGRBcnJheShfbmFtZXMuYXJyYXksIG5hbWUpICYmIF9zdGF0ZS5hY3Rpb24pICYmXG4gICAgICAgICAgICAgICAgICAgICAgICBfbmFtZXMudW5Nb3VudC5hZGQobmFtZSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSxcbiAgICAgICAgfTtcbiAgICB9O1xuICAgIGNvbnN0IF9mb2N1c0Vycm9yID0gKCkgPT4gX29wdGlvbnMuc2hvdWxkRm9jdXNFcnJvciAmJlxuICAgICAgICBpdGVyYXRlRmllbGRzQnlBY3Rpb24oX2ZpZWxkcywgX2ZvY3VzSW5wdXQsIF9uYW1lcy5tb3VudCk7XG4gICAgY29uc3QgX2Rpc2FibGVGb3JtID0gKGRpc2FibGVkKSA9PiB7XG4gICAgICAgIGlmIChpc0Jvb2xlYW4oZGlzYWJsZWQpKSB7XG4gICAgICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7IGRpc2FibGVkIH0pO1xuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKF9maWVsZHMsIChyZWYsIG5hbWUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCBjdXJyZW50RmllbGQgPSBnZXQoX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGN1cnJlbnRGaWVsZCkge1xuICAgICAgICAgICAgICAgICAgICByZWYuZGlzYWJsZWQgPSBjdXJyZW50RmllbGQuX2YuZGlzYWJsZWQgfHwgZGlzYWJsZWQ7XG4gICAgICAgICAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGN1cnJlbnRGaWVsZC5fZi5yZWZzKSkge1xuICAgICAgICAgICAgICAgICAgICAgICAgY3VycmVudEZpZWxkLl9mLnJlZnMuZm9yRWFjaCgoaW5wdXRSZWYpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnB1dFJlZi5kaXNhYmxlZCA9IGN1cnJlbnRGaWVsZC5fZi5kaXNhYmxlZCB8fCBkaXNhYmxlZDtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSwgMCwgZmFsc2UpO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBoYW5kbGVTdWJtaXQgPSAob25WYWxpZCwgb25JbnZhbGlkKSA9PiBhc3luYyAoZSkgPT4ge1xuICAgICAgICBsZXQgb25WYWxpZEVycm9yID0gdW5kZWZpbmVkO1xuICAgICAgICBpZiAoZSkge1xuICAgICAgICAgICAgZS5wcmV2ZW50RGVmYXVsdCAmJiBlLnByZXZlbnREZWZhdWx0KCk7XG4gICAgICAgICAgICBlLnBlcnNpc3QgJiZcbiAgICAgICAgICAgICAgICBlLnBlcnNpc3QoKTtcbiAgICAgICAgfVxuICAgICAgICBsZXQgZmllbGRWYWx1ZXMgPSBjbG9uZU9iamVjdChfZm9ybVZhbHVlcyk7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIGlmIChfb3B0aW9ucy5yZXNvbHZlcikge1xuICAgICAgICAgICAgY29uc3QgeyBlcnJvcnMsIHZhbHVlcyB9ID0gYXdhaXQgX3J1blNjaGVtYSgpO1xuICAgICAgICAgICAgX2Zvcm1TdGF0ZS5lcnJvcnMgPSBlcnJvcnM7XG4gICAgICAgICAgICBmaWVsZFZhbHVlcyA9IHZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGF3YWl0IGV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbihfZmllbGRzKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoX25hbWVzLmRpc2FibGVkLnNpemUpIHtcbiAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMuZGlzYWJsZWQpIHtcbiAgICAgICAgICAgICAgICBzZXQoZmllbGRWYWx1ZXMsIG5hbWUsIHVuZGVmaW5lZCk7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsICdyb290Jyk7XG4gICAgICAgIGlmIChpc0VtcHR5T2JqZWN0KF9mb3JtU3RhdGUuZXJyb3JzKSkge1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGVycm9yczoge30sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgYXdhaXQgb25WYWxpZChmaWVsZFZhbHVlcywgZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgICAgICAgICBvblZhbGlkRXJyb3IgPSBlcnJvcjtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGlmIChvbkludmFsaWQpIHtcbiAgICAgICAgICAgICAgICBhd2FpdCBvbkludmFsaWQoeyAuLi5fZm9ybVN0YXRlLmVycm9ycyB9LCBlKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb2N1c0Vycm9yKCk7XG4gICAgICAgICAgICBzZXRUaW1lb3V0KF9mb2N1c0Vycm9yKTtcbiAgICAgICAgfVxuICAgICAgICBfc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICBpc1N1Ym1pdHRlZDogdHJ1ZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGlzRW1wdHlPYmplY3QoX2Zvcm1TdGF0ZS5lcnJvcnMpICYmICFvblZhbGlkRXJyb3IsXG4gICAgICAgICAgICBzdWJtaXRDb3VudDogX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudCArIDEsXG4gICAgICAgICAgICBlcnJvcnM6IF9mb3JtU3RhdGUuZXJyb3JzLFxuICAgICAgICB9KTtcbiAgICAgICAgaWYgKG9uVmFsaWRFcnJvcikge1xuICAgICAgICAgICAgdGhyb3cgb25WYWxpZEVycm9yO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCByZXNldEZpZWxkID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBpZiAoZ2V0KF9maWVsZHMsIG5hbWUpKSB7XG4gICAgICAgICAgICBpZiAoaXNVbmRlZmluZWQob3B0aW9ucy5kZWZhdWx0VmFsdWUpKSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgc2V0VmFsdWUobmFtZSwgb3B0aW9ucy5kZWZhdWx0VmFsdWUpO1xuICAgICAgICAgICAgICAgIHNldChfZGVmYXVsdFZhbHVlcywgbmFtZSwgY2xvbmVPYmplY3Qob3B0aW9ucy5kZWZhdWx0VmFsdWUpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmICghb3B0aW9ucy5rZWVwVG91Y2hlZCkge1xuICAgICAgICAgICAgICAgIHVuc2V0KF9mb3JtU3RhdGUudG91Y2hlZEZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcERpcnR5KSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgX2Zvcm1TdGF0ZS5pc0RpcnR5ID0gb3B0aW9ucy5kZWZhdWx0VmFsdWVcbiAgICAgICAgICAgICAgICAgICAgPyBfZ2V0RGlydHkobmFtZSwgY2xvbmVPYmplY3QoZ2V0KF9kZWZhdWx0VmFsdWVzLCBuYW1lKSkpXG4gICAgICAgICAgICAgICAgICAgIDogX2dldERpcnR5KCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAoIW9wdGlvbnMua2VlcEVycm9yKSB7XG4gICAgICAgICAgICAgICAgdW5zZXQoX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUpO1xuICAgICAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZS5pc1ZhbGlkICYmIF9zZXRWYWxpZCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoeyAuLi5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucyA9IHt9KSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRWYWx1ZXMgPSBmb3JtVmFsdWVzID8gY2xvbmVPYmplY3QoZm9ybVZhbHVlcykgOiBfZGVmYXVsdFZhbHVlcztcbiAgICAgICAgY29uc3QgY2xvbmVVcGRhdGVkVmFsdWVzID0gY2xvbmVPYmplY3QodXBkYXRlZFZhbHVlcyk7XG4gICAgICAgIGNvbnN0IGlzRW1wdHlSZXNldFZhbHVlcyA9IGlzRW1wdHlPYmplY3QoZm9ybVZhbHVlcyk7XG4gICAgICAgIGNvbnN0IHZhbHVlcyA9IGlzRW1wdHlSZXNldFZhbHVlcyA/IF9kZWZhdWx0VmFsdWVzIDogY2xvbmVVcGRhdGVkVmFsdWVzO1xuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMpIHtcbiAgICAgICAgICAgIF9kZWZhdWx0VmFsdWVzID0gdXBkYXRlZFZhbHVlcztcbiAgICAgICAgfVxuICAgICAgICBpZiAoIWtlZXBTdGF0ZU9wdGlvbnMua2VlcFZhbHVlcykge1xuICAgICAgICAgICAgaWYgKGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzKSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGRzVG9DaGVjayA9IG5ldyBTZXQoW1xuICAgICAgICAgICAgICAgICAgICAuLi5fbmFtZXMubW91bnQsXG4gICAgICAgICAgICAgICAgICAgIC4uLk9iamVjdC5rZXlzKGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBfZm9ybVZhbHVlcykpLFxuICAgICAgICAgICAgICAgIF0pO1xuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIEFycmF5LmZyb20oZmllbGRzVG9DaGVjaykpIHtcbiAgICAgICAgICAgICAgICAgICAgZ2V0KF9mb3JtU3RhdGUuZGlydHlGaWVsZHMsIGZpZWxkTmFtZSlcbiAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KHZhbHVlcywgZmllbGROYW1lLCBnZXQoX2Zvcm1WYWx1ZXMsIGZpZWxkTmFtZSkpXG4gICAgICAgICAgICAgICAgICAgICAgICA6IHNldFZhbHVlKGZpZWxkTmFtZSwgZ2V0KHZhbHVlcywgZmllbGROYW1lKSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgaWYgKGlzV2ViICYmIGlzVW5kZWZpbmVkKGZvcm1WYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIGZvciAoY29uc3QgbmFtZSBvZiBfbmFtZXMubW91bnQpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KF9maWVsZHMsIG5hbWUpO1xuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBBcnJheS5pc0FycmF5KGZpZWxkLl9mLnJlZnMpXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gZmllbGQuX2YucmVmc1swXVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICA6IGZpZWxkLl9mLnJlZjtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAoaXNIVE1MRWxlbWVudChmaWVsZFJlZmVyZW5jZSkpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3QgZm9ybSA9IGZpZWxkUmVmZXJlbmNlLmNsb3Nlc3QoJ2Zvcm0nKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGZvcm0pIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGZvcm0ucmVzZXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIGZvciAoY29uc3QgZmllbGROYW1lIG9mIF9uYW1lcy5tb3VudCkge1xuICAgICAgICAgICAgICAgICAgICBzZXRWYWx1ZShmaWVsZE5hbWUsIGdldCh2YWx1ZXMsIGZpZWxkTmFtZSkpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIF9mb3JtVmFsdWVzID0gY2xvbmVPYmplY3QodmFsdWVzKTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5hcnJheS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICB2YWx1ZXM6IHsgLi4udmFsdWVzIH0sXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfVxuICAgICAgICBfbmFtZXMgPSB7XG4gICAgICAgICAgICBtb3VudDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGlydHlWYWx1ZXMgPyBfbmFtZXMubW91bnQgOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB1bk1vdW50OiBuZXcgU2V0KCksXG4gICAgICAgICAgICBhcnJheTogbmV3IFNldCgpLFxuICAgICAgICAgICAgZGlzYWJsZWQ6IG5ldyBTZXQoKSxcbiAgICAgICAgICAgIHdhdGNoOiBuZXcgU2V0KCksXG4gICAgICAgICAgICB3YXRjaEFsbDogZmFsc2UsXG4gICAgICAgICAgICBmb2N1czogJycsXG4gICAgICAgIH07XG4gICAgICAgIF9zdGF0ZS5tb3VudCA9XG4gICAgICAgICAgICAhX3Byb3h5Rm9ybVN0YXRlLmlzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcElzVmFsaWQgfHxcbiAgICAgICAgICAgICAgICAhIWtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5VmFsdWVzO1xuICAgICAgICBfc3RhdGUud2F0Y2ggPSAhIV9vcHRpb25zLnNob3VsZFVucmVnaXN0ZXI7XG4gICAgICAgIF9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgIHN1Ym1pdENvdW50OiBrZWVwU3RhdGVPcHRpb25zLmtlZXBTdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5zdWJtaXRDb3VudFxuICAgICAgICAgICAgICAgIDogMCxcbiAgICAgICAgICAgIGlzRGlydHk6IGlzRW1wdHlSZXNldFZhbHVlc1xuICAgICAgICAgICAgICAgID8gZmFsc2VcbiAgICAgICAgICAgICAgICA6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERpcnR5XG4gICAgICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5pc0RpcnR5XG4gICAgICAgICAgICAgICAgICAgIDogISEoa2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgIWRlZXBFcXVhbChmb3JtVmFsdWVzLCBfZGVmYXVsdFZhbHVlcykpLFxuICAgICAgICAgICAgaXNTdWJtaXR0ZWQ6IGtlZXBTdGF0ZU9wdGlvbnMua2VlcElzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLmlzU3VibWl0dGVkXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGRpcnR5RmllbGRzOiBpc0VtcHR5UmVzZXRWYWx1ZXNcbiAgICAgICAgICAgICAgICA/IHt9XG4gICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVZhbHVlc1xuICAgICAgICAgICAgICAgICAgICA/IGtlZXBTdGF0ZU9wdGlvbnMua2VlcERlZmF1bHRWYWx1ZXMgJiYgX2Zvcm1WYWx1ZXNcbiAgICAgICAgICAgICAgICAgICAgICAgID8gZ2V0RGlydHlGaWVsZHMoX2RlZmF1bHRWYWx1ZXMsIF9mb3JtVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBfZm9ybVN0YXRlLmRpcnR5RmllbGRzXG4gICAgICAgICAgICAgICAgICAgIDoga2VlcFN0YXRlT3B0aW9ucy5rZWVwRGVmYXVsdFZhbHVlcyAmJiBmb3JtVmFsdWVzXG4gICAgICAgICAgICAgICAgICAgICAgICA/IGdldERpcnR5RmllbGRzKF9kZWZhdWx0VmFsdWVzLCBmb3JtVmFsdWVzKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBEaXJ0eVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gX2Zvcm1TdGF0ZS5kaXJ0eUZpZWxkc1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDoge30sXG4gICAgICAgICAgICB0b3VjaGVkRmllbGRzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBUb3VjaGVkXG4gICAgICAgICAgICAgICAgPyBfZm9ybVN0YXRlLnRvdWNoZWRGaWVsZHNcbiAgICAgICAgICAgICAgICA6IHt9LFxuICAgICAgICAgICAgZXJyb3JzOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBFcnJvcnMgPyBfZm9ybVN0YXRlLmVycm9ycyA6IHt9LFxuICAgICAgICAgICAgaXNTdWJtaXRTdWNjZXNzZnVsOiBrZWVwU3RhdGVPcHRpb25zLmtlZXBJc1N1Ym1pdFN1Y2Nlc3NmdWxcbiAgICAgICAgICAgICAgICA/IF9mb3JtU3RhdGUuaXNTdWJtaXRTdWNjZXNzZnVsXG4gICAgICAgICAgICAgICAgOiBmYWxzZSxcbiAgICAgICAgICAgIGlzU3VibWl0dGluZzogZmFsc2UsXG4gICAgICAgIH0pO1xuICAgIH07XG4gICAgY29uc3QgcmVzZXQgPSAoZm9ybVZhbHVlcywga2VlcFN0YXRlT3B0aW9ucykgPT4gX3Jlc2V0KGlzRnVuY3Rpb24oZm9ybVZhbHVlcylcbiAgICAgICAgPyBmb3JtVmFsdWVzKF9mb3JtVmFsdWVzKVxuICAgICAgICA6IGZvcm1WYWx1ZXMsIGtlZXBTdGF0ZU9wdGlvbnMpO1xuICAgIGNvbnN0IHNldEZvY3VzID0gKG5hbWUsIG9wdGlvbnMgPSB7fSkgPT4ge1xuICAgICAgICBjb25zdCBmaWVsZCA9IGdldChfZmllbGRzLCBuYW1lKTtcbiAgICAgICAgY29uc3QgZmllbGRSZWZlcmVuY2UgPSBmaWVsZCAmJiBmaWVsZC5fZjtcbiAgICAgICAgaWYgKGZpZWxkUmVmZXJlbmNlKSB7XG4gICAgICAgICAgICBjb25zdCBmaWVsZFJlZiA9IGZpZWxkUmVmZXJlbmNlLnJlZnNcbiAgICAgICAgICAgICAgICA/IGZpZWxkUmVmZXJlbmNlLnJlZnNbMF1cbiAgICAgICAgICAgICAgICA6IGZpZWxkUmVmZXJlbmNlLnJlZjtcbiAgICAgICAgICAgIGlmIChmaWVsZFJlZi5mb2N1cykge1xuICAgICAgICAgICAgICAgIGZpZWxkUmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgb3B0aW9ucy5zaG91bGRTZWxlY3QgJiZcbiAgICAgICAgICAgICAgICAgICAgaXNGdW5jdGlvbihmaWVsZFJlZi5zZWxlY3QpICYmXG4gICAgICAgICAgICAgICAgICAgIGZpZWxkUmVmLnNlbGVjdCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgfTtcbiAgICBjb25zdCBfc2V0Rm9ybVN0YXRlID0gKHVwZGF0ZWRGb3JtU3RhdGUpID0+IHtcbiAgICAgICAgX2Zvcm1TdGF0ZSA9IHtcbiAgICAgICAgICAgIC4uLl9mb3JtU3RhdGUsXG4gICAgICAgICAgICAuLi51cGRhdGVkRm9ybVN0YXRlLFxuICAgICAgICB9O1xuICAgIH07XG4gICAgY29uc3QgX3Jlc2V0RGVmYXVsdFZhbHVlcyA9ICgpID0+IGlzRnVuY3Rpb24oX29wdGlvbnMuZGVmYXVsdFZhbHVlcykgJiZcbiAgICAgICAgX29wdGlvbnMuZGVmYXVsdFZhbHVlcygpLnRoZW4oKHZhbHVlcykgPT4ge1xuICAgICAgICAgICAgcmVzZXQodmFsdWVzLCBfb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIGlzTG9hZGluZzogZmFsc2UsXG4gICAgICAgICAgICB9KTtcbiAgICAgICAgfSk7XG4gICAgY29uc3QgbWV0aG9kcyA9IHtcbiAgICAgICAgY29udHJvbDoge1xuICAgICAgICAgICAgcmVnaXN0ZXIsXG4gICAgICAgICAgICB1bnJlZ2lzdGVyLFxuICAgICAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICAgICAgICAgIGhhbmRsZVN1Ym1pdCxcbiAgICAgICAgICAgIHNldEVycm9yLFxuICAgICAgICAgICAgX3N1YnNjcmliZSxcbiAgICAgICAgICAgIF9ydW5TY2hlbWEsXG4gICAgICAgICAgICBfZm9jdXNFcnJvcixcbiAgICAgICAgICAgIF9nZXRXYXRjaCxcbiAgICAgICAgICAgIF9nZXREaXJ0eSxcbiAgICAgICAgICAgIF9zZXRWYWxpZCxcbiAgICAgICAgICAgIF9zZXRGaWVsZEFycmF5LFxuICAgICAgICAgICAgX3NldERpc2FibGVkRmllbGQsXG4gICAgICAgICAgICBfc2V0RXJyb3JzLFxuICAgICAgICAgICAgX2dldEZpZWxkQXJyYXksXG4gICAgICAgICAgICBfcmVzZXQsXG4gICAgICAgICAgICBfcmVzZXREZWZhdWx0VmFsdWVzLFxuICAgICAgICAgICAgX3JlbW92ZVVubW91bnRlZCxcbiAgICAgICAgICAgIF9kaXNhYmxlRm9ybSxcbiAgICAgICAgICAgIF9zdWJqZWN0cyxcbiAgICAgICAgICAgIF9wcm94eUZvcm1TdGF0ZSxcbiAgICAgICAgICAgIGdldCBfZmllbGRzKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfZmllbGRzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfZm9ybVZhbHVlcygpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX2Zvcm1WYWx1ZXM7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9zdGF0ZSgpIHtcbiAgICAgICAgICAgICAgICByZXR1cm4gX3N0YXRlO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIHNldCBfc3RhdGUodmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfc3RhdGUgPSB2YWx1ZTtcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBnZXQgX2RlZmF1bHRWYWx1ZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9kZWZhdWx0VmFsdWVzO1xuICAgICAgICAgICAgfSxcbiAgICAgICAgICAgIGdldCBfbmFtZXMoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9uYW1lcztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX25hbWVzKHZhbHVlKSB7XG4gICAgICAgICAgICAgICAgX25hbWVzID0gdmFsdWU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9mb3JtU3RhdGUoKSB7XG4gICAgICAgICAgICAgICAgcmV0dXJuIF9mb3JtU3RhdGU7XG4gICAgICAgICAgICB9LFxuICAgICAgICAgICAgZ2V0IF9vcHRpb25zKCkge1xuICAgICAgICAgICAgICAgIHJldHVybiBfb3B0aW9ucztcbiAgICAgICAgICAgIH0sXG4gICAgICAgICAgICBzZXQgX29wdGlvbnModmFsdWUpIHtcbiAgICAgICAgICAgICAgICBfb3B0aW9ucyA9IHtcbiAgICAgICAgICAgICAgICAgICAgLi4uX29wdGlvbnMsXG4gICAgICAgICAgICAgICAgICAgIC4uLnZhbHVlLFxuICAgICAgICAgICAgICAgIH07XG4gICAgICAgICAgICB9LFxuICAgICAgICB9LFxuICAgICAgICBzdWJzY3JpYmUsXG4gICAgICAgIHRyaWdnZXIsXG4gICAgICAgIHJlZ2lzdGVyLFxuICAgICAgICBoYW5kbGVTdWJtaXQsXG4gICAgICAgIHdhdGNoLFxuICAgICAgICBzZXRWYWx1ZSxcbiAgICAgICAgZ2V0VmFsdWVzLFxuICAgICAgICByZXNldCxcbiAgICAgICAgcmVzZXRGaWVsZCxcbiAgICAgICAgY2xlYXJFcnJvcnMsXG4gICAgICAgIHVucmVnaXN0ZXIsXG4gICAgICAgIHNldEVycm9yLFxuICAgICAgICBzZXRGb2N1cyxcbiAgICAgICAgZ2V0RmllbGRTdGF0ZSxcbiAgICB9O1xuICAgIHJldHVybiB7XG4gICAgICAgIC4uLm1ldGhvZHMsXG4gICAgICAgIGZvcm1Db250cm9sOiBtZXRob2RzLFxuICAgIH07XG59XG5cbnZhciBnZW5lcmF0ZUlkID0gKCkgPT4ge1xuICAgIGlmICh0eXBlb2YgY3J5cHRvICE9PSAndW5kZWZpbmVkJyAmJiBjcnlwdG8ucmFuZG9tVVVJRCkge1xuICAgICAgICByZXR1cm4gY3J5cHRvLnJhbmRvbVVVSUQoKTtcbiAgICB9XG4gICAgY29uc3QgZCA9IHR5cGVvZiBwZXJmb3JtYW5jZSA9PT0gJ3VuZGVmaW5lZCcgPyBEYXRlLm5vdygpIDogcGVyZm9ybWFuY2Uubm93KCkgKiAxMDAwO1xuICAgIHJldHVybiAneHh4eHh4eHgteHh4eC00eHh4LXl4eHgteHh4eHh4eHh4eHh4Jy5yZXBsYWNlKC9beHldL2csIChjKSA9PiB7XG4gICAgICAgIGNvbnN0IHIgPSAoTWF0aC5yYW5kb20oKSAqIDE2ICsgZCkgJSAxNiB8IDA7XG4gICAgICAgIHJldHVybiAoYyA9PSAneCcgPyByIDogKHIgJiAweDMpIHwgMHg4KS50b1N0cmluZygxNik7XG4gICAgfSk7XG59O1xuXG52YXIgZ2V0Rm9jdXNGaWVsZE5hbWUgPSAobmFtZSwgaW5kZXgsIG9wdGlvbnMgPSB7fSkgPT4gb3B0aW9ucy5zaG91bGRGb2N1cyB8fCBpc1VuZGVmaW5lZChvcHRpb25zLnNob3VsZEZvY3VzKVxuICAgID8gb3B0aW9ucy5mb2N1c05hbWUgfHxcbiAgICAgICAgYCR7bmFtZX0uJHtpc1VuZGVmaW5lZChvcHRpb25zLmZvY3VzSW5kZXgpID8gaW5kZXggOiBvcHRpb25zLmZvY3VzSW5kZXh9LmBcbiAgICA6ICcnO1xuXG52YXIgYXBwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5kYXRhLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZCh2YWx1ZSksXG5dO1xuXG52YXIgZmlsbEVtcHR5QXJyYXkgPSAodmFsdWUpID0+IEFycmF5LmlzQXJyYXkodmFsdWUpID8gdmFsdWUubWFwKCgpID0+IHVuZGVmaW5lZCkgOiB1bmRlZmluZWQ7XG5cbmZ1bmN0aW9uIGluc2VydChkYXRhLCBpbmRleCwgdmFsdWUpIHtcbiAgICByZXR1cm4gW1xuICAgICAgICAuLi5kYXRhLnNsaWNlKDAsIGluZGV4KSxcbiAgICAgICAgLi4uY29udmVydFRvQXJyYXlQYXlsb2FkKHZhbHVlKSxcbiAgICAgICAgLi4uZGF0YS5zbGljZShpbmRleCksXG4gICAgXTtcbn1cblxudmFyIG1vdmVBcnJheUF0ID0gKGRhdGEsIGZyb20sIHRvKSA9PiB7XG4gICAgaWYgKCFBcnJheS5pc0FycmF5KGRhdGEpKSB7XG4gICAgICAgIHJldHVybiBbXTtcbiAgICB9XG4gICAgaWYgKGlzVW5kZWZpbmVkKGRhdGFbdG9dKSkge1xuICAgICAgICBkYXRhW3RvXSA9IHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZGF0YS5zcGxpY2UodG8sIDAsIGRhdGEuc3BsaWNlKGZyb20sIDEpWzBdKTtcbiAgICByZXR1cm4gZGF0YTtcbn07XG5cbnZhciBwcmVwZW5kQXQgPSAoZGF0YSwgdmFsdWUpID0+IFtcbiAgICAuLi5jb252ZXJ0VG9BcnJheVBheWxvYWQodmFsdWUpLFxuICAgIC4uLmNvbnZlcnRUb0FycmF5UGF5bG9hZChkYXRhKSxcbl07XG5cbmZ1bmN0aW9uIHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBpbmRleGVzKSB7XG4gICAgbGV0IGkgPSAwO1xuICAgIGNvbnN0IHRlbXAgPSBbLi4uZGF0YV07XG4gICAgZm9yIChjb25zdCBpbmRleCBvZiBpbmRleGVzKSB7XG4gICAgICAgIHRlbXAuc3BsaWNlKGluZGV4IC0gaSwgMSk7XG4gICAgICAgIGkrKztcbiAgICB9XG4gICAgcmV0dXJuIGNvbXBhY3QodGVtcCkubGVuZ3RoID8gdGVtcCA6IFtdO1xufVxudmFyIHJlbW92ZUFycmF5QXQgPSAoZGF0YSwgaW5kZXgpID0+IGlzVW5kZWZpbmVkKGluZGV4KVxuICAgID8gW11cbiAgICA6IHJlbW92ZUF0SW5kZXhlcyhkYXRhLCBjb252ZXJ0VG9BcnJheVBheWxvYWQoaW5kZXgpLnNvcnQoKGEsIGIpID0+IGEgLSBiKSk7XG5cbnZhciBzd2FwQXJyYXlBdCA9IChkYXRhLCBpbmRleEEsIGluZGV4QikgPT4ge1xuICAgIFtkYXRhW2luZGV4QV0sIGRhdGFbaW5kZXhCXV0gPSBbZGF0YVtpbmRleEJdLCBkYXRhW2luZGV4QV1dO1xufTtcblxudmFyIHVwZGF0ZUF0ID0gKGZpZWxkVmFsdWVzLCBpbmRleCwgdmFsdWUpID0+IHtcbiAgICBmaWVsZFZhbHVlc1tpbmRleF0gPSB2YWx1ZTtcbiAgICByZXR1cm4gZmllbGRWYWx1ZXM7XG59O1xuXG4vKipcbiAqIEEgY3VzdG9tIGhvb2sgdGhhdCBleHBvc2VzIGNvbnZlbmllbnQgbWV0aG9kcyB0byBwZXJmb3JtIG9wZXJhdGlvbnMgd2l0aCBhIGxpc3Qgb2YgZHluYW1pYyBpbnB1dHMgdGhhdCBuZWVkIHRvIGJlIGFwcGVuZGVkLCB1cGRhdGVkLCByZW1vdmVkIGV0Yy4g4oCiIFtEZW1vXShodHRwczovL2NvZGVzYW5kYm94LmlvL3MvcmVhY3QtaG9vay1mb3JtLXVzZWZpZWxkYXJyYXktc3N1Z24pIOKAoiBbVmlkZW9dKGh0dHBzOi8veW91dHUuYmUvNE1yYmZHU0ZZMkEpXG4gKlxuICogQHJlbWFya3NcbiAqIFtBUEldKGh0dHBzOi8vcmVhY3QtaG9vay1mb3JtLmNvbS9kb2NzL3VzZWZpZWxkYXJyYXkpIOKAoiBbRGVtb10oaHR0cHM6Ly9jb2Rlc2FuZGJveC5pby9zL3JlYWN0LWhvb2stZm9ybS11c2VmaWVsZGFycmF5LXNzdWduKVxuICpcbiAqIEBwYXJhbSBwcm9wcyAtIHVzZUZpZWxkQXJyYXkgcHJvcHNcbiAqXG4gKiBAcmV0dXJucyBtZXRob2RzIC0gZnVuY3Rpb25zIHRvIG1hbmlwdWxhdGUgd2l0aCB0aGUgRmllbGQgQXJyYXlzIChkeW5hbWljIGlucHV0cykge0BsaW5rIFVzZUZpZWxkQXJyYXlSZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBjb250cm9sLCBoYW5kbGVTdWJtaXQsIHJlc2V0LCB0cmlnZ2VyLCBzZXRFcnJvciB9ID0gdXNlRm9ybSh7XG4gKiAgICAgZGVmYXVsdFZhbHVlczoge1xuICogICAgICAgdGVzdDogW11cbiAqICAgICB9XG4gKiAgIH0pO1xuICogICBjb25zdCB7IGZpZWxkcywgYXBwZW5kIH0gPSB1c2VGaWVsZEFycmF5KHtcbiAqICAgICBjb250cm9sLFxuICogICAgIG5hbWU6IFwidGVzdFwiXG4gKiAgIH0pO1xuICpcbiAqICAgcmV0dXJuIChcbiAqICAgICA8Zm9ybSBvblN1Ym1pdD17aGFuZGxlU3VibWl0KGRhdGEgPT4gY29uc29sZS5sb2coZGF0YSkpfT5cbiAqICAgICAgIHtmaWVsZHMubWFwKChpdGVtLCBpbmRleCkgPT4gKFxuICogICAgICAgICAgPGlucHV0IGtleT17aXRlbS5pZH0gey4uLnJlZ2lzdGVyKGB0ZXN0LiR7aW5kZXh9LmZpcnN0TmFtZWApfSAgLz5cbiAqICAgICAgICkpfVxuICogICAgICAgPGJ1dHRvbiB0eXBlPVwiYnV0dG9uXCIgb25DbGljaz17KCkgPT4gYXBwZW5kKHsgZmlyc3ROYW1lOiBcImJpbGxcIiB9KX0+XG4gKiAgICAgICAgIGFwcGVuZFxuICogICAgICAgPC9idXR0b24+XG4gKiAgICAgICA8aW5wdXQgdHlwZT1cInN1Ym1pdFwiIC8+XG4gKiAgICAgPC9mb3JtPlxuICogICApO1xuICogfVxuICogYGBgXG4gKi9cbmZ1bmN0aW9uIHVzZUZpZWxkQXJyYXkocHJvcHMpIHtcbiAgICBjb25zdCBtZXRob2RzID0gdXNlRm9ybUNvbnRleHQoKTtcbiAgICBjb25zdCB7IGNvbnRyb2wgPSBtZXRob2RzLmNvbnRyb2wsIG5hbWUsIGtleU5hbWUgPSAnaWQnLCBzaG91bGRVbnJlZ2lzdGVyLCBydWxlcywgfSA9IHByb3BzO1xuICAgIGNvbnN0IFtmaWVsZHMsIHNldEZpZWxkc10gPSBSZWFjdF9fZGVmYXVsdC51c2VTdGF0ZShjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpKTtcbiAgICBjb25zdCBpZHMgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKS5tYXAoZ2VuZXJhdGVJZCkpO1xuICAgIGNvbnN0IF9maWVsZElkcyA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihmaWVsZHMpO1xuICAgIGNvbnN0IF9uYW1lID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKG5hbWUpO1xuICAgIGNvbnN0IF9hY3Rpb25lZCA9IFJlYWN0X19kZWZhdWx0LnVzZVJlZihmYWxzZSk7XG4gICAgX25hbWUuY3VycmVudCA9IG5hbWU7XG4gICAgX2ZpZWxkSWRzLmN1cnJlbnQgPSBmaWVsZHM7XG4gICAgY29udHJvbC5fbmFtZXMuYXJyYXkuYWRkKG5hbWUpO1xuICAgIHJ1bGVzICYmXG4gICAgICAgIGNvbnRyb2wucmVnaXN0ZXIobmFtZSwgcnVsZXMpO1xuICAgIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gY29udHJvbC5fc3ViamVjdHMuYXJyYXkuc3Vic2NyaWJlKHtcbiAgICAgICAgbmV4dDogKHsgdmFsdWVzLCBuYW1lOiBmaWVsZEFycmF5TmFtZSwgfSkgPT4ge1xuICAgICAgICAgICAgaWYgKGZpZWxkQXJyYXlOYW1lID09PSBfbmFtZS5jdXJyZW50IHx8ICFmaWVsZEFycmF5TmFtZSkge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkVmFsdWVzID0gZ2V0KHZhbHVlcywgX25hbWUuY3VycmVudCk7XG4gICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmllbGRWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgICAgIHNldEZpZWxkcyhmaWVsZFZhbHVlcyk7XG4gICAgICAgICAgICAgICAgICAgIGlkcy5jdXJyZW50ID0gZmllbGRWYWx1ZXMubWFwKGdlbmVyYXRlSWQpO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgfSxcbiAgICB9KS51bnN1YnNjcmliZSwgW2NvbnRyb2xdKTtcbiAgICBjb25zdCB1cGRhdGVWYWx1ZXMgPSBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjaygodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMpID0+IHtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSB0cnVlO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICB9LCBbY29udHJvbCwgbmFtZV0pO1xuICAgIGNvbnN0IGFwcGVuZCA9ICh2YWx1ZSwgb3B0aW9ucykgPT4ge1xuICAgICAgICBjb25zdCBhcHBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGFwcGVuZEF0KGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSksIGFwcGVuZFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5sZW5ndGggLSAxLCBvcHRpb25zKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBhcHBlbmRBdChpZHMuY3VycmVudCwgYXBwZW5kVmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgYXBwZW5kQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBwcmVwZW5kID0gKHZhbHVlLCBvcHRpb25zKSA9PiB7XG4gICAgICAgIGNvbnN0IHByZXBlbmRWYWx1ZSA9IGNvbnZlcnRUb0FycmF5UGF5bG9hZChjbG9uZU9iamVjdCh2YWx1ZSkpO1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHByZXBlbmRBdChjb250cm9sLl9nZXRGaWVsZEFycmF5KG5hbWUpLCBwcmVwZW5kVmFsdWUpO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyA9IGdldEZvY3VzRmllbGROYW1lKG5hbWUsIDAsIG9wdGlvbnMpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHByZXBlbmRBdChpZHMuY3VycmVudCwgcHJlcGVuZFZhbHVlLm1hcChnZW5lcmF0ZUlkKSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIHByZXBlbmRBdCwge1xuICAgICAgICAgICAgYXJnQTogZmlsbEVtcHR5QXJyYXkodmFsdWUpLFxuICAgICAgICB9KTtcbiAgICB9O1xuICAgIGNvbnN0IHJlbW92ZSA9IChpbmRleCkgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IHJlbW92ZUFycmF5QXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgpO1xuICAgICAgICBpZHMuY3VycmVudCA9IHJlbW92ZUFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4KTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgIUFycmF5LmlzQXJyYXkoZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSkpICYmXG4gICAgICAgICAgICBzZXQoY29udHJvbC5fZmllbGRzLCBuYW1lLCB1bmRlZmluZWQpO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCByZW1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBpbnNlcnQkMSA9IChpbmRleCwgdmFsdWUsIG9wdGlvbnMpID0+IHtcbiAgICAgICAgY29uc3QgaW5zZXJ0VmFsdWUgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBpbnNlcnQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIGluc2VydFZhbHVlKTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSBnZXRGb2N1c0ZpZWxkTmFtZShuYW1lLCBpbmRleCwgb3B0aW9ucyk7XG4gICAgICAgIGlkcy5jdXJyZW50ID0gaW5zZXJ0KGlkcy5jdXJyZW50LCBpbmRleCwgaW5zZXJ0VmFsdWUubWFwKGdlbmVyYXRlSWQpKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgaW5zZXJ0LCB7XG4gICAgICAgICAgICBhcmdBOiBpbmRleCxcbiAgICAgICAgICAgIGFyZ0I6IGZpbGxFbXB0eUFycmF5KHZhbHVlKSxcbiAgICAgICAgfSk7XG4gICAgfTtcbiAgICBjb25zdCBzd2FwID0gKGluZGV4QSwgaW5kZXhCKSA9PiB7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKTtcbiAgICAgICAgc3dhcEFycmF5QXQodXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgc3dhcEFycmF5QXQoaWRzLmN1cnJlbnQsIGluZGV4QSwgaW5kZXhCKTtcbiAgICAgICAgdXBkYXRlVmFsdWVzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgc2V0RmllbGRzKHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgc3dhcEFycmF5QXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4QSxcbiAgICAgICAgICAgIGFyZ0I6IGluZGV4QixcbiAgICAgICAgfSwgZmFsc2UpO1xuICAgIH07XG4gICAgY29uc3QgbW92ZSA9IChmcm9tLCB0bykgPT4ge1xuICAgICAgICBjb25zdCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcyA9IGNvbnRyb2wuX2dldEZpZWxkQXJyYXkobmFtZSk7XG4gICAgICAgIG1vdmVBcnJheUF0KHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzLCBmcm9tLCB0byk7XG4gICAgICAgIG1vdmVBcnJheUF0KGlkcy5jdXJyZW50LCBmcm9tLCB0byk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIGNvbnRyb2wuX3NldEZpZWxkQXJyYXkobmFtZSwgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMsIG1vdmVBcnJheUF0LCB7XG4gICAgICAgICAgICBhcmdBOiBmcm9tLFxuICAgICAgICAgICAgYXJnQjogdG8sXG4gICAgICAgIH0sIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHVwZGF0ZSA9IChpbmRleCwgdmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlVmFsdWUgPSBjbG9uZU9iamVjdCh2YWx1ZSk7XG4gICAgICAgIGNvbnN0IHVwZGF0ZWRGaWVsZEFycmF5VmFsdWVzID0gdXBkYXRlQXQoY29udHJvbC5fZ2V0RmllbGRBcnJheShuYW1lKSwgaW5kZXgsIHVwZGF0ZVZhbHVlKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSBbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdLm1hcCgoaXRlbSwgaSkgPT4gIWl0ZW0gfHwgaSA9PT0gaW5kZXggPyBnZW5lcmF0ZUlkKCkgOiBpZHMuY3VycmVudFtpXSk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyh1cGRhdGVkRmllbGRBcnJheVZhbHVlcyk7XG4gICAgICAgIHNldEZpZWxkcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgY29udHJvbC5fc2V0RmllbGRBcnJheShuYW1lLCB1cGRhdGVkRmllbGRBcnJheVZhbHVlcywgdXBkYXRlQXQsIHtcbiAgICAgICAgICAgIGFyZ0E6IGluZGV4LFxuICAgICAgICAgICAgYXJnQjogdXBkYXRlVmFsdWUsXG4gICAgICAgIH0sIHRydWUsIGZhbHNlKTtcbiAgICB9O1xuICAgIGNvbnN0IHJlcGxhY2UgPSAodmFsdWUpID0+IHtcbiAgICAgICAgY29uc3QgdXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXMgPSBjb252ZXJ0VG9BcnJheVBheWxvYWQoY2xvbmVPYmplY3QodmFsdWUpKTtcbiAgICAgICAgaWRzLmN1cnJlbnQgPSB1cGRhdGVkRmllbGRBcnJheVZhbHVlcy5tYXAoZ2VuZXJhdGVJZCk7XG4gICAgICAgIHVwZGF0ZVZhbHVlcyhbLi4udXBkYXRlZEZpZWxkQXJyYXlWYWx1ZXNdKTtcbiAgICAgICAgc2V0RmllbGRzKFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10pO1xuICAgICAgICBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUsIFsuLi51cGRhdGVkRmllbGRBcnJheVZhbHVlc10sIChkYXRhKSA9PiBkYXRhLCB7fSwgdHJ1ZSwgZmFsc2UpO1xuICAgIH07XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgY29udHJvbC5fc3RhdGUuYWN0aW9uID0gZmFsc2U7XG4gICAgICAgIGlzV2F0Y2hlZChuYW1lLCBjb250cm9sLl9uYW1lcykgJiZcbiAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgIC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSxcbiAgICAgICAgICAgIH0pO1xuICAgICAgICBpZiAoX2FjdGlvbmVkLmN1cnJlbnQgJiZcbiAgICAgICAgICAgICghZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCB8fFxuICAgICAgICAgICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1N1Ym1pdHRlZCkgJiZcbiAgICAgICAgICAgICFnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSkuaXNPblN1Ym1pdCkge1xuICAgICAgICAgICAgaWYgKGNvbnRyb2wuX29wdGlvbnMucmVzb2x2ZXIpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9ydW5TY2hlbWEoW25hbWVdKS50aGVuKChyZXN1bHQpID0+IHtcbiAgICAgICAgICAgICAgICAgICAgY29uc3QgZXJyb3IgPSBnZXQocmVzdWx0LmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGNvbnN0IGV4aXN0aW5nRXJyb3IgPSBnZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgIGlmIChleGlzdGluZ0Vycm9yXG4gICAgICAgICAgICAgICAgICAgICAgICA/ICghZXJyb3IgJiYgZXhpc3RpbmdFcnJvci50eXBlKSB8fFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIChlcnJvciAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAoZXhpc3RpbmdFcnJvci50eXBlICE9PSBlcnJvci50eXBlIHx8XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBleGlzdGluZ0Vycm9yLm1lc3NhZ2UgIT09IGVycm9yLm1lc3NhZ2UpKVxuICAgICAgICAgICAgICAgICAgICAgICAgOiBlcnJvciAmJiBlcnJvci50eXBlKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBlcnJvclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgID8gc2V0KGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsIG5hbWUsIGVycm9yKVxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIDogdW5zZXQoY29udHJvbC5fZm9ybVN0YXRlLmVycm9ycywgbmFtZSk7XG4gICAgICAgICAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlcnJvcnM6IGNvbnRyb2wuX2Zvcm1TdGF0ZS5lcnJvcnMsXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgY29uc3QgZmllbGQgPSBnZXQoY29udHJvbC5fZmllbGRzLCBuYW1lKTtcbiAgICAgICAgICAgICAgICBpZiAoZmllbGQgJiZcbiAgICAgICAgICAgICAgICAgICAgZmllbGQuX2YgJiZcbiAgICAgICAgICAgICAgICAgICAgIShnZXRWYWxpZGF0aW9uTW9kZXMoY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSkuaXNPblN1Ym1pdCAmJlxuICAgICAgICAgICAgICAgICAgICAgICAgZ2V0VmFsaWRhdGlvbk1vZGVzKGNvbnRyb2wuX29wdGlvbnMubW9kZSkuaXNPblN1Ym1pdCkpIHtcbiAgICAgICAgICAgICAgICAgICAgdmFsaWRhdGVGaWVsZChmaWVsZCwgY29udHJvbC5fbmFtZXMuZGlzYWJsZWQsIGNvbnRyb2wuX2Zvcm1WYWx1ZXMsIGNvbnRyb2wuX29wdGlvbnMuY3JpdGVyaWFNb2RlID09PSBWQUxJREFUSU9OX01PREUuYWxsLCBjb250cm9sLl9vcHRpb25zLnNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24sIHRydWUpLnRoZW4oKGVycm9yKSA9PiAhaXNFbXB0eU9iamVjdChlcnJvcikgJiZcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVycm9yczogdXBkYXRlRmllbGRBcnJheVJvb3RFcnJvcihjb250cm9sLl9mb3JtU3RhdGUuZXJyb3JzLCBlcnJvciwgbmFtZSksXG4gICAgICAgICAgICAgICAgICAgICAgICB9KSk7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wuX3N1YmplY3RzLnN0YXRlLm5leHQoe1xuICAgICAgICAgICAgbmFtZSxcbiAgICAgICAgICAgIHZhbHVlczogY2xvbmVPYmplY3QoY29udHJvbC5fZm9ybVZhbHVlcyksXG4gICAgICAgIH0pO1xuICAgICAgICBjb250cm9sLl9uYW1lcy5mb2N1cyAmJlxuICAgICAgICAgICAgaXRlcmF0ZUZpZWxkc0J5QWN0aW9uKGNvbnRyb2wuX2ZpZWxkcywgKHJlZiwga2V5KSA9PiB7XG4gICAgICAgICAgICAgICAgaWYgKGNvbnRyb2wuX25hbWVzLmZvY3VzICYmXG4gICAgICAgICAgICAgICAgICAgIGtleS5zdGFydHNXaXRoKGNvbnRyb2wuX25hbWVzLmZvY3VzKSAmJlxuICAgICAgICAgICAgICAgICAgICByZWYuZm9jdXMpIHtcbiAgICAgICAgICAgICAgICAgICAgcmVmLmZvY3VzKCk7XG4gICAgICAgICAgICAgICAgICAgIHJldHVybiAxO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICByZXR1cm47XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgY29udHJvbC5fbmFtZXMuZm9jdXMgPSAnJztcbiAgICAgICAgY29udHJvbC5fc2V0VmFsaWQoKTtcbiAgICAgICAgX2FjdGlvbmVkLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9LCBbZmllbGRzLCBuYW1lLCBjb250cm9sXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgIWdldChjb250cm9sLl9mb3JtVmFsdWVzLCBuYW1lKSAmJiBjb250cm9sLl9zZXRGaWVsZEFycmF5KG5hbWUpO1xuICAgICAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgICAgICAgY29uc3QgdXBkYXRlTW91bnRlZCA9IChuYW1lLCB2YWx1ZSkgPT4ge1xuICAgICAgICAgICAgICAgIGNvbnN0IGZpZWxkID0gZ2V0KGNvbnRyb2wuX2ZpZWxkcywgbmFtZSk7XG4gICAgICAgICAgICAgICAgaWYgKGZpZWxkICYmIGZpZWxkLl9mKSB7XG4gICAgICAgICAgICAgICAgICAgIGZpZWxkLl9mLm1vdW50ID0gdmFsdWU7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGNvbnRyb2wuX29wdGlvbnMuc2hvdWxkVW5yZWdpc3RlciB8fCBzaG91bGRVbnJlZ2lzdGVyXG4gICAgICAgICAgICAgICAgPyBjb250cm9sLnVucmVnaXN0ZXIobmFtZSlcbiAgICAgICAgICAgICAgICA6IHVwZGF0ZU1vdW50ZWQobmFtZSwgZmFsc2UpO1xuICAgICAgICB9O1xuICAgIH0sIFtuYW1lLCBjb250cm9sLCBrZXlOYW1lLCBzaG91bGRVbnJlZ2lzdGVyXSk7XG4gICAgcmV0dXJuIHtcbiAgICAgICAgc3dhcDogUmVhY3RfX2RlZmF1bHQudXNlQ2FsbGJhY2soc3dhcCwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICBtb3ZlOiBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhtb3ZlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIHByZXBlbmQ6IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKHByZXBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgYXBwZW5kOiBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhhcHBlbmQsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgcmVtb3ZlOiBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhyZW1vdmUsIFt1cGRhdGVWYWx1ZXMsIG5hbWUsIGNvbnRyb2xdKSxcbiAgICAgICAgaW5zZXJ0OiBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhpbnNlcnQkMSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICB1cGRhdGU6IFJlYWN0X19kZWZhdWx0LnVzZUNhbGxiYWNrKHVwZGF0ZSwgW3VwZGF0ZVZhbHVlcywgbmFtZSwgY29udHJvbF0pLFxuICAgICAgICByZXBsYWNlOiBSZWFjdF9fZGVmYXVsdC51c2VDYWxsYmFjayhyZXBsYWNlLCBbdXBkYXRlVmFsdWVzLCBuYW1lLCBjb250cm9sXSksXG4gICAgICAgIGZpZWxkczogUmVhY3RfX2RlZmF1bHQudXNlTWVtbygoKSA9PiBmaWVsZHMubWFwKChmaWVsZCwgaW5kZXgpID0+ICh7XG4gICAgICAgICAgICAuLi5maWVsZCxcbiAgICAgICAgICAgIFtrZXlOYW1lXTogaWRzLmN1cnJlbnRbaW5kZXhdIHx8IGdlbmVyYXRlSWQoKSxcbiAgICAgICAgfSkpLCBbZmllbGRzLCBrZXlOYW1lXSksXG4gICAgfTtcbn1cblxuLyoqXG4gKiBDdXN0b20gaG9vayB0byBtYW5hZ2UgdGhlIGVudGlyZSBmb3JtLlxuICpcbiAqIEByZW1hcmtzXG4gKiBbQVBJXShodHRwczovL3JlYWN0LWhvb2stZm9ybS5jb20vZG9jcy91c2Vmb3JtKSDigKIgW0RlbW9dKGh0dHBzOi8vY29kZXNhbmRib3guaW8vcy9yZWFjdC1ob29rLWZvcm0tZ2V0LXN0YXJ0ZWQtdHMtNWtzbW0pIOKAoiBbVmlkZW9dKGh0dHBzOi8vd3d3LnlvdXR1YmUuY29tL3dhdGNoP3Y9UmtYdjRBWFhDXzQpXG4gKlxuICogQHBhcmFtIHByb3BzIC0gZm9ybSBjb25maWd1cmF0aW9uIGFuZCB2YWxpZGF0aW9uIHBhcmFtZXRlcnMuXG4gKlxuICogQHJldHVybnMgbWV0aG9kcyAtIGluZGl2aWR1YWwgZnVuY3Rpb25zIHRvIG1hbmFnZSB0aGUgZm9ybSBzdGF0ZS4ge0BsaW5rIFVzZUZvcm1SZXR1cm59XG4gKlxuICogQGV4YW1wbGVcbiAqIGBgYHRzeFxuICogZnVuY3Rpb24gQXBwKCkge1xuICogICBjb25zdCB7IHJlZ2lzdGVyLCBoYW5kbGVTdWJtaXQsIHdhdGNoLCBmb3JtU3RhdGU6IHsgZXJyb3JzIH0gfSA9IHVzZUZvcm0oKTtcbiAqICAgY29uc3Qgb25TdWJtaXQgPSBkYXRhID0+IGNvbnNvbGUubG9nKGRhdGEpO1xuICpcbiAqICAgY29uc29sZS5sb2cod2F0Y2goXCJleGFtcGxlXCIpKTtcbiAqXG4gKiAgIHJldHVybiAoXG4gKiAgICAgPGZvcm0gb25TdWJtaXQ9e2hhbmRsZVN1Ym1pdChvblN1Ym1pdCl9PlxuICogICAgICAgPGlucHV0IGRlZmF1bHRWYWx1ZT1cInRlc3RcIiB7Li4ucmVnaXN0ZXIoXCJleGFtcGxlXCIpfSAvPlxuICogICAgICAgPGlucHV0IHsuLi5yZWdpc3RlcihcImV4YW1wbGVSZXF1aXJlZFwiLCB7IHJlcXVpcmVkOiB0cnVlIH0pfSAvPlxuICogICAgICAge2Vycm9ycy5leGFtcGxlUmVxdWlyZWQgJiYgPHNwYW4+VGhpcyBmaWVsZCBpcyByZXF1aXJlZDwvc3Bhbj59XG4gKiAgICAgICA8YnV0dG9uPlN1Ym1pdDwvYnV0dG9uPlxuICogICAgIDwvZm9ybT5cbiAqICAgKTtcbiAqIH1cbiAqIGBgYFxuICovXG5mdW5jdGlvbiB1c2VGb3JtKHByb3BzID0ge30pIHtcbiAgICBjb25zdCBfZm9ybUNvbnRyb2wgPSBSZWFjdF9fZGVmYXVsdC51c2VSZWYodW5kZWZpbmVkKTtcbiAgICBjb25zdCBfdmFsdWVzID0gUmVhY3RfX2RlZmF1bHQudXNlUmVmKHVuZGVmaW5lZCk7XG4gICAgY29uc3QgW2Zvcm1TdGF0ZSwgdXBkYXRlRm9ybVN0YXRlXSA9IFJlYWN0X19kZWZhdWx0LnVzZVN0YXRlKHtcbiAgICAgICAgaXNEaXJ0eTogZmFsc2UsXG4gICAgICAgIGlzVmFsaWRhdGluZzogZmFsc2UsXG4gICAgICAgIGlzTG9hZGluZzogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKSxcbiAgICAgICAgaXNTdWJtaXR0ZWQ6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdHRpbmc6IGZhbHNlLFxuICAgICAgICBpc1N1Ym1pdFN1Y2Nlc3NmdWw6IGZhbHNlLFxuICAgICAgICBpc1ZhbGlkOiBmYWxzZSxcbiAgICAgICAgc3VibWl0Q291bnQ6IDAsXG4gICAgICAgIGRpcnR5RmllbGRzOiB7fSxcbiAgICAgICAgdG91Y2hlZEZpZWxkczoge30sXG4gICAgICAgIHZhbGlkYXRpbmdGaWVsZHM6IHt9LFxuICAgICAgICBlcnJvcnM6IHByb3BzLmVycm9ycyB8fCB7fSxcbiAgICAgICAgZGlzYWJsZWQ6IHByb3BzLmRpc2FibGVkIHx8IGZhbHNlLFxuICAgICAgICBpc1JlYWR5OiBmYWxzZSxcbiAgICAgICAgZGVmYXVsdFZhbHVlczogaXNGdW5jdGlvbihwcm9wcy5kZWZhdWx0VmFsdWVzKVxuICAgICAgICAgICAgPyB1bmRlZmluZWRcbiAgICAgICAgICAgIDogcHJvcHMuZGVmYXVsdFZhbHVlcyxcbiAgICB9KTtcbiAgICBpZiAoIV9mb3JtQ29udHJvbC5jdXJyZW50KSB7XG4gICAgICAgIGlmIChwcm9wcy5mb3JtQ29udHJvbCkge1xuICAgICAgICAgICAgX2Zvcm1Db250cm9sLmN1cnJlbnQgPSB7XG4gICAgICAgICAgICAgICAgLi4ucHJvcHMuZm9ybUNvbnRyb2wsXG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgICAgIGlmIChwcm9wcy5kZWZhdWx0VmFsdWVzICYmICFpc0Z1bmN0aW9uKHByb3BzLmRlZmF1bHRWYWx1ZXMpKSB7XG4gICAgICAgICAgICAgICAgcHJvcHMuZm9ybUNvbnRyb2wucmVzZXQocHJvcHMuZGVmYXVsdFZhbHVlcywgcHJvcHMucmVzZXRPcHRpb25zKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAgIGNvbnN0IHsgZm9ybUNvbnRyb2wsIC4uLnJlc3QgfSA9IGNyZWF0ZUZvcm1Db250cm9sKHByb3BzKTtcbiAgICAgICAgICAgIF9mb3JtQ29udHJvbC5jdXJyZW50ID0ge1xuICAgICAgICAgICAgICAgIC4uLnJlc3QsXG4gICAgICAgICAgICAgICAgZm9ybVN0YXRlLFxuICAgICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgIH1cbiAgICBjb25zdCBjb250cm9sID0gX2Zvcm1Db250cm9sLmN1cnJlbnQuY29udHJvbDtcbiAgICBjb250cm9sLl9vcHRpb25zID0gcHJvcHM7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGNvbnN0IHN1YiA9IGNvbnRyb2wuX3N1YnNjcmliZSh7XG4gICAgICAgICAgICBmb3JtU3RhdGU6IGNvbnRyb2wuX3Byb3h5Rm9ybVN0YXRlLFxuICAgICAgICAgICAgY2FsbGJhY2s6ICgpID0+IHVwZGF0ZUZvcm1TdGF0ZSh7IC4uLmNvbnRyb2wuX2Zvcm1TdGF0ZSB9KSxcbiAgICAgICAgICAgIHJlUmVuZGVyUm9vdDogdHJ1ZSxcbiAgICAgICAgfSk7XG4gICAgICAgIHVwZGF0ZUZvcm1TdGF0ZSgoZGF0YSkgPT4gKHtcbiAgICAgICAgICAgIC4uLmRhdGEsXG4gICAgICAgICAgICBpc1JlYWR5OiB0cnVlLFxuICAgICAgICB9KSk7XG4gICAgICAgIGNvbnRyb2wuX2Zvcm1TdGF0ZS5pc1JlYWR5ID0gdHJ1ZTtcbiAgICAgICAgcmV0dXJuIHN1YjtcbiAgICB9LCBbY29udHJvbF0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKSA9PiBjb250cm9sLl9kaXNhYmxlRm9ybShwcm9wcy5kaXNhYmxlZCksIFtjb250cm9sLCBwcm9wcy5kaXNhYmxlZF0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy5tb2RlKSB7XG4gICAgICAgICAgICBjb250cm9sLl9vcHRpb25zLm1vZGUgPSBwcm9wcy5tb2RlO1xuICAgICAgICB9XG4gICAgICAgIGlmIChwcm9wcy5yZVZhbGlkYXRlTW9kZSkge1xuICAgICAgICAgICAgY29udHJvbC5fb3B0aW9ucy5yZVZhbGlkYXRlTW9kZSA9IHByb3BzLnJlVmFsaWRhdGVNb2RlO1xuICAgICAgICB9XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLm1vZGUsIHByb3BzLnJlVmFsaWRhdGVNb2RlXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKHByb3BzLmVycm9ycykge1xuICAgICAgICAgICAgY29udHJvbC5fc2V0RXJyb3JzKHByb3BzLmVycm9ycyk7XG4gICAgICAgICAgICBjb250cm9sLl9mb2N1c0Vycm9yKCk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgcHJvcHMuZXJyb3JzXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgcHJvcHMuc2hvdWxkVW5yZWdpc3RlciAmJlxuICAgICAgICAgICAgY29udHJvbC5fc3ViamVjdHMuc3RhdGUubmV4dCh7XG4gICAgICAgICAgICAgICAgdmFsdWVzOiBjb250cm9sLl9nZXRXYXRjaCgpLFxuICAgICAgICAgICAgfSk7XG4gICAgfSwgW2NvbnRyb2wsIHByb3BzLnNob3VsZFVucmVnaXN0ZXJdKTtcbiAgICBSZWFjdF9fZGVmYXVsdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgICAgICBpZiAoY29udHJvbC5fcHJveHlGb3JtU3RhdGUuaXNEaXJ0eSkge1xuICAgICAgICAgICAgY29uc3QgaXNEaXJ0eSA9IGNvbnRyb2wuX2dldERpcnR5KCk7XG4gICAgICAgICAgICBpZiAoaXNEaXJ0eSAhPT0gZm9ybVN0YXRlLmlzRGlydHkpIHtcbiAgICAgICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHtcbiAgICAgICAgICAgICAgICAgICAgaXNEaXJ0eSxcbiAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH0sIFtjb250cm9sLCBmb3JtU3RhdGUuaXNEaXJ0eV0pO1xuICAgIFJlYWN0X19kZWZhdWx0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgICAgIGlmIChwcm9wcy52YWx1ZXMgJiYgIWRlZXBFcXVhbChwcm9wcy52YWx1ZXMsIF92YWx1ZXMuY3VycmVudCkpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3Jlc2V0KHByb3BzLnZhbHVlcywgY29udHJvbC5fb3B0aW9ucy5yZXNldE9wdGlvbnMpO1xuICAgICAgICAgICAgX3ZhbHVlcy5jdXJyZW50ID0gcHJvcHMudmFsdWVzO1xuICAgICAgICAgICAgdXBkYXRlRm9ybVN0YXRlKChzdGF0ZSkgPT4gKHsgLi4uc3RhdGUgfSkpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgY29udHJvbC5fcmVzZXREZWZhdWx0VmFsdWVzKCk7XG4gICAgICAgIH1cbiAgICB9LCBbY29udHJvbCwgcHJvcHMudmFsdWVzXSk7XG4gICAgUmVhY3RfX2RlZmF1bHQudXNlRWZmZWN0KCgpID0+IHtcbiAgICAgICAgaWYgKCFjb250cm9sLl9zdGF0ZS5tb3VudCkge1xuICAgICAgICAgICAgY29udHJvbC5fc2V0VmFsaWQoKTtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLm1vdW50ID0gdHJ1ZTtcbiAgICAgICAgfVxuICAgICAgICBpZiAoY29udHJvbC5fc3RhdGUud2F0Y2gpIHtcbiAgICAgICAgICAgIGNvbnRyb2wuX3N0YXRlLndhdGNoID0gZmFsc2U7XG4gICAgICAgICAgICBjb250cm9sLl9zdWJqZWN0cy5zdGF0ZS5uZXh0KHsgLi4uY29udHJvbC5fZm9ybVN0YXRlIH0pO1xuICAgICAgICB9XG4gICAgICAgIGNvbnRyb2wuX3JlbW92ZVVubW91bnRlZCgpO1xuICAgIH0pO1xuICAgIF9mb3JtQ29udHJvbC5jdXJyZW50LmZvcm1TdGF0ZSA9IGdldFByb3h5Rm9ybVN0YXRlKGZvcm1TdGF0ZSwgY29udHJvbCk7XG4gICAgcmV0dXJuIF9mb3JtQ29udHJvbC5jdXJyZW50O1xufVxuXG5leHBvcnQgeyBDb250cm9sbGVyLCBGb3JtLCBGb3JtUHJvdmlkZXIsIGFwcGVuZEVycm9ycywgY3JlYXRlRm9ybUNvbnRyb2wsIGdldCwgc2V0LCB1c2VDb250cm9sbGVyLCB1c2VGaWVsZEFycmF5LCB1c2VGb3JtLCB1c2VGb3JtQ29udGV4dCwgdXNlRm9ybVN0YXRlLCB1c2VXYXRjaCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9aW5kZXguZXNtLm1qcy5tYXBcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlJlYWN0X19kZWZhdWx0IiwiaXNDaGVja0JveElucHV0IiwiZWxlbWVudCIsInR5cGUiLCJpc0RhdGVPYmplY3QiLCJ2YWx1ZSIsIkRhdGUiLCJpc051bGxPclVuZGVmaW5lZCIsImlzT2JqZWN0VHlwZSIsImlzT2JqZWN0IiwiQXJyYXkiLCJpc0FycmF5IiwiZ2V0RXZlbnRWYWx1ZSIsImV2ZW50IiwidGFyZ2V0IiwiY2hlY2tlZCIsImdldE5vZGVQYXJlbnROYW1lIiwibmFtZSIsInN1YnN0cmluZyIsInNlYXJjaCIsImlzTmFtZUluRmllbGRBcnJheSIsIm5hbWVzIiwiaGFzIiwiaXNQbGFpbk9iamVjdCIsInRlbXBPYmplY3QiLCJwcm90b3R5cGVDb3B5IiwiY29uc3RydWN0b3IiLCJwcm90b3R5cGUiLCJoYXNPd25Qcm9wZXJ0eSIsImlzV2ViIiwid2luZG93IiwiSFRNTEVsZW1lbnQiLCJkb2N1bWVudCIsImNsb25lT2JqZWN0IiwiZGF0YSIsImNvcHkiLCJpc0ZpbGVMaXN0SW5zdGFuY2UiLCJGaWxlTGlzdCIsIlNldCIsIkJsb2IiLCJrZXkiLCJpc0tleSIsInRlc3QiLCJpc1VuZGVmaW5lZCIsInZhbCIsInVuZGVmaW5lZCIsImNvbXBhY3QiLCJmaWx0ZXIiLCJCb29sZWFuIiwic3RyaW5nVG9QYXRoIiwiaW5wdXQiLCJyZXBsYWNlIiwic3BsaXQiLCJnZXQiLCJvYmplY3QiLCJwYXRoIiwiZGVmYXVsdFZhbHVlIiwicmVzdWx0IiwicmVkdWNlIiwiaXNCb29sZWFuIiwic2V0IiwiaW5kZXgiLCJ0ZW1wUGF0aCIsImxlbmd0aCIsImxhc3RJbmRleCIsIm5ld1ZhbHVlIiwib2JqVmFsdWUiLCJpc05hTiIsIkVWRU5UUyIsIkJMVVIiLCJGT0NVU19PVVQiLCJDSEFOR0UiLCJWQUxJREFUSU9OX01PREUiLCJvbkJsdXIiLCJvbkNoYW5nZSIsIm9uU3VibWl0Iiwib25Ub3VjaGVkIiwiYWxsIiwiSU5QVVRfVkFMSURBVElPTl9SVUxFUyIsIm1heCIsIm1pbiIsIm1heExlbmd0aCIsIm1pbkxlbmd0aCIsInBhdHRlcm4iLCJyZXF1aXJlZCIsInZhbGlkYXRlIiwiSG9va0Zvcm1Db250ZXh0IiwiY3JlYXRlQ29udGV4dCIsImRpc3BsYXlOYW1lIiwidXNlRm9ybUNvbnRleHQiLCJ1c2VDb250ZXh0IiwiRm9ybVByb3ZpZGVyIiwicHJvcHMiLCJjaGlsZHJlbiIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsImdldFByb3h5Rm9ybVN0YXRlIiwiZm9ybVN0YXRlIiwiY29udHJvbCIsImxvY2FsUHJveHlGb3JtU3RhdGUiLCJpc1Jvb3QiLCJkZWZhdWx0VmFsdWVzIiwiX2RlZmF1bHRWYWx1ZXMiLCJPYmplY3QiLCJkZWZpbmVQcm9wZXJ0eSIsIl9rZXkiLCJfcHJveHlGb3JtU3RhdGUiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlRm9ybVN0YXRlIiwibWV0aG9kcyIsImRpc2FibGVkIiwiZXhhY3QiLCJ1cGRhdGVGb3JtU3RhdGUiLCJ1c2VTdGF0ZSIsIl9mb3JtU3RhdGUiLCJfbG9jYWxQcm94eUZvcm1TdGF0ZSIsInVzZVJlZiIsImlzRGlydHkiLCJpc0xvYWRpbmciLCJkaXJ0eUZpZWxkcyIsInRvdWNoZWRGaWVsZHMiLCJ2YWxpZGF0aW5nRmllbGRzIiwiaXNWYWxpZGF0aW5nIiwiaXNWYWxpZCIsImVycm9ycyIsIl9zdWJzY3JpYmUiLCJjdXJyZW50IiwiY2FsbGJhY2siLCJfc2V0VmFsaWQiLCJ1c2VNZW1vIiwiaXNTdHJpbmciLCJnZW5lcmF0ZVdhdGNoT3V0cHV0IiwiX25hbWVzIiwiZm9ybVZhbHVlcyIsImlzR2xvYmFsIiwid2F0Y2giLCJhZGQiLCJtYXAiLCJmaWVsZE5hbWUiLCJ3YXRjaEFsbCIsInVzZVdhdGNoIiwiX2RlZmF1bHRWYWx1ZSIsInVwZGF0ZVZhbHVlIiwiX2dldFdhdGNoIiwidmFsdWVzIiwiX2Zvcm1WYWx1ZXMiLCJfcmVtb3ZlVW5tb3VudGVkIiwidXNlQ29udHJvbGxlciIsInNob3VsZFVucmVnaXN0ZXIiLCJpc0FycmF5RmllbGQiLCJhcnJheSIsIl9wcm9wcyIsIl9yZWdpc3RlclByb3BzIiwicmVnaXN0ZXIiLCJydWxlcyIsImZpZWxkU3RhdGUiLCJkZWZpbmVQcm9wZXJ0aWVzIiwiaW52YWxpZCIsImVudW1lcmFibGUiLCJpc1RvdWNoZWQiLCJlcnJvciIsInVzZUNhbGxiYWNrIiwicmVmIiwiZWxtIiwiZmllbGQiLCJfZmllbGRzIiwiX2YiLCJmb2N1cyIsInNlbGVjdCIsInNldEN1c3RvbVZhbGlkaXR5IiwibWVzc2FnZSIsInJlcG9ydFZhbGlkaXR5IiwiX3Nob3VsZFVucmVnaXN0ZXJGaWVsZCIsIl9vcHRpb25zIiwidXBkYXRlTW91bnRlZCIsIm1vdW50IiwiX3N0YXRlIiwiYWN0aW9uIiwidW5yZWdpc3RlciIsIl9zZXREaXNhYmxlZEZpZWxkIiwiQ29udHJvbGxlciIsInJlbmRlciIsImZsYXR0ZW4iLCJvYmoiLCJvdXRwdXQiLCJrZXlzIiwibmVzdGVkIiwibmVzdGVkS2V5IiwiUE9TVF9SRVFVRVNUIiwiRm9ybSIsIm1vdW50ZWQiLCJzZXRNb3VudGVkIiwibWV0aG9kIiwiaGVhZGVycyIsImVuY1R5cGUiLCJvbkVycm9yIiwib25TdWNjZXNzIiwidmFsaWRhdGVTdGF0dXMiLCJyZXN0Iiwic3VibWl0IiwiaGFzRXJyb3IiLCJoYW5kbGVTdWJtaXQiLCJmb3JtRGF0YSIsIkZvcm1EYXRhIiwiZm9ybURhdGFKc29uIiwiSlNPTiIsInN0cmluZ2lmeSIsIl9hIiwiZmxhdHRlbkZvcm1WYWx1ZXMiLCJhcHBlbmQiLCJzaG91bGRTdHJpbmdpZnlTdWJtaXNzaW9uRGF0YSIsInNvbWUiLCJpbmNsdWRlcyIsInJlc3BvbnNlIiwiZmV0Y2giLCJTdHJpbmciLCJib2R5Iiwic3RhdHVzIiwiX3N1YmplY3RzIiwic3RhdGUiLCJuZXh0IiwiaXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0RXJyb3IiLCJGcmFnbWVudCIsIm5vVmFsaWRhdGUiLCJhcHBlbmRFcnJvcnMiLCJ2YWxpZGF0ZUFsbEZpZWxkQ3JpdGVyaWEiLCJ0eXBlcyIsImNvbnZlcnRUb0FycmF5UGF5bG9hZCIsImNyZWF0ZVN1YmplY3QiLCJfb2JzZXJ2ZXJzIiwib2JzZXJ2ZXIiLCJzdWJzY3JpYmUiLCJwdXNoIiwidW5zdWJzY3JpYmUiLCJvIiwib2JzZXJ2ZXJzIiwiaXNQcmltaXRpdmUiLCJkZWVwRXF1YWwiLCJvYmplY3QxIiwib2JqZWN0MiIsImdldFRpbWUiLCJrZXlzMSIsImtleXMyIiwidmFsMSIsInZhbDIiLCJpc0VtcHR5T2JqZWN0IiwiaXNGaWxlSW5wdXQiLCJpc0Z1bmN0aW9uIiwiaXNIVE1MRWxlbWVudCIsIm93bmVyIiwib3duZXJEb2N1bWVudCIsImRlZmF1bHRWaWV3IiwiaXNNdWx0aXBsZVNlbGVjdCIsImlzUmFkaW9JbnB1dCIsImlzUmFkaW9PckNoZWNrYm94IiwibGl2ZSIsImlzQ29ubmVjdGVkIiwiYmFzZUdldCIsInVwZGF0ZVBhdGgiLCJzbGljZSIsImlzRW1wdHlBcnJheSIsInVuc2V0IiwicGF0aHMiLCJjaGlsZE9iamVjdCIsIm9iamVjdEhhc0Z1bmN0aW9uIiwibWFya0ZpZWxkc0RpcnR5IiwiZmllbGRzIiwiaXNQYXJlbnROb2RlQXJyYXkiLCJnZXREaXJ0eUZpZWxkc0Zyb21EZWZhdWx0VmFsdWVzIiwiZGlydHlGaWVsZHNGcm9tVmFsdWVzIiwiZ2V0RGlydHlGaWVsZHMiLCJkZWZhdWx0UmVzdWx0IiwidmFsaWRSZXN1bHQiLCJnZXRDaGVja2JveFZhbHVlIiwib3B0aW9ucyIsIm9wdGlvbiIsImF0dHJpYnV0ZXMiLCJnZXRGaWVsZFZhbHVlQXMiLCJ2YWx1ZUFzTnVtYmVyIiwidmFsdWVBc0RhdGUiLCJzZXRWYWx1ZUFzIiwiTmFOIiwiZGVmYXVsdFJldHVybiIsImdldFJhZGlvVmFsdWUiLCJwcmV2aW91cyIsImdldEZpZWxkVmFsdWUiLCJmaWxlcyIsInJlZnMiLCJzZWxlY3RlZE9wdGlvbnMiLCJnZXRSZXNvbHZlck9wdGlvbnMiLCJmaWVsZHNOYW1lcyIsImNyaXRlcmlhTW9kZSIsInNob3VsZFVzZU5hdGl2ZVZhbGlkYXRpb24iLCJpc1JlZ2V4IiwiUmVnRXhwIiwiZ2V0UnVsZVZhbHVlIiwicnVsZSIsInNvdXJjZSIsImdldFZhbGlkYXRpb25Nb2RlcyIsIm1vZGUiLCJpc09uU3VibWl0IiwiaXNPbkJsdXIiLCJpc09uQ2hhbmdlIiwiaXNPbkFsbCIsImlzT25Ub3VjaCIsIkFTWU5DX0ZVTkNUSU9OIiwiaGFzUHJvbWlzZVZhbGlkYXRpb24iLCJmaWVsZFJlZmVyZW5jZSIsImZpbmQiLCJ2YWxpZGF0ZUZ1bmN0aW9uIiwiaGFzVmFsaWRhdGlvbiIsImlzV2F0Y2hlZCIsImlzQmx1ckV2ZW50Iiwid2F0Y2hOYW1lIiwic3RhcnRzV2l0aCIsIml0ZXJhdGVGaWVsZHNCeUFjdGlvbiIsImFib3J0RWFybHkiLCJjdXJyZW50RmllbGQiLCJzY2hlbWFFcnJvckxvb2t1cCIsImpvaW4iLCJmb3VuZEVycm9yIiwicm9vdCIsInBvcCIsInNob3VsZFJlbmRlckZvcm1TdGF0ZSIsImZvcm1TdGF0ZURhdGEiLCJzaG91bGRTdWJzY3JpYmVCeU5hbWUiLCJzaWduYWxOYW1lIiwiY3VycmVudE5hbWUiLCJza2lwVmFsaWRhdGlvbiIsImlzU3VibWl0dGVkIiwicmVWYWxpZGF0ZU1vZGUiLCJ1bnNldEVtcHR5QXJyYXkiLCJ1cGRhdGVGaWVsZEFycmF5Um9vdEVycm9yIiwiZmllbGRBcnJheUVycm9ycyIsImlzTWVzc2FnZSIsImdldFZhbGlkYXRlRXJyb3IiLCJldmVyeSIsImdldFZhbHVlQW5kTWVzc2FnZSIsInZhbGlkYXRpb25EYXRhIiwidmFsaWRhdGVGaWVsZCIsImRpc2FibGVkRmllbGROYW1lcyIsImlzRmllbGRBcnJheSIsImlucHV0VmFsdWUiLCJpbnB1dFJlZiIsImlzUmFkaW8iLCJpc0NoZWNrQm94IiwiaXNFbXB0eSIsImFwcGVuZEVycm9yc0N1cnJ5IiwiYmluZCIsImdldE1pbk1heE1lc3NhZ2UiLCJleGNlZWRNYXgiLCJtYXhMZW5ndGhNZXNzYWdlIiwibWluTGVuZ3RoTWVzc2FnZSIsIm1heFR5cGUiLCJtaW5UeXBlIiwiZXhjZWVkTWluIiwibWF4T3V0cHV0IiwibWluT3V0cHV0IiwidmFsdWVOdW1iZXIiLCJ2YWx1ZURhdGUiLCJjb252ZXJ0VGltZVRvRGF0ZSIsInRpbWUiLCJ0b0RhdGVTdHJpbmciLCJpc1RpbWUiLCJpc1dlZWsiLCJtYXhMZW5ndGhPdXRwdXQiLCJtaW5MZW5ndGhPdXRwdXQiLCJwYXR0ZXJuVmFsdWUiLCJtYXRjaCIsInZhbGlkYXRlRXJyb3IiLCJ2YWxpZGF0aW9uUmVzdWx0IiwiZGVmYXVsdE9wdGlvbnMiLCJzaG91bGRGb2N1c0Vycm9yIiwiY3JlYXRlRm9ybUNvbnRyb2wiLCJzdWJtaXRDb3VudCIsImlzUmVhZHkiLCJpc1N1Ym1pdHRpbmciLCJ1bk1vdW50IiwiZGVsYXlFcnJvckNhbGxiYWNrIiwidGltZXIiLCJfcHJveHlTdWJzY3JpYmVGb3JtU3RhdGUiLCJzaG91bGREaXNwbGF5QWxsQXNzb2NpYXRlZEVycm9ycyIsImRlYm91bmNlIiwid2FpdCIsImNsZWFyVGltZW91dCIsInNldFRpbWVvdXQiLCJzaG91bGRVcGRhdGVWYWxpZCIsInJlc29sdmVyIiwiX3J1blNjaGVtYSIsImV4ZWN1dGVCdWlsdEluVmFsaWRhdGlvbiIsIl91cGRhdGVJc1ZhbGlkYXRpbmciLCJmcm9tIiwiZm9yRWFjaCIsIl9zZXRGaWVsZEFycmF5IiwiYXJncyIsInNob3VsZFNldFZhbHVlcyIsInNob3VsZFVwZGF0ZUZpZWxkc0FuZFN0YXRlIiwiZmllbGRWYWx1ZXMiLCJhcmdBIiwiYXJnQiIsIl9nZXREaXJ0eSIsInVwZGF0ZUVycm9ycyIsIl9zZXRFcnJvcnMiLCJ1cGRhdGVWYWxpZEFuZFZhbHVlIiwic2hvdWxkU2tpcFNldFZhbHVlQXMiLCJkZWZhdWx0Q2hlY2tlZCIsInNldEZpZWxkVmFsdWUiLCJ1cGRhdGVUb3VjaEFuZERpcnR5IiwiZmllbGRWYWx1ZSIsInNob3VsZERpcnR5Iiwic2hvdWxkUmVuZGVyIiwic2hvdWxkVXBkYXRlRmllbGQiLCJpc1ByZXZpb3VzRGlydHkiLCJpc0N1cnJlbnRGaWVsZFByaXN0aW5lIiwiaXNQcmV2aW91c0ZpZWxkVG91Y2hlZCIsInNob3VsZFJlbmRlckJ5RXJyb3IiLCJwcmV2aW91c0ZpZWxkRXJyb3IiLCJkZWxheUVycm9yIiwidXBkYXRlZEZvcm1TdGF0ZSIsImNvbnRleHQiLCJleGVjdXRlU2NoZW1hQW5kVXBkYXRlU3RhdGUiLCJzaG91bGRPbmx5Q2hlY2tWYWxpZCIsInZhbGlkIiwiaXNGaWVsZEFycmF5Um9vdCIsImlzUHJvbWlzZUZ1bmN0aW9uIiwiZmllbGRFcnJvciIsImdldFZhbHVlcyIsIl9nZXRGaWVsZEFycmF5Iiwib3B0aW9uUmVmIiwic2VsZWN0ZWQiLCJjaGVja2JveFJlZiIsInJhZGlvUmVmIiwic2hvdWxkVG91Y2giLCJzaG91bGRWYWxpZGF0ZSIsInRyaWdnZXIiLCJzZXRWYWx1ZXMiLCJmaWVsZEtleSIsInNldFZhbHVlIiwiY2xvbmVWYWx1ZSIsImlzRmllbGRWYWx1ZVVwZGF0ZWQiLCJfdXBkYXRlSXNGaWVsZFZhbHVlVXBkYXRlZCIsIk51bWJlciIsInZhbGlkYXRpb25Nb2RlQmVmb3JlU3VibWl0IiwidmFsaWRhdGlvbk1vZGVBZnRlclN1Ym1pdCIsInNob3VsZFNraXBWYWxpZGF0aW9uIiwiZGVwcyIsIndhdGNoZWQiLCJwcmV2aW91c0Vycm9yTG9va3VwUmVzdWx0IiwiZXJyb3JMb29rdXBSZXN1bHQiLCJfZm9jdXNJbnB1dCIsImZpZWxkTmFtZXMiLCJQcm9taXNlIiwic2hvdWxkRm9jdXMiLCJnZXRGaWVsZFN0YXRlIiwiY2xlYXJFcnJvcnMiLCJpbnB1dE5hbWUiLCJjdXJyZW50RXJyb3IiLCJjdXJyZW50UmVmIiwicmVzdE9mRXJyb3JUcmVlIiwicGF5bG9hZCIsIl9zZXRGb3JtU3RhdGUiLCJyZVJlbmRlclJvb3QiLCJkZWxldGUiLCJrZWVwVmFsdWUiLCJrZWVwRXJyb3IiLCJrZWVwRGlydHkiLCJrZWVwVG91Y2hlZCIsImtlZXBJc1ZhbGlkYXRpbmciLCJrZWVwRGVmYXVsdFZhbHVlIiwia2VlcElzVmFsaWQiLCJkaXNhYmxlZElzRGVmaW5lZCIsInByb2dyZXNzaXZlIiwiZmllbGRSZWYiLCJxdWVyeVNlbGVjdG9yQWxsIiwicmFkaW9PckNoZWNrYm94IiwiX2ZvY3VzRXJyb3IiLCJfZGlzYWJsZUZvcm0iLCJvblZhbGlkIiwib25JbnZhbGlkIiwiZSIsIm9uVmFsaWRFcnJvciIsInByZXZlbnREZWZhdWx0IiwicGVyc2lzdCIsInNpemUiLCJyZXNldEZpZWxkIiwiX3Jlc2V0Iiwia2VlcFN0YXRlT3B0aW9ucyIsInVwZGF0ZWRWYWx1ZXMiLCJjbG9uZVVwZGF0ZWRWYWx1ZXMiLCJpc0VtcHR5UmVzZXRWYWx1ZXMiLCJrZWVwRGVmYXVsdFZhbHVlcyIsImtlZXBWYWx1ZXMiLCJrZWVwRGlydHlWYWx1ZXMiLCJmaWVsZHNUb0NoZWNrIiwiZm9ybSIsImNsb3Nlc3QiLCJyZXNldCIsImtlZXBTdWJtaXRDb3VudCIsImtlZXBJc1N1Ym1pdHRlZCIsImtlZXBFcnJvcnMiLCJrZWVwSXNTdWJtaXRTdWNjZXNzZnVsIiwic2V0Rm9jdXMiLCJzaG91bGRTZWxlY3QiLCJfcmVzZXREZWZhdWx0VmFsdWVzIiwidGhlbiIsInJlc2V0T3B0aW9ucyIsImZvcm1Db250cm9sIiwiZ2VuZXJhdGVJZCIsImNyeXB0byIsInJhbmRvbVVVSUQiLCJkIiwicGVyZm9ybWFuY2UiLCJub3ciLCJjIiwiciIsIk1hdGgiLCJyYW5kb20iLCJ0b1N0cmluZyIsImdldEZvY3VzRmllbGROYW1lIiwiZm9jdXNOYW1lIiwiZm9jdXNJbmRleCIsImFwcGVuZEF0IiwiZmlsbEVtcHR5QXJyYXkiLCJpbnNlcnQiLCJtb3ZlQXJyYXlBdCIsInRvIiwic3BsaWNlIiwicHJlcGVuZEF0IiwicmVtb3ZlQXRJbmRleGVzIiwiaW5kZXhlcyIsImkiLCJ0ZW1wIiwicmVtb3ZlQXJyYXlBdCIsInNvcnQiLCJhIiwiYiIsInN3YXBBcnJheUF0IiwiaW5kZXhBIiwiaW5kZXhCIiwidXBkYXRlQXQiLCJ1c2VGaWVsZEFycmF5Iiwia2V5TmFtZSIsInNldEZpZWxkcyIsImlkcyIsIl9maWVsZElkcyIsIl9uYW1lIiwiX2FjdGlvbmVkIiwiZmllbGRBcnJheU5hbWUiLCJ1cGRhdGVWYWx1ZXMiLCJ1cGRhdGVkRmllbGRBcnJheVZhbHVlcyIsImFwcGVuZFZhbHVlIiwicHJlcGVuZCIsInByZXBlbmRWYWx1ZSIsInJlbW92ZSIsImluc2VydCQxIiwiaW5zZXJ0VmFsdWUiLCJzd2FwIiwibW92ZSIsInVwZGF0ZSIsIml0ZW0iLCJleGlzdGluZ0Vycm9yIiwidXNlRm9ybSIsIl9mb3JtQ29udHJvbCIsIl92YWx1ZXMiLCJzdWIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(app-pages-browser)/./node_modules/react-hook-form/dist/index.esm.mjs\n"));

/***/ })

},
/******/ function(__webpack_require__) { // webpackRuntimeModules
/******/ var __webpack_exec__ = function(moduleId) { return __webpack_require__(__webpack_require__.s = moduleId); }
/******/ __webpack_require__.O(0, ["main-app"], function() { return __webpack_exec__("(app-pages-browser)/./node_modules/next/dist/build/webpack/loaders/next-flight-client-entry-loader.js?modules=C%3A%5CUsers%5Ctiger%5CDownloads%5Cartistly%5Capp%5Conboard%5Cpage.tsx&server=false!"); });
/******/ var __webpack_exports__ = __webpack_require__.O();
/******/ _N_E = __webpack_exports__;
/******/ }
]);